ASP.Net Interview Questions for Freshers
1. What is ASP.NET?
ASP.NET (Active Server Pages . NET) is a progressive new programming framework that empowers the rapid improvement of powerful web applications and administrations. It is a part of the Microsoft .NET Platform, it gives the simplest and most versatile approach to creating, deploying and running web applications that can focus on any browser or device.ASP.NET is built on the CLR(Common Language Runtime) which allows the programmers to execute its code using any .NET language(C#, VB, etc.). It is specially designed to work with HTTP and for web developers to create dynamic web pages, web applications, websites, and web services as it provides a good integration of HTML, CSS, and JavaScript.

.NET Framework is used to create a variety of applications and services like Console, Web, and Windows, etc. But ASP.NET is only used to create web applications and web services. That’s why we termed ASP.NET as a subset of the .NET Framework.

2. Write down the features of ASP.NET?
There are a lot of reasons which make ASP.NET popular among developers. Some reasons are listed below:

Extending .NET Framework: ASP.NET is a subset of the .NET Framework as it extends the .NET Framework with some libraries and tools to develop web apps. The thing that it adds to the .NET Framework is Libraries for common web patterns like MVC, Editor Extensions, the base framework to process the web requests, and web-page templating syntax like Razor, etc.
Performance: It is faster than the other web frameworks available in the market.
Backend Code: With the help of ASP.NET you can write the backend code for data access and any logic in C#.
Dynamic Pages: In ASP.NET, Razor provides the syntax for developing dynamic web pages with the help of C# and HTML. ASP.NET can be integrated with JavaScript and it also includes the frameworks like React and Angular for the SPA(Single Page Application.)
Supporting different OS: You can develop and execute ASP.NET apps on Windows, Linux, Docker, and macOS. The Visual Studio provides the tools to build .NET apps with different OS.
3. What is Common Language Runtime (CLR)?
CLR is the basic and Virtual Machine component of the .NET Framework. It is the run-time environment in the .NET Framework that runs the codes and helps in making the development process easier by providing various services such as remoting, thread management, type-safety, memory management, robustness, etc. Basically, it is responsible for managing the execution of .NET programs regardless of any .NET programming language. It also helps in the management of code, as code that targets the runtime is known as the Managed Code, and code that doesn’t target to runtime is known as Unmanaged code. 

To read more, you can refer: Common Language Runtime

4. What is ASP.NET MVC framework?
ASP.MVC is a web application framework that is lightweight and has high testable features. ASP.NET supports 3 different types of components namely Model, View, and Controller.

Model Layer: The Model component corresponds to all or any of the data-related logic that the user works with. This will represent either the info that’s being transferred between the View and Controller components or the other business logic-related data. For instance, a Customer object will retrieve the customer information from the database, manipulate it, and update its data back to the database or use it to render data.
View Layer: The View component is employed for all the UI logic of the appliance. For instance, the Customer view will include all the UI components like text boxes, dropdowns, etc. that the ultimate user interacts with.
Controller: Controllers act as an interface between Model and consider components to process all the business logic and incoming requests, manipulate data using the Model component, and interact with the Views to render the ultimate output. For instance, the Customer controller will handle all the interactions and inputs from the Customer View and update the database using the Customer Model. An equivalent controller is going to be wont to view the Customer data.
5. Which would be the right framework to be used ASP.NET MVC or ASP.NET Web API?
ASP.Net MVC is used to make web applications that return the view and data but  Asp.Net Web API is used to make all  HTTP services in a simple and basic way that returns only information, not view.
Web API helps to build REST-ful services over the .NET Framework, and it additionally supports content negotiation, self-facilitating which are not in MVC.
Web API additionally deals with returning information specifically design like JSON, XML, or some other dependent on the Accept header in the solicitation, and you don't stress over that. MVC just returns information in JSON design utilizing Json Result.
6. What is Server control?
ASP.NET has Server Controls features, Which provide facilities to manipulated values of the controls on the Server-Side. This is especially helpful while we want to create validating and dynamically web forms.

7. What is the web.config file?
A configuration file (web.config) is utilized to oversee different settings that characterize a website. The settings are store in XML files that are independent of your application code. In this manner, you can configure settings freely from your code. This file stored inside the application root directory.



8. Which compiler is used in ASP.NET?
To complied an ASP.NET program  .NET framework used the Roslyn compiler.

9. ASP.NET is open-source. Explain?
ASP.NET is an open-source web framework for building web applications on the .NET (dotNET) framework. It is made by Microsoft and variant 1.0 was delivered in 2002 to allow users to develop dynamic web applications, services, and sites. The framework is designed to work with the standard HTTP convention, which is the standard protocol utilized across all web-based applications.  ASP.NET is the replacement to the ASP (Active Server Pages) innovation and was a significant update as far as adaptability and power. It is an expansion of the .NET framework with extra tools and libraries for building things on the web, including web applications and websites.  The ASP.NET cross-plate form version is known as ASP.NET Core, which was delivered in 2016. ASP.NET is still updated and supported.

10. Explain the Global.asax file?
Global.asax is an optional file that resides in the application root directory. This file is used to handle higher-level application events, for example, Application_Start, Application_End, Session_Start, Session_End, and so on. It is additionally known as the ASP.NET Application File..Global.asax contains a Class representing your application as a whole. At run time, this file is parsed and compiled into a dynamically created .NET Framework class derived from the HTTP Application base class. We can convey this file as an assembly in the \bin catalog of an ASP.NET application. The Global.asax record itself is designed so that if a user demands the document, the request is denied. External users can't download or see the code written inside it.

Global.asax file

11. How many types of Server controls are supported by ASP.NET?
There are mainly four different types of  Server-side controls in ASP.NET :

HTML server controls
Web Server controls
User controls
Validation controls
12. What does “PostBack” mean in ASP.NET?
A PostBack is the process of presenting an ASP.NET page to the server for processing. PostBack is done if certain credentials of the page are to be checked against certain sources, (for example, confirmation of username and secret key/password using a database). This is something that a client machine can not able to achieve and subsequently, these details must be 'posted back' on the server. So we can say that a postback event occurs on the client-side but is handled by the code in a copy of the page running on the server.

13. Explain the difference between Web.config and Machine.config file?
There is some key difference between Web.config and Machine.config file below:

The machine.config record is the master configuration document on your framework with a lot of default settings.And Web.config is the file for the local settings to be applied for a website which store configuration information in XML format.
The settings of Machine.config file are applied to the entire asp.net applications on your server while the settings made in the Web.config file are applied to that specific web application only.
Each .NET Framework form has only one machine.config file, simultaneously, each web application has its own web.config file. Directories inside a web application can have web.config files as well.
The machine.config is shared values among numerous applications on the server, while Web.config documents contain application explicit things, for example, database connection strings.
Suppose if you want any improvements in the web.config, then the web application will promptly load the changes but in the machine.config case you should restart the application.
The machine.config document will automatically introduce when you install Visual Studio.Net and it resides in the c:\windows\microsoft.net\framework\version\config folder whereas web.config will automatically be made when you make an ASP.Net web application project.
Machine.config is the design configuration file for all the applications in the IIS, but Web. config is a configuration file for a specific application.
14. Explain the differences between GridView and DataGrid?
Grid View

DataGrid

It was introduced with Asp.Net 2.0.

It was introduced with Asp.Net 1.0.

Built-in supports for Paging and Sorting.

For sorting you need to handle SortCommand event and rebind grid required and for paging, you need to handle the PageIndexChanged event and rebind grid required.,

Built-in supports for Update and Delete operations.

Need to write code for implementing Update and Delete operations.

Supports auto-format or style features.

This feature is not supported.

Performance is slow as compared to DataGrid

Performance is fast as compared to GridView.

15. What is the difference between custom controls and user controls?
User Control

Custom Control

User controls are created just like a web form. They make use of the existing controls to define their own logic.

A custom control is one that is made or created by the programmer to serve the business needs, by extending the functionality of existing controls. 

We can User control easily.

The creation of custom control is not easy as compare to user control

These control do not run on their own dll.

While these control can run on their own dl.

We can not add to the toolbox.

While we can add to the toolbox.we

This control is not flexible.

This control is more flexible.

Once we created a single copy of this control, we can use this copy to different projects as well.

We can not call or use a single copy of this control in different applications. For this, we need to create a control for each and every application.

16. What are web controls in ASP.NET?
Web server controls are powerful than HTML server-side controls. The only difference is that they must have the runat = ”server” attribute set. This attribute makes the control available for server-side programming. Each ASP.NET Server Control is capable of exposing an object model containing properties, methods, and events. This object model can be utilized by the ASP.NET developers to modify and interact with the Web page. Web controls contain all basic controls of HTML controls as well as some new controls like as DataGrid, DataList, and Calendar.

WEB CONTROL

DESCRIPTION

Label

Represents a label control

ListBox

Represents a list box control

CheckBox

Represents a Check box control

Calendar

Represents a calendar control

ImageButton

Represents an image button control

TableCell

Represents a table cell

Panel

Represents a panel control

DataList

Represents a data list control

TextBox

Represents a text box control

Image

Represents an image control

CheckBoxList

Represents a list box with checkboxes

Button

Represents a button control

HyperLink

Represents a hyperlink control

TableRow

Represents a row of a table

RadioButtonList

Represents a list box with radio button controls

DataGrid

Represents a data grid control

DropDownList

Represents a drop-down list control

AdRotator

Represents an ad rotator control

RadioButton

Represents a radio button control

LinkButton

Represents a link button control

Table

Represents a table control

Repeater

Represents a repeater control

17. Describe login Controls in ASP? 
The ASP.NET supports robust login controls for web-based application which does not require any program coding. These login controls coordinate with ASP.NET participation and form authentication to help automated client verification for a server webpage. By default, the ASP.NET login controls work in plain text over HTTP. The ASP.NET supports different types of Login Controls like:

Login Control
LoginView Control
LoginStatus Control
LoginName Control
PasswordRecovery Control
CreateUserWizard Control
ChangePassword Control


18. What are the different validation controls in ASP.NET?
Validation controls in ASP.NET are one of the significant requirements for Web application creation. These controls give the facility to validate user input. By using these controls we can check as a required field, range, custom rules, conditions, etc. An asp.net has 5 different types of validation controls:

RequiredFieldValidator: If we want the user must fill certain compulsory fields then this validation control is used.
CompareValidator: This validation compares user input with a value using a comparison operator such as less than, greater than, and so on.
RangeValidator: This validation checks user’s input values lie within a certain range.
RegularExpressionValidator: It checks the user’s input string matches a defined pattern.
CustomValidator: This validation is used to check user-defined validation conditions.
19. Why do we use CheckBox in .NET?
This control creates a check box on a Web Forms page, allowing users to set a true or false value for the item associated with the control. The properties of the CheckBox are:

Checked: This is true if the checkbox is checked, otherwise false. The default value is false.
TextAlign: TextAlign is the position of the caption. The possible values are Right and Left. The default is Right to align.
Text: This defines the checkbox caption.
<%@ Page Language="C#" AutoEventWireup="true" CodeBehind="WebForm2.aspx.cs"
 Inherits="WebApplication10.WebForm2" %>

<!DOCTYPE html>

<html xmlns="https://www.w3.org/1999/xhtml/">
<head runat="server">
    <title></title>
    <style type="text/css">
        #form1 {}
    </style>
</head>
<body>
    <form id="form1" runat="server">
        <div>
            <br />
            Eligibility criteria for take admission in Master of Technology
            <br />
        </div>
        <asp:CheckBox ID="CheckBox1" runat="server" Text="HSC" />
        <br />
        <asp:CheckBox ID="CheckBox2" runat="server" Text="SSC" />
        / Polytechnic<br />
        <asp:CheckBox ID="CheckBox3" runat="server" Text="BE" />
        <br />
        <br />
        <asp:Button ID="Button1" runat="server" 
        OnClick="Button1_Click" Text="Submit " />

        <asp:Label ID="Label1" runat="server" ForeColor="Lime" 
        Text="Label"></asp:Label>
    </form>
</body>
</html>



Output 1:



Output 2:



20. Explain the HTML server controls in ASP.NET?
HTML Server Controls : HTML elements are exposed to the server. They expose an object model that maps very closely to the HTML elements that they render. You can run these controls on the server by defining the runat ="server" attribute.

CONTROL	DESCRIPTION
HtmlForm	Create an HTML form control, used as a placeholder for other controls.
HtmlInputText	Creates an input text box control used to get input from the user.
HtmltextArea	Creates multi-line text box control.
HtmlAnchor	Creates Web navigation.
HtmlButton	Creates a button control.
HtmlImage	Creates an image control, which is used to display an image.
HtmlInputCheckBox	Creates a checkbox control.
HtmlInputRadioButton	Creates a radio button control.
HtmlTable	Creates a table control.
HtmlTableRow	Creates a row within a table.
HtmlTableCell	Creates a cell within a row.
21. What is LINQ? 
LINQ is known as Language Integrated Query and it is introduced in .NET 3.5 and Visual Studio 2008. The beauty of LINQ is it provides the ability to .NET languages(like C#, VB.NET, etc.) to generate queries to retrieve data from the data source. For example, a program may get information from the student records or accessing employee records, etc. In, past years, such type of data is stored in a separate database from the application, and you need to learn different types of query language to access such types of data like SQL, XML, etc. And also you cannot create a query using C# language or any other .NET language.

To overcome such types of problems Microsoft developed LINQ. It attaches one, more power to the C# or .NET languages to generate a query for any LINQ compatible data source. And the best part is the syntax used to create a query is the same no matter which type of data source is used means the syntax of creating query data in a relational database is the same as that used to create query data stored in an array there is no need to use SQL or any other non-.NET language mechanism. You can also use LINQ with SQL, with XML files, with ADO.NET, with web services, and with any other database.

22. What is ASP.NET Core?
ASP.NET Core is the open-source version of ASP.NET, that can be run on macOS, Linux, and Windows. ASP.NET Core was first delivered in 2016 and is a re-plan of prior Windows-just forms of ASP.NET.

In November 2015, Microsoft released the 5.0 version of ASP.NET which get separated later and known as ASP.NET Core. Also, it is considered as an important redesign of ASP.NET with the feature of open-source and cross-platform. Before this version, ASP.NET is only considered a Windows-only version.

23. What is Razor in ASP.NET?
In ASP.NET, Razor provides the syntax for developing dynamic web pages with the help of C# and HTML. ASP.NET can be integrated with JS(JavaScript) and it also includes the frameworks like React and Angular for the SPA(Single Page Application).

24. What are the types of Authentication in ASP.NET?
Authentication is the process of checking the identity of a user based on the user’s credentials. Generally, user’s credentials are in the form of user ID and password, and we check their credentials from a database or equivalent alternative if it exists then the user is a valid candidate for the next process - authorization. There are different types of Authentication available in ASP.NET namely:

Form Authentication
Passport Authentication
Windows Authentication
Custom Authentication
25. What is Query String in ASP? And what are its advantages and disadvantages?
A QueryString is a collection of characters input to a computer web browser. It is helpful when we want to transfer a value from one page to another page. If the sending data is in large quantity then we can not use Request.QueryString because it supports only 255 characters. We use the ‘&’ special character for separate multiple query strings. Any query string that was available to the calling ASPX page will be available to the called ASPX page.

26. Briefly describe the difference between the Web Site and Web Application?
A web application is a piece of software that can be accessed by the browser. A Browser is an application that is used to browse the internet. Web application needs authentication. The web application uses a combination of server-side scripts and client-side scripts to present information. It requires a server to manage requests from the users. For example, Google Apps

A website is a collection of related web pages that contains images, text, audio, video, etc. It can be consist of one page, two pages, and n number of pages. A website provides visual and text content that users can view and read. To view a website requires a browser(chrome, firefox). There are many types of websites like Archive website, Blog, Community website, Dating website, etc. For example, Amazon, youtube, etc.

27. Explain View State? 
View state is the method that the ASP.NET page framework uses to preserve page and control values between round trips.

<%@ Page Language="C#" AutoEventWireup="true" CodeBehind="WebForm4.aspx.cs" 
Inherits="WebApplication9.WebForm4" %>

<!DOCTYPE html>

<html xmlns="https://www.w3.org/1999/xhtml/">
<head runat="server">
    <title></title>
</head>
<body>
    <form id="form1" runat="server">
       
         <div>
            <h6>Example of View State:</B></h6>
             <p><B><I><U>WELCOME TO GEEKSFORGEEKS</B></I></U></p>
         
            Page Counter:
            
             <br />
             <br />
            
         <asp:Label ID="lblCounter" runat="server" />
             <br />
             <br />
             <br />
             <asp:Button ID="btnIncrement" runat="server" 
             Text="Number of Visitors Count" OnClientClick="btnIncrement_Click"  />
         </div>
      </form>     
</body>
</html>



Output:



28. Explain Cookies in ASP.NET?
A Cookie can be defined as small pieces of information, which can be sent to a  browser by a server program and stored by the internet browser. The internet browser will then, at that point pass the Cookies back to the server each time it makes a request from that server. This is especially helpful for permitting verification/ authentication.

 Suppose, when a user signs in to a password-restricted system, a cookie stores user information (user name, password). So the client doesn't need to re-type their details information for each new page they wish to download. The cookie property gets a collection of the client’s cookie variables.

29. Explain the purpose of Web Services in ASP.NET?
Web services are a web application that is fundamentally a class comprising of methods that could be utilized by different applications. It likewise follows a code-behind design, for example, the ASP.NET pages, despite the fact that it doesn't have a user interface.

ASP.NET Core Advanced Interview Questions
30. Write a step for Request Flow in ASP.NET MVC framework?
The sequence for Request Flow in ASP.NET MVC is as follows:

Request: In this step firstly request is received. After that,  in the Global.asax file, route objects are added to the Route table object.
Routing: At the second step routing is performed. After the application gets from the client, it uses URL Routing Module to deal with the request. The Route Table guides URLs to handlers. A routing is coordinating with a system that matches with the request's URL against the URL patterns which are available in the Route Table. The Routing engine diverts the request to the relating IRouteHandler when the match is found in the pattern. Assuming relating mentioned URL is not found in the routing table, it will return a 404 HTTP status code.
MVC Handler: A RouteHandler responsible for deciding the HTTP handler that will serve the request, according to the received RequestContext.
Controller: In this step, the controller decides which action method is to be executed.
Action Executed: After the controller gets instantiated ActionInvoker will determine which Action method needs to execute. ActionNameSelectorAttribute and ActionMethodSelectorAttribute methods used to select action method. The action method receives user input then executes the result and returning a result type to view.
31. Explain the various modes for the Session state in ASP.NET? 
InProc: Sessions are stored within the application's process on a web server. Depending on the IIS rendition utilized that could be aspnet_wp.exe or w3wp.exe.
StateServer: Sessions are stored by utilizing State Server windows administration service.
SQLServer: SQL Server database is utilized to store sessions' information.
Custom: A custom session state provider manages all the session states.
32. Write down different return types of a controller action method?
View Result
Javascript Result
Redirect Result
JSON Result
Content Result
33. How to maintain sessions in MVC?
We can maintain sessions in MVC using three different ways:

Temp data
Viewdata
View bag
34. How would you explain the differences between Repeater and ListView?
Repeater control is derived from the Control class. A repeater simply repeats data given in templates. Repeated data is usually HTML code mixed with records from the data sources. Repeater's output is not predefined. Because of that, Repeater demands most work to define the template. In return, it gives us the most flexibility to build the layout and optimize the presentation.

With the same template and same data set, Repeater usually works faster than Data List or GridView controls. This is mostly because of the DataReader class, which is used for read-only access. DataReader is faster than DataSet or DataTable classes commonly used with GridView.

Compared to GridView and DataList control, Repeater has limited features. By default, Repeater is good for displaying data. It is not the best choice if you need editing of data. Also, by default, it doesn't provide paging and sorting of records.

ListView control is the newest data presentation control, introduced in ASP.NET 3.5. Previous controls (Repeater, DataList, and GridView) logically follow each other. For example, Repeater is simplest but fastest, then DataList has more features but more overheads too, and finally GridView is most complex, has most features, but heaviest and thus slowest on-page. Now, there is new ListView control that tries to provide the best from both sides: speed and flexibility in design, and also a lot of features like paging, updating or deleting of records, etc. Because of this, ListView control is often a better choice than Repeater or DataList.

35. Describe loginStatus Controls in ASP? 
The ASP.NET supports a robust login controls for web-based application which does not require any program coding. The LoginStatus control is a very simple control, all it does is display a link that is different depending on whether the user is logged in or logged out. If a user is logged in then it displays a LogOut link and vice versa.

There are few properties that it supports, LogOutAction can be used to specify what happens when a user clicks on the LogOutLink, and the options are Redirect, RedirctToLoginPage, Refresh. If we set it to Redirect then we must set another property LogOutPage Url which a user is redirected to after logging out of the website.

<%@ Page Language="C#" AutoEventWireup="true" 
CodeBehind="WebForm1.aspx.cs" Inherits="WebApplication10.WebForm1" %>

<!DOCTYPE html>

<html xmlns="https://www.w3.org/1999/xhtml/">
<head runat="server">
    <title></title>
</head>
<body>
    <form id="form1" runat="server">
        <div>
            Welcome To GeeksForGeeks<br />

            <asp:LoginStatus ID="LoginStatus1" runat="server"
             ForeColor="#CC0000" LoginText="Click here for Login" />
            <br />
            <br />

            <asp:LoginStatus ID="LoginStatus2" runat="server" 
            ForeColor="#CC0000" LoginText="Click here to Logout" />
            <br />
            </div>
    </form>
</body>
</html>



Output:


36. What do you know about JIT?
Just-In-Time(JIT) Compiler: Just-In-Time compiler(JIT) is a part of Common Language Runtime (CLR) in .NET which is responsible for managing the execution of .NET programs regardless of any .NET programming language. A language-specific compiler converts the source code to the intermediate language. This intermediate language is then converted into the machine code by the Just-In-Time (JIT) compiler. This machine code is specific to the computer environment that the JIT compiler runs on. 

To read more, refer to the article: What is Just-In-Time(JIT) Compiler in .NET?

37. What is RedirectPermanent in ASP.Net?
The RedirectPermanent(String) method overload gives a 301 HTTP status code in the reaction and incorporates the URL to divert the request. A 301 HTTP status code is a standard code in an HTTP reaction. It shows that a lasting redirection exists, and it gives the redirection area.

38. What is AJAX in ASP.NET?
The full form of ASP.NET AJAX is Asynchronous JavaScript and XML. ASP.NET AJAX also known as AJAX, is a bunch of augmentations of ASP.NET. It uses asynchronous data transfer between browser and webserver to allow web pages to request small bits of information from the server instead of entire pages. This technique makes Internet applications smaller, faster, and more user-friendly. It is created by Microsoft to execute AJAX functionalities in Web applications. The ASP.NET AJAX works with the AJAX Library that utilization object-arranged programming (OOP) to faster rich Web applications.

39. What is Round Trip in ASP.NET?
At the point when server-side processing is included, then there are four stages included:  

A user requests a Web form from the Web server.
Web Server reacts back with the mentioned Web form.
The user enters the information and submits the webform to the webserver.
Then Web Server processes the form structure and sends the outcomes back to the particular user.
Now, stage 3 is known as a page postback, while stages 3 and 4 are aggregately known as a "roundtrip". We can say that- "A roundtrip includes making a total excursion over the network to the Web browser and getting the reaction back.  The Web applications use HTTP to build up correspondence between the Web program and the Web server. 

40. What is the REST architecture?
REST stands for REpresentational State Transfer.REST is an architectural style that doesn’t follow any strict standard but follows six constraints defined by Roy Fielding in 2000. Those constraints are – Uniform Interface, Client-Server, Stateless, Cacheable, Layered System, Code on Demand.REST is not restricted to XML and it's the choice of implementer which Media-Type to use like XML, JSON, Plain-text. Moreover, REST can use SOAP protocol but SOAP cannot use REST.REST is easy to implement and requires less bandwidth such as smartphones.

Architectural Constraints of RESTful API: There are six architectural constraints that make any web service are listed below:

Uniform Interface
Stateless
Cacheable
Client-Server
Layered System
Code on Demand
41. What is Caching and its different types?
In Asp.Net the caching method allows to store or cache Web Page output. This technic is used to avoiding the overhead of recreating the same data. There are three different caching types available in ASP.NET:

Page Output Caching
Page Fragment Caching
Data Caching
Caching increases the performance parameter if the same data or information is requested by the user.

Page Output Caching: It is implemented by placing an OutputCache directive at the top of the .aspx page at design time.
Data Caching: It is used for quick retrieval of application data and implemented by the Cache object.
Page Fragment Caching: It is used to store part of a Web form response in memory by caching a user control.
42. What does the method Finalize do in ASP.NET?
The Finalize technique is utilized to perform a cleanup procedure on unmanaged resources held by the current object before the object is destroyed. The strategy is ensured and subsequently is available just through this class or through a derived class.

43. Write down the name of all steps in the ASP.NET page life cycle?
Page request
Starting of page life cycle
Page initialization
Page Load
Validation
Postback event handling
Page rendering
Unload
44. What is tracing in .NET?
ASP.NET includes an easy-to-use functionality that helps to debug Web applications. Tracing functionality allows debugging print statements to be inserted into the code to output variables or structures, assert whether a condition is met, or trace through the execution path of the application. Trace feature is used to track particular types of actions in a deployed application as they occur (for example, database connections), and can thus monitor the application’s efficiency. The new tracing features of ASP.NET allow simulating Response.Write() statements. The users need not worry about removing the statements before deploying the applications. Instead of using Response.Write(), Trace.Write() is used. The Trace object is an intrinsic page object, similar to Request, Response, Server, etc. It is accessible directly with the page code.

Trace class: A Trace class is used to get information about Trace. When the Trace property is used, an instance of the TraceContext class is defined in the System.Web namespace. Trace class provides a set of methods and properties that help to trace the execution of code. Instrumentation allows monitoring the health of the application running in real-life settings. Tracing helps to isolate problems and fix them without disturbing a running system.

There are two different ways to enable tracing:

In C# or Managed Extensions for C++, the /d: TRACE flag can be added to the compiler command line. In Visual Basic, the /d: TRACE=True flag can be added to the compiler command line
The #define TRACE can be added to the top of the file. This syntax is compiler-specific. If the user is using a compiler other than the ones specified above, the compiler’s documentation has to be referred to enable conditional compilation
45. Write down different Trace Methods provided in ASP.NET?
Assert() - Checks for a condition, and displays a message if the condition is false.
Close() - Cleanup the output buffer, and then closes the Listeners so that they no longer receive debugging output.
Fail() - This method emits an error message.
GetType() - It is used for "Gets the Type of the Object".
ToString() - Returns a String that represents the current Object
GetHashCode() - This method works like a hash function for a particular type. It is suitable for use in hashing algorithms and data structures like a hash table.
Equals() - Determines whether the specified Object is the same instance as the current Object
Warn() - Writes trace information, along with optional exception data, to the trace log. All warnings appear as red text. It has two forms. The first form writes trace information to the trace log including any user-defined categories.
Write() - Writes trace information to the trace log. It has two forms. The first form writes trace information to the trace log, including any user-defined categories and traces messages.
46. Explain Local Resources and Global Resources?
A local resource is explicit to a specific page, which is the one in particular who can get to it, while global resources can be accessed from any place. Local resources are kept in the App_LocalResources organizer, while global are kept in the App_GlobalResources folder. Local and global resources records will appear to be identical, so the only distinction is the folder they reside in. But they are utilized in different.

47. Write down various page events in ASP.NET?
PreInit
Init
InitComplete
LoadViewState
LoadPostData
PreLoad
Load
LoadComplete
PreRender
PreRenderComplete
SaveStageComplete
UnLoad
48. What is Navigation control in ASP.NET?
Navigation Control is defined as a menu that can be stored in a file to make it easier to maintain. This file is normally called web.Sitemap, and is stored in the root directory of the web. An ASP.NET has three different types of Navigation control:

Dynamic Menus
TreeView
Site Map path
49. Describe TreeView control?
The  TreeView control is made up of nodes. Each entry in the tree is called a node and is represented by a TreeNode object. A node that contains other nodes is called a parent node. A node that is contained by another node is called a child node. A node that has no child nodes is called a leaf node. A node that is not contained by any other node but is the ancestor to all the other nodes in the root node. A node can be both a parent and a child, but root, parent, and leaf nodes are mutually exclusive. Several visual and behavioural properties of nodes are determined by whether a node is a root, parent, or leaf node.

50. Explain ADO.net?
ASP.NET has introduced the next generation of ADO known as ADO.NET with respect to data access. ADO.NET places more emphasis on disconnected recordsets by employing XML as a medium of communication between these record sets and the DataStore.ADO.NET is the latest of the database access technologies that began with the Open Database Connectivity (ODBC) application programming interface (API). Microsoft introduced open database connectivity with the promise of creating a singular common access methodology for databases. ODBC has come a long way since those early days. Almost every major database in use today supports ODBC drivers, and third-party developers provide optimized driver versions. The primary focus of the ODBC is to provide a consistent interface to database data sources.



.NET Interview Questions for Beginners
This set of questions is helpful for beginners to kickstart their preparation.

1. What is .NET, and how does the .NET Framework work?
.NET is a Microsoft platform that develops web, desktop, and mobile applications.

Code written in C#, F#, or VB
Compiled into CIL
Stored as .dll or .exe
The CLR uses JIT to convert CIL into machine code at runtime so it can run on any system architecture.

2. What are the major components of the .NET Framework?
The major components of the .NET Framework are:

CLR – Runs code and handles memory, security, and exceptions
FCL – Predefined methods and types (e.g., System.IO for file operations)
BCL – Core set of reusable classes
CTS – Defines how data types are handled across languages
CLS – Ensures language interoperability
3. What is an EXE and a DLL?
EXE or Executable is a file that runs a program. It is created when you build an app and cannot be reused by other apps.

DLL, or Dynamic Link Library, is a file with reusable code that other programs use. System.Data.dll is an example of a DLL used for database tasks.

4. What are the differences between CTS and CLS?
Feature

CTS (Common Type System)

CLS (Common Language Specification)

Purpose

Defines how types are declared and used.

Sets rules for cross-language compatibility.

Scope

Broad – covers all .NET types.

Narrow – subset of CTS.

Use

Ensures type safety across languages.

Ensures inter-language interoperability.

Developer Impact

Developers follow CTS to define custom types.

Developers follow CLS for compatibility across languages.

5. What is JIT?
JIT, or "Just In Time," is a compiler that, at runtime, transforms the compiled intermediate code (CIL) into machine code so that it may execute on the hardware of the computer. This enhances performance. This enhances performance. JIT compiles methods just before they are executed when a .NET app runs.

Join Simplilearn's Full Stack Java Developer Masters Program and learn everything from Java fundamentals to advanced frameworks. Equip yourself with the tools and knowledge to excel in today’s tech-driven world.
6. What is a garbage collector?
The garbage collector is a virtual machine component that automatically manages memory allocation and deallocation. GC ensures that memory occupied by unused objects is reclaimed. So there are no memory leaks and improved application performance.

7. What is caching?
Storing data in a temporary location, like memory, prevents memory leaks and improves application performance. This is called caching. It helps to quickly access the data later instead of recalculating or fetching it again.

MemoryCache cache = MemoryCache.Default;
cache.Set("username", "John", DateTimeOffset.Now.AddMinutes(10));
string name = cache.Get("username") as string;  // Fast access
8. What is an assembly?
An assembly is a file (.exe or .dll) automatically created by the compiler in .NET. It contains code and resources that work together. It is used to run or share parts of a program.

9. What are the different types of assembly?
There are two types of assemblies:

Private Assembly – Used by one application only. It must be placed in that app’s folder.
Shared (Public) Assembly – Used by many applications. It’s stored in the Global Assembly Cache (GAC). You don't need to place the same assembly in every app’s folder. 
10. What is the difference between managed and unmanaged code?
Feature

Managed Code

Unmanaged Code

Runtime

Runs under CLR

Runs directly on OS

Memory Management

Automatic (Garbage Collected)

Manual

Language Example

C#, VB.NET

C, C++

Safety

More secure

Less secure

Interoperability

Needs wrappers (like P/Invoke)

Direct use

11. What is Microsoft Intermediate Language?
Microsoft Intermediate Language (MSIL) is the low-level code generated by the .NET compiler from your source code. It includes instructions for loading, storing, method calls, and more. At runtime, the JIT compiler converts MSIL into native machine code that runs on your OS.

Example C# code:
Console.WriteLine("Hello");
12. How is ASP.NET different from .NET?
Feature

.NET

ASP.NET

Type

Framework

Web framework (part of .NET)

Usage

Build all app types

Build web apps/services only

Includes

CLR, BCL, etc.

Web Forms, MVC, Web API

Target

Desktop, Mobile, Web, etc.

Web browsers

13. What is cross-page posting?
Cross-page posting happens when a form on one ASP.NET page posts data to a different page, not itself. This is done using the PostBackUrl property of a button.

14. What are the differences between value and reference types in .NET?
Feature

Value Type

Reference Type

Storage

Stack

Heap

Stores

Actual data

Reference (address)

Type Example

int, float, bool, struct

string, class, object

Memory Efficiency

More efficient

Less efficient

Copy Behavior

Creates a copy

Copies the reference

15. What is serialization and deserialization in .NET?
Serialization converts an object into a format (like JSON, XML, or binary) for storage or sending, while deserialization converts that data back into an object.

Example (JSON):
string json = JsonConvert.SerializeObject(obj);
// Serialization
MyClass obj2 = JsonConvert.DeserializeObject<MyClass>(json);
// Deserialization
Become a Software Development Professional
$621.31 Billion
Expected Global Application Development Software Market Size by 2032.
2x Productivity Increase
AmongDevelopers Who Used Generative AI Tools to Complete Tasks.
56% Faster Task Completion
Reported by Developers Using Github Copilot.
Microsoft 
AI-Powered Full Stack Developer Program
Learn through 100+ hours of core curriculum delivered in live online classes by industry experts
Enhance your coding skills using AI-driven tools like ChatGPT, CodeWhisperer, Copilot, and Hugging Face
9 months
View Program
Full Stack Java Developer Masters Program
Full Stack Java Developer Masters Program
Kickstart Full Stack Java Developer career with industry-aligned curriculum by experts
Hands-on practice through 20+ projects, assessments, and tests
7 months
View Program
Here's what learners are saying regarding our programs:
Jonathan Mabiala
Jonathan Mabiala
Java Software Developer, Desjardins
I chose to upskill after moving from the United States to Canada in 2019. My journey in programming began during engineering, but I lost touch after college. Realizing I needed certification to advance, I enrolled in Simplilearn. The live classes boosted my confidence, allowing me to transition to a Java Software Developer role.

Atharv Chavan
Atharv Chavan
Software Development Engineer, PTC
Upskilling with Java Development course transformed my career. The hands-on coding sessions and expert mentorship bridged the gap between theory and real-world application. With enhanced skills, I secured a new job, delivered projects ahead of schedule, and even earned an innovation award—marking a significant milestone in my IT journey.

Not sure what you’re looking for?View all Related Programs
.NET Interview Questions for Experienced Professionals
Are you an experienced professional who wants to brush up on the .NET concepts for your next interview? Here are the .NET interview questions for 5 years of experience:

16. Explain role-based security in .NET
Role-based security in .NET means giving users access based on their assigned roles (like Admin, User, Guest). It helps control what each user can do in an app.

17. What is the order of the events in a page life cycle?
These are the eight key events in the ASP.NET page life cycle. The events are executed in this order to render a page properly:

Page_PreInit – Set master page/theme
Page_Init – Initialize controls
Page_InitComplete – Initialization done
Page_PreLoad – Before Load event
Page_Load – Load data into controls
Page_LoadComplete – Page loading complete
Page_PreRender – Final changes before rendering
Render – Renders HTML to the browser.
18. What is the difference between int and Int32? 
There is no difference. In C#, int is just an alias for System.Int32. Both represent a 32-bit signed integer.

Example:
int a = 10;
System.Int32 b = 20;
19. What is localization and globalization?
Globalization is designing apps to support multiple cultures/languages. Localization is adapting the app to a specific culture (like translating it into Spanish). Some of them are changing dates, currency, or language format based on the region where the user is located.

20. What is MVC?
MVC stands for Model-View-Controller. It is a design pattern used in ASP.NET to build web apps by separating logic, UI, and user input handling. This separation makes code cleaner and easier to manage.

Component

Role

Example

Model

Manages data and logic

Employee data from the database

View

Displays data (UI)

HTML form with employee info

Controller

Handles user input and updates the model/view

Save/Update employee info on button click

21. What is a delegate in .NET?
A delegate in .NET is like a pointer to a method. It holds a reference to a method with a specific signature. It can call that method and even pass it around like a variable. Delegates are also used to define custom events.

Example:
public delegate void MyDelegate(string msg);
void Show(string msg) => Console.WriteLine(msg);
MyDelegate del = Show;
del("Hello from delegate!");
22. What security controls are available on ASP.NET?
ASP.NET provides built-in security controls to manage login, authentication, and password recovery:

Control

Description

<asp:Login>

Displays a login form with user ID and password fields.

<asp:LoginName>

Shows the name of the logged-in user.

<asp:LoginView>

Displays different views for logged-in and anonymous users.

<asp:LoginStatus>

Shows login/logout link based on the user's status.

<asp:PasswordRecovery>

Helps users reset passwords via email.

23. What is boxing and unboxing in .NET?
Boxing converts a value type (like int) into a reference type (object) automatically (implicitly).

Unboxing converts it back to a value type. It's manual (explicit).

Example:
int x = 10;
object obj = x;
// Boxing
int y = (int)obj;
// Unboxing
24. What is MIME in .NET?
MIME stands for Multipurpose Internet Mail Extension. It is a .NET standard that tells the browser or client what type of data is being sent. The data can be an image, audio, or PDF. MIME is used in email and web apps to define content types.

Example MIME types:

text/html for HTML pages
image/png for PNG images
application/pdf for PDF files
25. What is the use of manifest in .NET?
A manifest in .NET is part of an assembly that stores metadata about the assembly. It contains:

Assembly version info
Scope of the assembly
References to other assemblies/classes
Security permissions
This helps the CLR manage and load assemblies correctly.

Boost your career with our Full Stack Developer - MERN Stack Master's program! Gain in-depth expertise in development and testing with the latest technologies. Enroll today and become a skilled MERN Stack Developer!
26. What is the meaning of CAS in .NET?
CAS is Code Access Security. It is part of .NET's built-in security model and restricts what code can do in .NET based on where it came from or who runs it. CAS gives limited permissions to external or risky code to help protect the system, so there is no unauthorized access to resources.

27. What is the appSettings section in the web.config file?
The appSettings section in web.config stores user-defined key-value pairs (like config values) that can be used throughout the application.

Example:
<configuration>
<appSettings>
<add key="ConnectionString"value="server=local;pwd=password;database=default"/>
</appSettings>
</configuration>
Access in C#:
string conn=ConfigurationManager.AppSettings["ConnectionString"];
28. What are the types of memories supported in .NET?
In .NET, there are two types of memory used for managing data:

Stack:

Stores value types (like int or float)
Static memory allocation for method calls and local variables
Heap:

Stores reference types (like objects)
Dynamic memory allocation for data that needs to persist outside method calls
29. What are the parameters that control the connection pooling behaviors?
In .NET connection pooling, the following four parameters control its behavior:

Connect Timeout: Specifies how long it takes for a connection to open before timing out
Min Pool Size: Sets the minimum number of connections in the pool
Max Pool Size: Sets the maximum number of connections allowed in the pool
Pooling: Specifies whether connection pooling is enabled (true) or disabled (false)
30. What are MDI and SDI?
MDI (Multiple Document Interface): Allows multiple child windows within a single parent window. Shared components like toolbars and menus are available across all child windows.
SDI (Single Document Interface): Each document opens in its own separate window with its own set of components, like toolbars and menus. No parent-child relationship exists between Windows.
.NET Core Interview Questions
31. What is .NET Core, and what is it used for?
.NET Core is a cross-platform, open-source framework developed by Microsoft for building modern web, cloud, and IoT applications. It allows you to run applications on Windows, macOS, and Linux.

32. What are .NET Core Components?
.NET Core components are as follows:

Runtime: The environment that runs .NET Core applications
Libraries: A set of class libraries (like ASP.NET Core, Entity Framework Core) for building different types of apps
SDK (Software Development Kit): Provides tools and libraries for building .NET Core applications
CLI (Command-Line Interface): Tools for creating, building, and running .NET Core applications via the command line.
33. What is CoreCLR?
CoreCLR is the runtime execution engine for .NET Core. It includes:

JIT (Just-In-Time) compiler for converting CIL into native code
Garbage collector for memory management
Low-level classes and primitive data types
CoreCLR enables cross-platform execution on Windows and Linux and supports languages like C# and VB.

34. What is CoreRT?
CoreRT is a native runtime for .NET that compiles applications ahead-of-time (AOT), unlike JIT-based runtimes. It is part of the .NET Native project.

No JIT compiler: It compiles code ahead of time, reducing runtime overhead
Supports RTTI and reflection: It still allows runtime type identification and reflection
Efficient with unused code: Unused metadata and code are eliminated, which makes the application more optimized
35. What is the purpose of webHostBuilder()?
The WebHostBuilder() function configures and builds a web host for hosting an ASP.NET Core web application. It uses method chaining to set up the HTTP request pipeline and services (e.g., Use()). Build() creates the necessary services and returns an IWebHost to host the web application. It is part of Microsoft.AspNetCore.Hosting namespace.

36. What is Transfer-Encoding?
Transfer-Encoding is an HTTP header that specifies how the data is transferred between two nodes (e.g., client and server). It is hop-by-hop and is not applied directly to the resource itself. In Chunked Transfer-Encoding, data is sent in chunks, which is useful when the total size of the response is unknown before the request finishes. Each chunk is sent sequentially to the client.

37. What are Zero Garbage Collectors?
Zero Garbage Collectors prevent automatic memory management by not reclaiming unused memory.

Two main uses:

Custom Garbage Collection: This allows you to create your memory management system
Special Use Cases: This is ideal for short-lived applications or applications that do not allocate memory (Zero-alloc programming), where Garbage Collection overhead is unnecessary
38. What is CoreFx?
CoreFX is the set of class libraries for .NET Core that provides essential functionality like collections, console input/output, file systems, XML, JSON, async operations, and more. It is platform-neutral, can run across all platforms, and is implemented as a single portable assembly.

39. What is Explicit Compilation (Ahead Of Time compilation)?
AOT compilation compiles high-level code into low-level code during build time, reducing runtime workload and providing faster startup. It requires more memory and disk space but avoids expensive runtime actions like disk I/O. AOT compilation happens once during build time, making the app smaller and faster.

Example: In Angular, AOT compiles templates during build time for faster rendering:
ng build --prod --aot
40. What is the use of generating SQL scripts in .NET Core?
Generating SQL scripts in .NET Core helps debug or deploy migrations to a production database. These scripts can be reviewed for accuracy. This checks whether the data is correct and can be customized to meet production database requirements.


Not sure what you’re looking for?View all Related Programs
7 Tips to Prepare for a .NET Interview
Now that you have understood the 40 dot net interview questions and answers, it’s time to learn the tips for .NET interview preparation.

1. Master C# Basics
Have ample knowledge of the C# basics. C# syntax, data types, loops, conditions, and basic object-oriented programming (OOP) principles. Inheritance and polymorphism are the top things to cover.

2. Understand .NET Core and ASP.NET Core
You should be clear on the differences between .NET Core and .NET Framework. Learn all the basic differences between the two. You must understand how ASP.NET Core is used for web applications.

3. Learn Entity Framework Core
Be ready to discuss how to perform CRUD operations with EF Core, set up relationships, and understand concepts like migrations and LINQ queries.

4. Practice Unit Testing
Your familiarity with unit testing frameworks is essential. It is helpful if you know how to write unit tests, mock dependencies using Moq, and test for edge cases.

5. Know Dependency Injection (DI)
The concept of DI is also worth getting acquainted with. You must know how to implement it in .NET Core applications and improve maintainability and testability. 

6. Study Common Design Patterns
Do not forget to learn and practice common design patterns because they are often discussed in interviews.  The common ones include Singleton, Factory, Repository, and MVC.

7. Prepare for Problem-Solving Questions
Practice coding problems and algorithms on platforms like LeetCode or HackerRank to improve problem-solving skills and time management.

Conclusion
Learn the dotnet interview questions discussed in the article to tackle interviews and demonstrate proficiency in .NET development. You can take a step further to enhance your career. Check out Simplilearn's Full Stack (MERN Stack) Developer Master's Program in collaboration with IBM. This live, online, and interactive course will teach you the in-demand skills and prepare you for real-world scenarios.

FAQs
1. What is the difference between .NET Framework and .NET Core?
The .NET framework serves only Windows, while .NET Core supports multiple systems. Similarly, the latter lacks a few functionalities in the .NET framework.

2. Which language is best for .NET development?
C# is the top choice of language owing to its general purpose language, wide usage and great support system.

3. What should I know about .NET for a full-stack developer role?
Focus on the .NET framework and familiarity with front-end technologies and back-end development are essential to fulfilling the role's responsibilities.

1. What is .NET?

.NET is a software development framework created by Microsoft. It provides a platform for building and running applications across different environments (Windows, Linux, macOS, and cloud). It includes:

.NET runtime (to run applications).

Class libraries (pre-built reusable code).

Languages (like C#, F#, VB.NET).

Tools (like Visual Studio).

In short, .NET is a cross-platform, open-source framework for building web, desktop, mobile, cloud, gaming, and IoT applications.

2. Can you explain the Common Language Runtime (CLR)?

The CLR is the execution engine of .NET. It manages the life cycle of applications written in .NET languages.
Key responsibilities include:

Memory management (garbage collection).

Type safety.

Exception handling.

Thread management.

JIT (Just-In-Time) compilation of Intermediate Language (IL) code to machine code.

Basically, CLR makes sure that .NET applications run efficiently and securely.

3. What is the difference between managed and unmanaged code?

Managed code: Code executed by the CLR. Examples: C#, F#. It benefits from garbage collection, type safety, and memory management.

Unmanaged code: Code executed directly by the operating system, outside CLR. Examples: C, C++, assembly. Developers must manage memory and handle errors manually.

4. Explain the basic structure of a C# program.

A simple C# program typically includes:

using System;   // Namespace import

namespace HelloWorldApp  // Namespace declaration
{
    class Program        // Class declaration
    {
        static void Main(string[] args)  // Entry point
        {
            Console.WriteLine("Hello, World!");
        }
    }
}


Structure breakdown:

using → Imports namespaces.

namespace → Groups related classes.

class → Contains code (methods, variables).

Main → Entry point of the program.

5. What are Value Types and Reference Types in C#?

Value Types:

Store data directly in memory.

Examples: int, double, bool, struct, enum.

Stored in the stack (faster).

Reference Types:

Store a reference (address) pointing to data.

Examples: class, array, string, object.

Data is stored in the heap (managed by CLR).

6. What is garbage collection in .NET?

Garbage Collection (GC) is the automatic memory management process in .NET.

It identifies objects in the heap that are no longer referenced.

Frees up memory without requiring the developer to manually release it.

Runs in generations (Gen 0, Gen 1, Gen 2) for efficiency.

This helps prevent memory leaks and improves stability.

7. Explain the concept of exception handling in C#.

Exception handling is the mechanism to handle runtime errors gracefully.
It uses:

try → Code block to test.

catch → Handles exceptions if they occur.

finally → Executes always (cleanup code).

throw → Manually raise exceptions.

Example:

try
{
    int x = 10 / 0; // Exception
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("You cannot divide by zero!");
}
finally
{
    Console.WriteLine("Execution finished.");
}

8. What are the different types of classes in C#?

Static class → Cannot be instantiated, contains only static members.

Sealed class → Cannot be inherited.

Abstract class → Cannot be instantiated, used for base definitions, can have abstract methods.

Partial class → Definition can be split across multiple files.

Concrete class → A normal class that can be instantiated.

9. Can you describe what a namespace is and how it is used in C#?

A namespace is a logical grouping of classes, interfaces, enums, and structs.

Prevents naming conflicts.

Makes code organized and modular.

Example:

namespace ECommerce.Orders
{
    class OrderService { }
}


To use it:

using ECommerce.Orders;

10. What is encapsulation?

Encapsulation is one of the four pillars of OOP.
It means bundling data (fields) and methods (functions) together and restricting direct access to some of the object's components.

Achieved using access modifiers (private, public, protected).

Ensures data hiding and controlled access.

Example:

class Account
{
    private double balance;  // Hidden field

    public void Deposit(double amount)
    {
        balance += amount;   // Controlled access
    }

    public double GetBalance()
    {
        return balance;
    }
}


✅ Would you like me to prepare short interview-style answers (1–2 sentences each) so you can use them directly in a job interview setting?

Here’s a structured explanation for each of your new questions:

---

### **1. Explain polymorphism and its types in C#.**

Polymorphism means **"many forms"** — it allows the same method or object to behave differently based on context.
Types:

* **Compile-time (Static) polymorphism** → Achieved via **method overloading** and **operator overloading**.
* **Runtime (Dynamic) polymorphism** → Achieved via **method overriding** using `virtual`, `override`, and `abstract` keywords.

Example:

```csharp
class Shape { public virtual void Draw() => Console.WriteLine("Drawing shape"); }
class Circle : Shape { public override void Draw() => Console.WriteLine("Drawing circle"); }
```

---

### **2. What are delegates and how are they used in C#?**

A **delegate** is a **type-safe function pointer** that allows methods to be passed as parameters.
They are used for **callbacks, event handling, and LINQ expressions**.

Example:

```csharp
public delegate void Notify(string msg);

class Program
{
    static void Main()
    {
        Notify notify = ShowMessage;
        notify("Hello World!");
    }

    static void ShowMessage(string msg) => Console.WriteLine(msg);
}
```

---

### **3. Describe what LINQ is and give an example of where it might be used.**

LINQ (**Language Integrated Query**) allows querying collections, databases, XML, or objects in a **SQL-like** manner directly in C#.

Example (filtering a list):

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var evens = numbers.Where(n => n % 2 == 0);
```

Usage: Data filtering, joins, grouping, and aggregation over collections or databases.

---

### **4. What is the difference between an abstract class and an interface?**

* **Abstract class**:

  * Can have **implementation + abstract methods**.
  * Supports **fields, constructors, access modifiers**.
  * A class can inherit from **one abstract class only**.

* **Interface**:

  * Contains **only definitions (no fields, no constructors)**.
  * Supports **multiple inheritance**.
  * All members are **public and abstract by default**.

---

### **5. How do you manage memory in .NET applications?**

Memory is managed mainly by the **CLR’s garbage collector (GC)**, which frees unused objects in the heap.
Best practices for memory management:

* Dispose unmanaged resources (`IDisposable`, `using`).
* Minimize object creation in loops.
* Use **structs** for small, short-lived data.
* Avoid memory leaks by unsubscribing events.

---

### **6. Explain the concept of threading in .NET.**

Threading allows multiple tasks to run concurrently.

* **Main thread** runs the application.
* Developers can create **worker threads** using `Thread`, `ThreadPool`, or `Task Parallel Library (TPL)`.
* Helps improve performance in CPU-bound or I/O-bound operations.

Example:

```csharp
new Thread(() => Console.WriteLine("Running in another thread")).Start();
```

---

### **7. What is async/await and how does it work?**

`async/await` provides **asynchronous programming** support without blocking threads.

* **async** marks a method as asynchronous.
* **await** pauses execution until the awaited task completes, freeing the thread for other work.

Example:

```csharp
async Task FetchDataAsync()
{
    var response = await httpClient.GetStringAsync("https://api.com/data");
    Console.WriteLine(response);
}
```

---

### **8. Describe the Entity Framework and its advantages.**

Entity Framework (EF) is an **ORM (Object-Relational Mapper)** for .NET. It maps database tables to C# classes.

**Advantages:**

* Reduces boilerplate SQL code.
* Strongly-typed queries with LINQ.
* Supports migrations and schema updates.
* Cross-database support (SQL Server, PostgreSQL, MySQL, etc.).

---

### **9. What are extension methods and where would you use them?**

An **extension method** allows adding new methods to existing classes **without modifying them**.

* Defined in a `static` class.
* Must use `this` keyword before the parameter type.

Example:

```csharp
public static class StringExtensions
{
    public static bool IsEmpty(this string str) => string.IsNullOrWhiteSpace(str);
}

Console.WriteLine("".IsEmpty()); // true
```

**Usage:** Add utility functions to built-in or third-party classes.

---

### **10. How do you handle exceptions in a method that returns a Task?**

In async methods, exceptions are wrapped inside the `Task`.

* Use `try-catch` inside the method.
* Or handle with `.ContinueWith()` or `await` at the caller level.

Example:

```csharp
public async Task<int> DivideAsync(int a, int b)
{
    try
    {
        return await Task.Run(() => a / b);
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
        return -1; // fallback
    }
}
```

---

✅ Do you want me to also prepare **a compact “interview-quick answer” version** of all these so you can memorize and answer confidently in a real interview?

Great set of advanced .NET/ASP.NET Core questions 👍 Here’s a clear, detailed explanation for each:

---

### **1. What is reflection in .NET and how would you use it?**

Reflection is the process of **inspecting metadata** about assemblies, modules, and types at runtime.

* Lets you discover **methods, properties, attributes, and constructors** dynamically.
* Enables creating/using objects without knowing their type at compile time.

**Example use cases:**

* Dependency injection frameworks.
* ORMs (Entity Framework mapping).
* Plugins & dynamic loading.

```csharp
var type = typeof(Customer);
foreach (var prop in type.GetProperties())
    Console.WriteLine(prop.Name);
```

---

### **2. Can you explain the concept of middleware in ASP.NET Core?**

Middleware are **components in the HTTP request/response pipeline**.

* Each middleware processes the request and decides to **pass it to the next** or stop the pipeline.
* Implemented via `RequestDelegate`.

**Example (Logging Middleware):**

```csharp
app.Use(async (context, next) =>
{
    Console.WriteLine($"Request: {context.Request.Path}");
    await next();
    Console.WriteLine($"Response: {context.Response.StatusCode}");
});
```

---

### **3. Describe the Dependency Injection (DI) pattern and how it's implemented in .NET Core.**

DI is a design pattern where **dependencies are injected** rather than created inside a class.

* Promotes **loose coupling, testability, maintainability**.

In ASP.NET Core, DI is built-in. Services are registered in `Program.cs`:

```csharp
builder.Services.AddTransient<IEmailService, EmailService>();
```

And consumed via constructor injection:

```csharp
public class OrderController
{
    private readonly IEmailService _emailService;
    public OrderController(IEmailService emailService) => _emailService = emailService;
}
```

---

### **4. What is the purpose of the .NET Standard?**

.NET Standard is a **formal specification of APIs** that all .NET implementations must support.

* Ensures code sharing across **.NET Framework, .NET Core, Xamarin, Mono**.
* Example: A library targeting `.NET Standard 2.0` can run on any platform that supports that version.

---

### **5. Explain the differences between .NET Core, .NET Framework, and Xamarin.**

* **.NET Framework** → Windows-only, mature but not cross-platform.
* **.NET Core** → Cross-platform, open-source, modular.
* **Xamarin** → Used for **mobile apps** (iOS, Android) with C# and .NET libraries.

Today, these are unified under **.NET 5+ (modern .NET)**.

---

### **6. How does garbage collection work in .NET and how can you optimize it?**

* .NET GC manages **heap memory** automatically.
* Objects are collected when they are no longer referenced.
* Uses **generational collection (Gen 0, 1, 2)** for efficiency.

**Optimizations:**

* Use `using` or `Dispose()` for unmanaged resources.
* Avoid large object allocations unless necessary.
* Reduce event subscription leaks (unsubscribe when done).
* Use **Span<T>, ArrayPool<T>** for high-performance apps.

---

### **7. What are attributes in C# and how can they be used?**

Attributes are **metadata applied to code elements** (classes, methods, properties).

* Retrieved via **reflection**.
* Used by frameworks/tools (e.g., `[Obsolete]`, `[HttpGet]`, `[Required]`).

Example:

```csharp
[Obsolete("Use NewMethod instead")]
public void OldMethod() { }
```

Custom attribute:

```csharp
[AttributeUsage(AttributeTargets.Class)]
public class MyCustomAttribute : Attribute { }
```

---

### **8. Can you describe the process of code compilation in .NET?**

1. **C# code → IL (Intermediate Language)** via Roslyn compiler.
2. IL stored in assemblies (`.dll`/`.exe`).
3. **CLR JIT compiler** converts IL → machine code at runtime.
4. Optionally, **RyuJIT + tiered compilation** optimize hot paths.

---

### **9. What is the Global Assembly Cache (GAC) and when should it be used?**

* GAC is a **machine-wide repository** for shared .NET assemblies.
* Assemblies in GAC must be **strongly named** (unique name, version, public key).
* Useful when:

  * Multiple applications need the **same shared library**.
  * Version management across applications is required.

⚠️ In modern .NET (Core/5+), **GAC is not used** — assemblies are app-local.

---

### **10. How would you secure a web application in ASP.NET Core?**

Best practices:

* **Authentication & Authorization** → Identity, JWT, OAuth2, OpenID Connect.
* **Data protection** → HTTPS, HSTS, encryption.
* **Input validation & model binding** → prevent SQL injection/XSS.
* **CSRF protection** → `[ValidateAntiForgeryToken]`.
* **Secret management** → Azure Key Vault, AWS Secrets Manager, `dotnet user-secrets`.
* **Logging & monitoring** → Serilog, NewRelic, CloudWatch.
* **Rate limiting & throttling** for APIs.

---

✅ Would you like me to prepare a **tabular “cheat sheet” version** (Question | Short Answer | Example) of all these so you can use it as a quick interview revision guide?

Perfect — you’re asking all the right ASP.NET Core interview-style questions 👌
Here are **clear, structured answers with examples**:

---

### **1. What is MVC (Model-View-Controller)?**

MVC is a **design pattern** that separates an application into three parts:

* **Model** → Data and business logic.
* **View** → UI, displays data.
* **Controller** → Handles requests, interacts with Model, selects View.

👉 Helps maintainability, testability, and separation of concerns.

---

### **2. Difference between Razor Pages and MVC in ASP.NET Core**

* **MVC** → Follows `Controller → View` pattern. Best for large, complex apps with many controllers and views.
* **Razor Pages** → Page-based programming model. Each page (`.cshtml + .cshtml.cs`) handles its own UI + logic.
* Razor Pages = **lightweight, simple** for CRUD-style apps.
* MVC = **better structure** for enterprise-level applications.

---

### **3. How do you perform validations in ASP.NET Core?**

Validation is done using **Data Annotations** + **ModelState**.

* Example:

```csharp
public class User
{
    [Required]
    [StringLength(50)]
    public string Name { get; set; }

    [Range(18, 60)]
    public int Age { get; set; }
}
```

In controller:

```csharp
if (ModelState.IsValid) { /* process */ }
```

For advanced rules → use **FluentValidation**.

---

### **4. Describe SignalR and its use cases.**

SignalR is a **real-time communication library** in ASP.NET Core.

* Supports **WebSockets, Server-Sent Events, Long Polling**.
* Enables **bi-directional communication** between server and client.

**Use cases:**

* Chat apps.
* Live dashboards.
* Notifications (stock price updates, IoT devices).
* Multiplayer games.

---

### **5. Benefits of using Blazor over traditional web technologies**

Blazor allows building **interactive web UIs using C# instead of JavaScript**.
**Benefits:**

* Full-stack development with **one language (C#)**.
* **Code sharing** between client and server.
* Rich component model.
* Runs in **browser (WebAssembly)** or **server** mode.
* Integrates with existing .NET libraries easily.

---

### **6. How do you implement Web API versioning in ASP.NET Core?**

Use **Microsoft.AspNetCore.Mvc.Versioning** package.

* Register in `Program.cs`:

```csharp
builder.Services.AddApiVersioning(options =>
{
    options.AssumeDefaultVersionWhenUnspecified = true;
    options.DefaultApiVersion = new ApiVersion(1, 0);
    options.ReportApiVersions = true;
});
```

* Apply versions:

```csharp
[ApiVersion("1.0")]
[Route("api/v{version:apiVersion}/[controller]")]
public class UsersController : ControllerBase { }
```

---

### **7. Explain the role of IApplicationBuilder in ASP.NET Core.**

`IApplicationBuilder` is used in the **middleware pipeline configuration** (`Program.cs`).

* Adds middleware components like `UseRouting`, `UseAuthentication`, `UseEndpoints`.
* Example:

```csharp
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();
app.UseEndpoints(endpoints =>
{
    endpoints.MapControllers();
});
```

---

### **8. What are Areas in ASP.NET Core and how do you use them?**

Areas are a way to **partition a large application into smaller functional modules**.

* Each Area has its own **Controllers, Views, Models**.
* Example:

  * `/Areas/Admin/Controllers/DashboardController.cs`
  * `/Areas/Customer/Controllers/OrderController.cs`

Enable in routing:

```csharp
endpoints.MapControllerRoute(
    name: "areas",
    pattern: "{area:exists}/{controller=Home}/{action=Index}/{id?}");
```

---

### **9. How do you manage sessions in ASP.NET Core applications?**

1. Add session services:

```csharp
builder.Services.AddSession();
```

2. Use session middleware:

```csharp
app.UseSession();
```

3. Store/Retrieve session values:

```csharp
HttpContext.Session.SetString("UserName", "Emrah");
var user = HttpContext.Session.GetString("UserName");
```

---

### **10. Describe how to implement caching in ASP.NET Core.**

ASP.NET Core provides **3 types of caching**:

1. **In-Memory Caching** → Stores data in server memory.

```csharp
builder.Services.AddMemoryCache();
cache.Set("key", "value", TimeSpan.FromMinutes(5));
```

2. **Distributed Caching** → Stores data in external cache (Redis, SQL Server).

```csharp
builder.Services.AddStackExchangeRedisCache(options => { options.Configuration = "localhost"; });
```

3. **Response Caching** → Caches HTTP responses.

```csharp
app.UseResponseCaching();
[ResponseCache(Duration = 60)]
```

---

✅ Do you want me to prepare a **side-by-side comparison table** for Razor Pages vs MVC vs Blazor vs Web API so you can quickly recall differences in interviews?

Great — you’re asking **senior-level .NET interview questions** 👌
Here’s a **structured breakdown with detailed answers + examples**:

---

### **1. What is Unit Testing in .NET?**

Unit Testing is the process of **testing individual units of code (methods, classes)** in isolation.

* Ensures correctness, reliability, and maintainability.
* In .NET, common frameworks are **xUnit, NUnit, MSTest**.

Example (xUnit):

```csharp
[Fact]
public void Add_ShouldReturnSum()
{
    var calc = new Calculator();
    var result = calc.Add(2, 3);
    Assert.Equal(5, result);
}
```

---

### **2. How do you mock dependencies in unit tests using .NET?**

Mocking isolates the **class under test** by simulating dependencies.

* Common library: **Moq**.

Example:

```csharp
var mockRepo = new Mock<IUserRepository>();
mockRepo.Setup(r => r.GetUserById(1)).Returns(new User { Id = 1, Name = "Emrah" });

var service = new UserService(mockRepo.Object);
var result = service.GetUserName(1);

Assert.Equal("Emrah", result);
```

---

### **3. Can you explain SOLID principles?**

* **S – Single Responsibility Principle** → One class = one responsibility.
* **O – Open/Closed Principle** → Open for extension, closed for modification.
* **L – Liskov Substitution Principle** → Subclasses should be usable in place of their base classes.
* **I – Interface Segregation Principle** → Prefer small, specific interfaces.
* **D – Dependency Inversion Principle** → Depend on abstractions, not concrete implementations.

👉 Ensures clean, maintainable, extensible architecture.

---

### **4. What is Continuous Integration/Continuous Deployment (CI/CD) and how does it apply to .NET development?**

* **CI** → Automates building, testing, and code integration.
* **CD** → Automates deployment to environments (Dev, Test, Prod).
* In .NET:

  * Build pipelines (Azure DevOps, GitLab, GitHub Actions).
  * Run unit tests automatically.
  * Deploy Docker containers or apps to **Azure, AWS, Kubernetes, IIS**.

---

### **5. How do you ensure your C# code is secure?**

* **Authentication & Authorization** (ASP.NET Identity, JWT).
* **Input validation** → Avoid SQL injection/XSS.
* **Encrypt sensitive data** (`DataProtection`, AES, Hashing).
* **Use HTTPS/HSTS** always.
* **Follow OWASP guidelines**.
* **Secure secrets** in **Azure Key Vault, AWS Secrets Manager** instead of config files.

---

### **6. Common performance issues in .NET and how to address them**

* **High GC pressure** → Optimize allocations, use `Span<T>`/`ArrayPool<T>`.
* **Unoptimized database calls** → Use async queries, caching, indexing.
* **Blocking async calls** → Avoid `.Result` or `.Wait()`.
* **Inefficient LINQ** → Avoid multiple enumerations, use `ToList()` carefully.
* **Large object allocations** → Use value types or object pooling.

Tools: **dotMemory, dotTrace, PerfView, Application Insights, AWS CloudWatch**.

---

### **7. Describe the Repository pattern and its benefits.**

Repository pattern abstracts **data access logic** from business logic.

* Encapsulates queries and persistence.
* Promotes **testability, separation of concerns, maintainability**.

Example:

```csharp
public interface ICustomerRepository
{
    Task<Customer> GetByIdAsync(int id);
    Task AddAsync(Customer customer);
}
```

Benefits:

* Centralized data access.
* Easier to mock/test.
* Swap data sources (SQL, NoSQL, API).

---

### **8. How do you handle database migrations in Entity Framework?**

* EF Core provides **code-based migrations**.
* Steps:

```bash
dotnet ef migrations add InitialCreate
dotnet ef database update
```

* Migrations track schema changes → easy deployment.
* Use **DbContext** + `OnModelCreating()` for schema definitions.

---

### **9. What tools do you use for debugging and profiling .NET applications?**

* **Visual Studio Debugger** (breakpoints, watch, immediate window).
* **dotTrace / dotMemory (JetBrains)**.
* **PerfView** (low-level performance).
* **Application Insights / New Relic / CloudWatch** for production monitoring.
* **Serilog + Structured Logging** for tracing.

---

### **10. How do you stay updated with the latest .NET technologies and practices?**

* **Official sources** → .NET Blog (Microsoft), GitHub repos.
* **Community** → StackOverflow, Reddit (.NET), LinkedIn groups.
* **Podcasts & YouTube** → .NET Rocks, Channel 9, conferences (Build, Ignite).
* **Hands-on practice** → Side projects, upgrading apps to latest .NET version.
* **Newsletters & Blogs** → Scott Hanselman, Microsoft Docs updates.

---

✅ Do you want me to now prepare a **final interview “cheat sheet”** (all the Q\&A we covered so far summarized into a 3-column Markdown table: *Question | Short Answer | Example*) so you have it as a compact revision guide?

Excellent 👌 These are **core SQL/DB interview questions** that often come up at senior developer/architect levels.
Here’s a **comprehensive breakdown**:

---

### **1. Difference between INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN**

* **INNER JOIN** → Returns rows with matching values in both tables.
* **LEFT JOIN** → Returns all rows from the left table, plus matches from the right.
* **RIGHT JOIN** → Returns all rows from the right table, plus matches from the left.
* **FULL JOIN** → Returns all rows from both tables, with NULLs where no match exists.

---

### **2. Primary Key vs Unique Key**

* **Primary Key**:

  * Uniquely identifies each row.
  * Only one per table.
  * Cannot be NULL.
* **Unique Key**:

  * Ensures column values are unique.
  * Multiple allowed per table.
  * Can contain a single NULL.

---

### **3. Foreign Keys & Referential Integrity**

* **Foreign Key** → Column that refers to the Primary Key in another table.
* **Referential Integrity** → Ensures consistency (e.g., can’t insert an order with a non-existent customer ID).

---

### **4. Normalization & Normal Forms**

Process of organizing data to **reduce redundancy**.

* **1NF** → Atomic values, no repeating groups.
* **2NF** → 1NF + no partial dependency on composite key.
* **3NF** → 2NF + no transitive dependency.
* **BCNF** → Stronger version of 3NF.
* **4NF/5NF** → Handle multi-valued dependencies & join dependencies.

---

### **5. Clustered vs Non-Clustered Index**

* **Clustered Index**:

  * Defines **physical order of data**.
  * One per table.
* **Non-Clustered Index**:

  * Separate structure pointing to data rows.
  * Multiple allowed per table.

---

### **6. Transactions & ACID**

* **Transaction** → Group of SQL operations executed as a single unit.
* **ACID properties**:

  * **Atomicity** → All or nothing.
  * **Consistency** → Maintains valid state.
  * **Isolation** → Transactions don’t interfere.
  * **Durability** → Changes persist after commit.

---

### **7. DELETE vs TRUNCATE vs DROP**

* **DELETE** → Removes rows (can filter with WHERE). Logged. Rollback possible.
* **TRUNCATE** → Removes all rows. Faster, minimal logging. Cannot filter.
* **DROP** → Removes entire table structure and data.

---

### **8. Window Functions**

Functions that operate on a set of rows **related to the current row**.

* Examples: `ROW_NUMBER()`, `RANK()`, `SUM() OVER(...)`.
* Used for running totals, ranking, pagination.

---

### **9. Common Table Expression (CTE) vs Subquery**

* **CTE** → Temporary result set defined with `WITH`. Improves readability, supports recursion.
* **Subquery** → Nested query inside another query. Less reusable.

---

### **10. Stored Procedures: Pros & Cons**

**Advantages**:

* Performance (precompiled).
* Security (parameterized).
* Reusability & abstraction.

**Disadvantages**:

* Harder to version control.
* Tightly coupled to DB engine.

---

### **11. Detect & Prevent SQL Injection**

* Use **parameterized queries** (`SqlCommand.Parameters`).
* Use **ORMs** (EF Core).
* Apply **least privilege** principle.
* Input validation & escaping.

---

### **12. EXISTS vs IN**

* **EXISTS** → Checks if subquery returns rows. Stops at first match. Faster for large data.
* **IN** → Compares a value against a list of values. Loads all values first.

---

### **13. Indexing & Identifying Slow Queries**

* **Indexing** speeds lookups by creating sorted structures.
* Detect slow queries with:

  * **Execution plans**.
  * **Query performance tools** (SQL Profiler, `pg_stat_activity`, `EXPLAIN`).
  * Monitoring CPU/IO waits.

---

### **14. EXPLAIN / QUERY PLAN**

* Shows how the database **executes a query**.
* Displays whether indexes, scans, or joins are used.
* Helps optimize queries by spotting **full table scans**.

---

### **15. Aggregate Functions, GROUP BY & HAVING**

* **Aggregate functions**: `COUNT`, `SUM`, `AVG`, `MIN`, `MAX`.
* **GROUP BY** → Groups rows to apply aggregates.
* **HAVING** → Filters groups (like WHERE but for aggregates).

---

### **16. Composite Key**

* A key made of **multiple columns**.
* Used when a single column cannot uniquely identify a row.
* Example: `(OrderId, ProductId)` in an OrderDetails table.

---

### **17. Materialized View vs Regular View**

* **View** → Virtual table, query executed every time.
* **Materialized View** → Stores the result set physically, can be refreshed. Faster reads.

---

### **18. Handling NULL values**

* Use **IS NULL / IS NOT NULL**.
* Use **COALESCE()** or **ISNULL()** to replace NULLs.
* In constraints: `NOT NULL` prevents them.

---

### **19. Scalar vs Table-Valued Functions**

* **Scalar Function** → Returns a single value. Example: `GetAge(birthdate)`.
* **Table-Valued Function (TVF)** → Returns a result set (table). Useful for inline queries.

---

### **20. Schema Design for Multi-Tenant Applications**

Options:

* **Shared Schema, TenantId column** → All tenants in same tables (cheap, simple).
* **Separate Schema per tenant** → Isolates data, more secure.
* **Separate Database per tenant** → Highest isolation, but harder to manage at scale.

Choice depends on **scale, cost, and isolation requirements**.

---

✅ Do you want me to convert all **.NET + SQL interview Q\&A we’ve done so far** into a **single Markdown “Interview Playbook”** (questions, short answers, examples) so you have a ready reference before interviews?

What is the .NET framework?
The .NET Framework is a multi-platform software framework developed by Microsoft. .NET developers may handle the performance, testing, security and scalability of web and mobile applications. Programmers can use the .NET Framework to develop user and business software. They can also coordinate in teams to build programs more effectively. .NET professionals may have the following responsibilities: 
Collaborating with a team to develop web and mobile applications
Translating app storyboards into functional applications
Integrating data storage solutions
Guaranteeing peak performance, quality and responsiveness of applications
Identifying bugs and other issues within applications, and develop solutions to address such problems
Maintaining code quality over time
Designing and developing clean and efficient code
Related: 8 .NET Certifications for Your Software Development Career
7 .NET interview questions and answers
Here are seven common dot net interview questions that may test your knowledge of the framework and example answers that can help you prepare your interview responses: 
1. What's the .NET Framework?
Interviewers may start the interview with this question to test your basic understanding of the framework and its uses. You can show the interviewer your ability to use the .NET Framework effectively by defining it and listing its key features. You may also mention when you can use it to show your practical knowledge of the system. 
Example: ".NET is a Microsoft framework that helps developers work with different coding languages. You can describe it as a virtual machine that assists with the compilation, conversion and execution of code within a development framework. Using .NET, developers can create form-based and web applications and services."
Related: How To Write a .NET Developer Resume: Steps, Tips and Example
2. What languages does the .NET Framework support?
The interviewer may ask this question to test your experience programming in .NET. Different organizations may require you to learn to program in multiple supported languages. You can respond by explaining the languages the framework supports and giving your experience programming with those languages. 
Example: "The .NET Framework supports multiple programming languages. These languages include both Microsoft and non-Microsoft languages. The most common languages include VB.NET, Cobol, Perl, C#, C++ and F#. I have experience writing code in C#. It has provided me with a foundation for learning other programming tools. I've also created applications in F# and Cobol."
Related: 8 .NET Certifications for Your Software Development Career 
3. What are the essential aspects of .NET?
.NET is an infrastructure that comprises multiple features like application domain, a standard type system and profiling. The hiring manager may ask to identify your understanding of the significant .NET components. Typically, .NET experts may consider "class library" and "Common Language Runtime." as the most critical components. You can answer by listing the principal features and explaining why you consider them essential. 
Example: "Common Language Runtime (CLR) and Class library are the most important aspects of the .NET Framework. CLR provides building tools and resources that help developers set the foundation for application building. The class library is an engine that supports the running of programs. The library holds essential classes providing common functionality that multiple applications can share."
Related: 38 Common C# Net Interview Questions (With Sample Answers)
4. What's the difference between managed and unmanaged code?
The code a program compiles can have different implications depending on whether it's managed or unmanaged. The type of code you use may limit the features you can create in an application as a programmer. For example, managed code forbids you from accessing the low-level addresses of the operating system. The hiring lead may ask this question to identify your ability to differentiate between the two types of code. You can respond by defining them and explaining their features.
Example: "Managed code runs inside the CLR and needs the .NET Framework to execute. Unmanaged code is independent of the CLR and runs in the operating system. Programmers can create unmanaged code from a language independent of the .NET Framework. This ability can allow managed code to be separate from the execution and compile environment.
You can get more system security from using managed code as it runs in a secure CLR engine. Compilers translate unmanaged code to machine code. Machine code runs directly on the operating system, which means it can do dangerous tasks on the computer, such as leaking the system's memory."
Related: 40 Interview Questions You May Be Asked As a .NET Developer
5. In basic terms, explain how to execute managed code.
Executing code is essential knowledge to a developer, but running managed code is specific to the .NET Framework. A question asking you to explain a process in "simple terms" may test your knowledge of the process and ability to communicate clearly. It may mean the position requires you to be very technical and a clear communicator who can explain your work to a nontechnical audience. Your answer can explain how to execute code inside the framework's common language runtime environment. You can also provide your experience implementing managed code. 
Example: "You can start by writing code to build the program. Coding creates the managed code. A compatible compiler can allow you to compile the code by converting the managed code into an intermediate language. The Common Language Runtime targets the intermediate language within .NET Framework and converts it to native code executable within the framework. In my previous role, my task involved speeding up application delivery times. Using .NET and this process for executing managed code, I reduced delivery timelines by 5% overall." 
Related: 8 .NET Certifications for Your Software Development Career
6. Describe the garbage collection process.
Garbage collection is a process of the .NET Framework that performs memory usage optimization. This optimization can allow for greater effectiveness of the platform by cleaning unnecessary data in memory. The interviewer may ask this question to test your ability to perform memory management tasks in the .NET platform. You can respond by describing how .NET performs garbage collection and why it's necessary. 
Example: "The .NET Framework uses the garbage collector to release unused code lying in the memory. The garbage collector releases codes for the three generations divided within the memory–Generation 0, 1 and 2. Since the code objects in Generation 0 are generally short-lived, the garbage collector frequently releases the code objects while releasing objects in Generations 1 and 2 less often.
In the first phase of garbage collection, the collector identifies a list of live objects. It updates the references for the entities it plans to compact. In phase three, the collector reclaims the spaces taken up by the dead code objects. The system then transports the remaining code to an older segment." 
Related: 10 Skills Needed for .NET Developers (Plus Tips)
7. What's role-based security in .NET?
Programmers can create roles in business applications to impose permission restrictions. For example, a student may miss the ability to alter exam records. The hiring manager may ask to analyze your experience in using role-based authentication in .NET programs. You can respond by defining roles in computer security and how you can implement them in .NET.
Example: "Developers use roles in a system to restrict access depending on a user's role in the system. .NET supports role-based authorization by providing information about the current user to the running thread. The operating system can identify the user from their Windows or custom company accounts. The system authorizes the user based on their account identity or the membership groups the account belongs. For example, if a user is in the "admins" group, they can have the administrator-level privilege."
Related: Writing Your ASP.NET Resume
10 additional .NET interview questions
.NET interview questions may focus on analyzing your understanding of the essential features of the tool or your ability to use .NET to solve problems. Other questions you may encounter in a .NET interview include:
What's the difference between "Server.Transfer" and "Response.Redirect"?
What's passport authentication?
What's CAS?
What's the difference between function and stored procedure?
What are the different assemblies?
What are the elements of an assembly?
What are the two types of cookies in ASP.NET?
What's the order of events in a page life-cycle?
What's a delegate in .NET?
What are the types of Common Type System (CTS)?
Related: Essential .NET Interview Questions With Answers
.NET developer skills
Being a .NET developer can combine creative problem-solving skills with technical coding ability. As a programmer, you may create applications that improve companies and serve clients' needs. Some skills you may require for a .NET role include:
Proficiency in VB.NET, C# languages or both
Knowledge of particular .NET Framework versions
Familiarity with Mono
Collaborative skills
Ability to write reusable libraries
Understanding of object-oriented programming
Familiarity with a range of design and architectural patterns
Familiarity with Microsoft SQL
Knowledge of concurrency patterns
Ability to write clean and maintainable code
Knowledge of the strengths and limitations of Common Language Runtime
Familiarity with Windows Presentation Framework
Knowledge of popular web application frameworks
Knowledge of the fundamental design principles required to develop a scalable application
Experience with building database schemas


General .NET Interview Questions
1. What are the main principles of OOP (Object-Oriented Programming)?
Encapsulation involves bundling data (properties) and methods into a single unit called a class. Encapsulation helps hide the internal implementation details of an object and provides a well-defined interface for interacting with the object.

Abstraction focuses on the essential features of an object, hiding the unnecessary details. It allows you to create abstract classes and interfaces that define a contract without specifying the implementation details.

Inheritance allows a derived class to inherit properties and methods from a base class. It promotes code reuse and helps create hierarchical relationships between classes.

Polymorphism enables objects of different classes to be treated as objects of a common superclass. It allows you to write more generic and flexible code that can work with objects of different types.

2. What are inheritance, encapsulation, abstraction, and polymorphism? Provide examples (preferably from your own experience). From which class are all classes in .NET implicitly inherited? Is multiple inheritance allowed in C#?
Inheritance is the ability of a derived class to inherit properties and methods from a base class. Encapsulation is the idea of bundling data and methods into a single unit (class) and hiding the internal implementation details.

Abstraction focuses on the essential features of an object, hiding the non-essential details. Polymorphism allows objects of different classes to be treated as objects of a common superclass.

In .NET, all classes implicitly inherit from the Object class, which is the base class for all .NET classes. Multiple inheritance is not allowed in C# but can be achieved through interfaces.

3. What is recursion?
Recursion is a programming technique where a function calls itself to solve a problem. It involves breaking down a problem into smaller, similar subproblems until a base case is reached. Recursive functions are often used to solve problems that can be defined in terms of smaller instances of the same problem, such as traversing tree-like data structures, calculating factorials, or generating Fibonacci sequences.

4. What is a lambda expression?
A lambda expression is an anonymous function that can be used as a method argument or to initialize a variable. This function concisely represents a method, allowing you to write more readable and expressive code. Lambda expressions are commonly used in LINQ queries and various event handlers.

5. What is parallel programming (multithreading), and its purpose? Which classes are used?
Parallel programming, or multithreading, is the ability of a system to support multiple threads of execution simultaneously. It improves performance by utilizing multiple processors or cores, allowing the application to perform multiple tasks concurrently. In .NET, classes like Task, Thread, and the Task Parallel Library (TPL) are commonly used for parallel programming.

6. What is JSON?
JSON (JavaScript Object Notation) is a text-based data interchange format that machines can parse and generate easily. JSON is often used as an alternative to XML to transmit data between a server and web application.

7. What is your understanding of REST?
REST (Representational State Transfer) is an architectural style for building web services that use HTTP methods (GET, POST, PUT, DELETE) to perform CRUD (Create, Read, Update, Delete) operations on resources. REST APIs offer a structured way to access and manage web services. Clients can interact with these services using standard rules and protocols.

8. Explain the SPA (Single Page Application) concept.
Single Page Applications (SPAs) concept is a web application model that initially loads a single HTML page. As users interact with the app, content updates dynamically without reloading the entire page.

9. Which GoF (Gang of Four) design patterns have you used?
Some commonly used GoF (Gang of Four) design patterns include:

Singleton ensures a class has only one instance and provides a global point of access to it.
Factory defines an interface for creating objects but lets subclasses decide which class to instantiate.
Adapter converts the interface of a class into another interface the client expects.
Observer defines a one-to-many dependency between objects. So that when one object changes state, all its dependents are notified and updated automatically.
Strategy defines a family of algorithms, encapsulates each one, and makes them interchangeable.
10. What is the difference between the GET and POST HTTP methods?
GET requests retrieve data from the server, and the requested data is included in the URL.
POST requests send data to the server, and the data is included in the request body.

11. What problem does Docker solve? What are its pros and cons?
Docker solves the “works on my machine” problem by packaging an application with its dependencies into a standardized unit called a container. This container ensures that the application will run consistently across different environments. Some of the key benefits of Docker include:

Consistent Environment: Docker containers provide a consistent, isolated runtime environment, ensuring the application behaves the same way across different systems.
Faster Deployment: Docker's containerization and image-based deployment model make it easier and faster to deploy applications.
Better Resource Utilization: Docker's efficient use of system resources, such as CPU and memory, can lead to better utilization of the underlying infrastructure.
The main downsides of Docker include increased complexity, potential security concerns, and the risk of vendor lock-in.

12. What is the fundamental difference between unit tests and integration tests?
The fundamental difference between unit tests and integration tests is the scope and focus of the tests:

Unit tests focus on testing individual system components in isolation, verifying that each unit works as expected. They target the smallest testable parts of an application, such as individual methods or classes, and aim to ensure the correctness of the implementation.

Integration tests verify that different components of a system work together correctly. They test the interactions between multiple units or modules, ensuring the overall system functions as expected. Integration tests are typically performed after unit tests. They help identify issues that may arise from integrating different application parts.

The main difference is that unit tests target individual code units, while integration tests focus on the interactions and data flow between those units. Unit tests are typically easier to write, maintain, and run, while integration tests provide a more comprehensive understanding of the system’s behavior.

 

Exception Handling
13. What is an Exception?
An Exception is an event that occurs during the execution of a program that disrupts the normal flow of the program’s instructions. Exceptions handle unexpected situations in a program, such as division by zero or invalid user input.

14. What are the purposes of try, catch, and finally blocks? In what case can the finally block not be executed?
The try block encloses code that might throw an exception.

The catch block handles the exception and provides appropriate error-handling logic.

The final block executes code that should run regardless of whether an exception is thrown or not.

The finally block might not execute if the process is terminated, such as when Environment.FailFast() is called, or the process is abruptly shut down.

15. What is a call stack? What are the key keywords you know?
The call stack is a stack data structure that stores information about the active subroutines of a computer program. It keeps track of the functions or methods that have been called and the order in which they were called. Key keywords related to the call stack include try, catch, throw, and finally.

 

.NET Framework Interview Questions
16. What is ASP.NET?
ASP.NET is a web application framework developed by Microsoft for building dynamic websites, web applications, and web services. It provides a programming model and a set of tools and libraries for developing web applications using .NET.

17. What types of Action filters exist?
The main types of Action filters in ASP.NET MVC are:

Authorization Filters: These are used to control access to actions based on authorization rules.

Action Filters: Used to perform pre-processing or post-processing logic for actions.

Result Filters: Used to modify the result of an action.

Exception Filters: Used to handle exceptions that occur during the execution of an action.

18. What is a Web Service?
A Web Service is a software system designed to support interoperable machine-to-machine interaction over a network. Standard protocols like SOAP, REST are typically used.

19. What is CLR (Common Language Runtime)?
CLR (Common Language Runtime) is the execution engine of the .NET Framework. CLR provides a runtime environment for executing .NET applications, handling memory management, code execution, and other low-level details.

20. What is Garbage Collector at a basic level?
Garbage Collector is a mechanism in .NET that automatically reclaims memory occupied by objects no longer used by the application. This mechanism scans the memory (managed heap) to find unused objects and reclaim their space for future use.

21. What is a delegate?
A delegate is a type that represents a method with a particular signature. Delegates are used to pass methods as arguments to other methods or store methods in variables, enabling function pointers in C#.

22. Is there a difference between Delegate and Action?
Delegate is a general-purpose type representing any method with a matching signature.

Action is a specific type of delegate that represents a method with a void return type and no parameters.

23. What is LINQ, and what is it used for? Provide a few examples of LINQ usage.
LINQ (Language Integrated Query) is a set of extensions to the .NET Framework that provide a generic way to query and transform data from various data sources. Examples of LINQ usage include querying collections, accessing databases using LINQ to Entities, and transforming XML data.

24. What is a namespace, and why is it needed?
A namespace is a way to organize and scope classes, interfaces, and other types in .NET. Namespaces help prevent naming collisions and make the code more maintainable by grouping related types together.

 

Data Types, Collections, and Data Structures
25. What data types do you know?
The main data types in C# can be divided into value and reference types.

Value types: Include the primitive data types (e.g., int, float, bool, char, byte) and user-defined structs. Store their data directly in memory.
Reference types: Include classes, interfaces, delegates, and arrays. Store a reference (pointer) to the actual data, which is stored on the managed heap.
26. What primitive types do you know?
The primitive data types in C# include:

Signed integer types: sbyte, short, int, long
Unsigned integer types: byte, ushort, uint, ulong
Floating-point types: float, double
Decimal type: decimal
Boolean type: bool
Character type: char

27. What is a Nullable type?
A Nullable type is a value type that can also have a null value. It’s denoted with the ? suffix, e.g., int?. Nullable types are useful when you need to represent the absence of a value. Such as when working with databases where a column may have a null value.

28. What is a value type, and what is a reference type? What of these is a class, and what is a struct? In which area of memory are they stored?
Value types store their data directly in memory, while reference types store a reference (pointer) to the data. Classes are reference types, while structs are value types.
Value types are stored on the stack, while reference types are stored on the managed heap.

29. How do value and reference types differ? Is String a reference or a value type?
Value types are copied by value, creating a copy of the actual data.
Reference types are copied by reference, creating a copy of the reference (pointer).
String is a reference type in C#, not a value type.

30. What is the difference between StringBuilder and String?
StringBuilder is a mutable string type, meaning its contents can be modified after creation.
String is an immutable type, meaning its contents cannot be changed once created. StringBuilder is more efficient for concatenating strings, as it avoids the overhead of creating new string objects.

31. What are generics? What problems do they solve?
Generics allow you to write code that works with different data types without knowing the specific type at compile-time. They help with type safety, code reuse, and remove the need for explicit casting.

32. What is boxing/unboxing?
Boxing is the process of converting a value type to a reference type instance.
Unboxing is the opposite, converting a reference type back to a value type.
Boxing and unboxing can incur a performance penalty as they involve additional memory allocations and type conversions.

33. What are Array, List, HashSet, Dictionary? Provide examples of using these data structures. What is the time complexity of operations with them (search, insertion, deletion)?
Array: A fixed-size collection of elements of the same type. Time complexity: Access O(1), Insertion/Deletion O(n).
Example: int[] numbers = { 1, 2, 3, 4, 5 };

List<T>: A dynamic array that can grow and shrink in size. Time complexity: Access O(1), Insertion/Deletion at the end O(1), Insertion/Deletion in the middle O(n).
Example: List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };

HashSet<T>: An unordered collection of unique elements. Time complexity: Add/Remove/Contains O(1) on average.Example: HashSet<string> names = new HashSet<string> { “Alice”, “Bob”, “Charlie” };

Dictionary<TKey, TValue>: A collection of key-value pairs. Time complexity: Add/Remove/Get O(1) on average. Example: Dictionary<int, string> idToName = new Dictionary<int, string> { { 1, “Alice” }, { 2, “Bob” }, { 3, “Charlie” } };

34. What clections do you know?
Queue<T> and Stack<T>: First-in-first-out (FIFO) and last-in-first-out (LIFO) collections, respectively.
SortedSet<T> and SortedDictionary<TKey, TValue>: Sorted versions of HashSet and Dictionary.
ObservableCollection<T>: A collection that provides notification when items are added, removed or the whole collection is refreshed.

35. What does the yield operator do?
The yield keyword returns an enumerable sequence of values from a method or iterator block, one at a time, instead of constructing the entire array or collection in memory. It allows you to work with data sequences too large to fit in memory all at once. When you iterate over a method that uses yield, the method generates the values on-the-fly, rather than creating a complete collection upfront.

 

Classes, Structures, and Interfaces
36. What is a class?
A class is a blueprint or template for creating objects. It encapsulates data (fields) and functionality (methods) into a single unit, providing a way to model real-world entities or concepts in software.

37. How does a class differ from an abstract class?
The key differences between a class and an abstract class are:

An abstract class cannot be instantiated directly, while a regular class can. It can have both abstract and non-abstract (implemented) methods, while a regular class can only have non-abstract methods.
A class can inherit from only one abstract class but implement multiple interfaces.

38. How does an abstract class differ from an interface? What are interfaces for, and what tasks do they perform?
The main differences between an abstract class and an interface are:

Abstract classes can have both abstract and non-abstract members.
Interfaces can only have abstract members (except for static and extension methods in C# 8.0 and later).
Abstract classes can have access modifiers and can provide method implementations.
Interfaces can only have public abstract members.
A class can inherit from only one abstract class but implement multiple interfaces.
Interfaces are used to achieve abstraction and define a contract.

39. What access modifiers do you know?
The access modifiers in C# are:

public: The type or member is accessible from anywhere.
private: The type or member is accessible only within the containing class.
protected: The type or member is accessible within the containing class or any derived classes.
internal: The type or member is accessible within the same assembly.
protected internal: The type or member is accessible within the same assembly or any derived classes.

40. What is the difference between regular and static classes?
A regular class can be instantiated and has both static and instance members. A static class cannot be instantiated and contains only static members. Static classes are useful for providing utility methods or constants that don’t require any instance state.

41. What is the difference in method overriding between the keywords new and override?
When overriding a method, the new keyword hides the base class implementation. In contrast, override replaces the base class implementation with the derived class implementation.

42. What is the difference between const and readonly?
const is a compile-time constant.
readonly can be set at runtime but cannot be changed after initialization.
const values are inlined by the compiler.
readonly fields are stored as instance fields.

43. The difference between a structure and a class. Provide examples of structures.
Structs are value types, while classes are reference types. Structs are lightweight, suitable for small, simple data structures, and are stored on the stack. Examples of structs include Point, Rectangle, and DateTime.

44. Can an instance of a structure be stored in the heap? How can you do this?
Structs are value types and cannot be directly stored in the heap. To store a struct in the heap, you would need to wrap it in a class or use boxing.

 

Asynchronicity
45. What is asynchronicity, and how does it differ from multithreading?
Asynchronicity allows a program to perform other tasks while waiting for a long-running operation to complete without blocking the main thread. It is different from multithreading, which involves running multiple threads concurrently. With asynchronicity, the application can continue executing other code while the asynchronous operation is in progress, improving overall responsiveness and efficiency. On the other hand, multithreading involves parallel execution of multiple threads, which can be useful for CPU-bound tasks but requires more complex synchronization and resource management.

46. What keywords are used to work with asynchronicity in code?
The keywords used for asynchronicity in C# are async and await.

47. What do the keywords async/await mean?
The async keyword marks a method as asynchronous, allowing it to use the await keyword to pause the execution of the method until the awaited asynchronous operation completes. It enables the method to return control to the caller while the asynchronous operation is in progress, improving the application’s overall responsiveness.

 

Databases
48. The difference between relational and non-relational databases, the pros and cons of using both options.
Relational databases (SQL) store data in tables with defined schemas, using a structured query language (SQL) for data manipulation and retrieval. They excel at handling structured data and complex queries. Relational databases are generally stronger regarding data integrity, consistency, and complex querying.

Non-relational (NoSQL) databases use flexible, schema-less data models, such as key-value, document-oriented, or graph-based. They are better suited for handling unstructured data and high scalability requirements. Non-relational databases offer higher availability, partition tolerance, and scalability.

49. What are indexes in RDBMS?
Indexes in RDBMS are additional data structures that improve the speed of data retrieval operations, such as SELECT queries. Indexes create a sorted list of values from a table column and pointers to the corresponding rows.

50. What types of JOINs exist in SQL?
The main types of SQL JOINs are:

INNER JOIN: Returns rows that have matching values in both tables.
LEFT JOIN (LEFT OUTER JOIN): Returns all rows from the left table and the matching rows from the right table.
RIGHT JOIN (RIGHT OUTER JOIN): Returns all rows from the right table and the matching rows from the left table.
FULL JOIN (FULL OUTER JOIN): Returns all rows from both tables, whether or not there is a match.

 

Testing
51. What is the fundamental difference between unit tests and integration tests?
The fundamental difference between unit tests and integration tests is the scope and focus of the tests:

Unit tests focus on testing individual units or components of a system in isolation, verifying that each unit works as expected. They target the smallest testable parts of an application, such as individual methods or classes, and aim to ensure the correctness of the implementation.

Integration tests, on the other hand, verify that different components of a system work together correctly. They test the interactions between multiple units or modules, ensuring the overall system functions as expected. Integration tests are typically performed after unit tests, and they help identify issues that may arise from integrating different parts of the application.

The main difference is that unit tests target individual units of code, while integration tests focus on the interactions and data flow between those units. Unit tests are typically easier to write, maintain, and run, while integration tests provide a more comprehensive understanding of the system’s behavior.

52. What are unit tests used for?
Unit tests are used to verify the correctness of individual units of code (methods, classes, or components) in isolation. By testing units in isolation, you ensure each building block functions correctly, leading to a reliable application.

53. What are the advantages and disadvantages of using unit tests?
Advantages of unit tests include catching bugs early, improving code quality, and providing a safety net for future changes. Disadvantages include additional development effort and the potential for tests to become outdated over time.

54. From what three logical blocks is a unit test composed?
A unit test consists of three logical blocks:
Arrange: Set up the necessary test data and preconditions.
Act: Execute the code being tested.
Assert: Verify that the observed outcome matches the expected outcome.

.NET Interview Questions for Middle Developers
Mid-level .NET interviews gauge candidates’ deeper technical proficiency. Initial rounds screen intermediate .NET concepts and design patterns. Technical stages involve complex coding and architecture discussions. Candidates may also face system design and database modeling questions.

Mid-level .NET developer

General .NET Interview Questions
55. Describe in as much detail as possible what happens at the HTTP level when you type google.com in a browser.
When you type “google.com” in a browser, the following happens at the HTTP level:

The browser first resolves the domain name “google.com” to an IP address using the Domain Name System (DNS). The browser sends a DNS query to a DNS server, which looks up the IP address associated with the domain.

Once the IP address is obtained, the browser initiates a TCP connection with the web server at that IP address, using the HTTP protocol on port 80 (the default HTTP port).

The browser then sends an HTTP GET request to the web server, requesting the root resource (usually the home page). The request includes headers with information about the client, such as the browser type, accepted file types, and other metadata.

The web server receives the request, processes it, and generates a response. The response includes an HTTP status code (e.g., 200 for successful, 404 for not found), response headers with metadata about the response, and the web page’s actual content (usually in HTML format).

The browser receives the response, parses the HTML, and renders the web page. As the page loads, the browser may send additional requests for resources referenced in the HTML, such as images, stylesheets, and JavaScript files.

The browser continues to fetch all the necessary resources and assembles the complete web page, displaying it to the user.

HTTPS (Hypertext Transfer Protocol Secure) is a secure version of the HTTP protocol that adds encryption to the communication between the client (browser) and the web server.

56. How does HTTPS work?
HTTPS works as follows:

01
The client (browser) initiates a connection to the web server using the HTTPS protocol, typically on port 443.
02
The web server presents its SSL/TLS certificate, which contains its public key and other information about the server's identity.
03
The client verifies the server's certificate, checking that it was issued by a trusted Certificate Authority (CA) and that the domain name matches the expected website.
04
The client and server establish a secure, encrypted connection if the certificate is valid.
05
All subsequent communication between the client and server is encrypted.
HTTPS helps protect against man-in-the-middle attacks, eavesdropping, and other security threats.

57. What is your understanding of SOLID principles?
The SOLID principles are a set of guidelines for writing clean, maintainable, and extensible object-oriented code:

Single Responsibility Principle (SRP): A class should have only one reason to change.
Open/Closed Principle (OCP): Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.
Liskov Substitution Principle (LSP): Subtypes must be substitutable for their base types.
Clients should not be forced to depend on interfaces they do not use.
Dependency Inversion Principle (DIP): High-level modules should not depend on low-level modules. Both should depend on abstractions.
Adhering to the SOLID principles helps create modular, flexible, and maintainable code that is easier to understand, test, and extend over time.

58. What serialization protocols do you know, and where are they used?
Some common serialization protocols used in .NET include:

JSON (JavaScript Object Notation):A lightweight, text-based format used for data exchange. Commonly used for web services and APIs.
XML (Extensible Markup Language): A more verbose, structured format widely used for data exchange and configuration files.
Binary serialization: A compact, binary format for serializing .NET objects. Useful for transmitting data over the network or persisting objects to storage.
Protocol Buffers (protobuf): A binary serialization format developed by Google, optimized for performance and size.
The choice of serialization protocol depends on factors such as the data’s size and complexity and the system’s compatibility needs.

59. What is a pure function, and what are its advantages?
A pure function is a function that:

Always returns the same output for a given input (no side effects).
Does not modify any state outside of its local scope.
The advantages of using pure functions include:

Predictability: Pure functions always produce the same output for the same input, making the code more predictable and easier to reason about.
Testability: Pure functions can be easily tested in isolation, as they don't depend on external state.
Parallelism: Pure functions can be safely executed in parallel, as they don't interfere with each other.
Referential transparency: Expressions using pure functions can be replaced by their result without affecting the program's behavior.
Pure functions promote modularity, testability, and functional programming principles, leading to more maintainable and robust code.

60. What is dependency injection, and why is it useful?

Dependency Injection (DI) is a design pattern that allows you to decouple the creation and management of object dependencies from the objects that depend on them. Instead of directly creating dependencies, objects receive their dependencies from an external source. For example, through the constructor, method parameters, or properties.

DI is useful because it:

Promotes loose coupling between components, making the code more modular and testable.
Allows for easy substitution of implementations, enabling flexibility and adaptability.
Facilitates the use of abstractions, which can improve the system's overall design.
Simplifies the management of object lifetime and resource allocation.
By using DI, you can create more maintainable, extensible, and testable applications, as the dependencies are managed externally.

61. What are cohesion and coupling, and what do they mean?
Cohesion and coupling are two fundamental software design principles:

Cohesion refers to the degree to which the elements inside a module (e.g., a class or a function) belong together. High cohesion means that the elements within a module are strongly related and work together to achieve a specific purpose. Low cohesion indicates that the elements within a module are loosely related or unrelated, making the module harder to understand and maintain.

Coupling refers to the degree of interdependence between modules. Low coupling means that modules have minimal dependencies on each other, making the system more flexible and easier to modify. High coupling indicates that modules have strong dependencies, which can make the system more rigid and harder to change.

62. What are IaaS, PaaS, and SaaS, and what are the differences between them?
IaaS, PaaS, and SaaS are different service models in cloud computing:

IaaS (Infrastructure as a Service): Provides access to virtualized computing resources, such as virtual machines, storage, and networking. The cloud provider manages the underlying infrastructure, while the user controls the operating system, applications, and data.

PaaS (Platform as a Service): Provides a platform for developing, testing, and deploying applications, including the operating system, middleware, and runtime environment. The cloud provider manages the underlying infrastructure and platform while the user focuses on deploying and managing their applications.

SaaS (Software as a Service): Provides access to software applications hosted and managed by the cloud provider. Users access the software through a web browser or API; the cloud provider is responsible for the infrastructure, platform, and application management.

The main differences lie in the level of control and responsibility the user has over the various components of the system. IaaS offers the most control, PaaS offers a balance of control and abstraction, and SaaS offers the least control but the highest level of abstraction.

63. What debugging techniques do you use?
Some common debugging techniques include:

Setting breakpoints in the code to pause execution and inspect variables.
Stepping through the code line by line to understand the flow of execution.
Using the debugger's "Watch" and "Immediate" windows to evaluate expressions and monitor variable values.
Leveraging logging and tracing to output relevant information during program execution.
Analyzing stack traces to identify the root cause of exceptions or unexpected behavior.
Profiling the application to identify performance bottlenecks and optimize the code.
Leveraging debugging tools, such as PerfView, dotTrace, or Visual Studio's built-in profiler to gain deeper insights into the application's runtime behavior.
The choice of debugging technique depends on the nature of the problem, the complexity of the application, and the available tooling.

64. What design patterns do you know? Explain the essence of the ones you mentioned.
Some design patterns include:

Singleton ensures a class has only one instance and provides a global point of access to it. Useful for managing global state or resources.
Factory defines an interface for creating objects but lets subclasses decide which class to instantiate. Helpful for creating objects without exposing the creation logic.
Adapter converts the interface of a class into another interface the client expects. Allows classes with incompatible interfaces to work together.
Observer defines a one-to-many dependency between objects. So that when one object changes state, all its dependents are notified and updated automatically. Useful for implementing event-driven architectures.
Strategy defines a family of algorithms, encapsulates each one, and makes them interchangeable. Allows the algorithm used by a class to be selected at runtime.
These patterns help promote modularity, flexibility, and reusability in software design, making the code more maintainable over time.

65. What is the essence of the Singleton pattern? Why is it also called an anti-pattern?
The Singleton pattern ensures that a class has only one instance and provides a global point of access to it. The essence of the Singleton pattern is to have a private constructor and a static method that returns the single instance of the class.

The Singleton pattern is sometimes considered an anti-pattern because it can introduce a global state, making the code harder to test.

Alternatives to the Singleton pattern include using Dependency Injection to manage the lifetime of objects or using static classes (in C#) to provide global access to functionality without needing a Singleton instance.

66. What is the purpose of the Strategy pattern?
The purpose of the Strategy pattern is to define a family of algorithms, encapsulate each one, and make them interchangeable. This way, the algorithm can be used by a class to be selected at runtime rather than being hard-coded.

The key benefits of the Strategy pattern are:

Flexibility: By encapsulating different algorithms in separate classes, the Strategy pattern makes it easy to add new algorithms or modify existing ones without changing the context in which they are used.
Reduced conditional logic: Instead of using conditional statements to determine which algorithm to use, the Strategy pattern delegates the choice of algorithm to the client, making the code more readable and maintainable.
Testability: The algorithms can be tested in isolation, as they are decoupled from the context in which they are used.
The Strategy pattern is useful in scenarios where you need to support multiple algorithms or behaviors.

67. What are the key differences between distributed systems and monolithic ones?
The key differences between distributed systems and monolithic ones are:

Architecture: Distributed systems are composed of multiple, independently deployable components that communicate with each other. Monolithic systems are a single, tightly coupled application.
Scalability:Distributed systems can scale individual components horizontally, adding more instances as needed. Monolithic systems can be more challenging to scale, as the entire application needs to be scaled.
Complexity: Distributed systems are generally more complex. They need to handle issues like network failures, eventual consistency, and coordinating the interactions between components.
Development and Deployment: Distributed systems allow for independent development and deployment of components. Monolithic systems require the entire application to be deployed together.
Reliability: Distributed systems can be more resilient, as the failure of one component does not necessarily bring down the entire system. Monolithic systems have a single point of failure.
68. What design patterns for distributed systems do you know?
Some design patterns used in distributed systems include:

Microservices: Organizes an application as a collection of loosely coupled, independently deployable services.
API Gateway: Serves as a single entry point for clients to access the underlying microservices.
Circuit Breaker: Prevents cascading failures in distributed systems by stopping calls to a failing service.
Event-Driven Architecture: Uses an event bus or message broker to decouple the components of a distributed system.
CQRS (Command Query Responsibility Segregation): Separates the read and write operations responsibilities, often used in event-driven architectures.
69. What are the principles of a Message Bus? Why can duplicates occur in queues?
The principles of a Message Bus are:

Loose Coupling: The components of the system are decoupled, communicating asynchronously through the message bus.
Scalability: The message bus can handle increasing message loads by adding more message brokers or consumers.
Reliability: To ensure reliable delivery, the message bus provides features like message persistence, retries, and dead-letter queues.
Duplicates can occur in queues for various reasons, such as network failures, process restarts, or message redelivery. To handle this, consumers should be designed to be idempotent, meaning they can safely process the same message multiple times.

70. What principles of building idempotent services do you know?
Asynchronous methods in .NET allow a calling thread to initiate an operation and continue executing other tasks without waiting for the operation to complete. This is achieved through the use of the async and await keywords.

When an async method is called, it returns a Task or Task<T> object, representing the pending operation. The calling thread can then await the completion of the task, at which point the method will resume execution with the result of the asynchronous operation.

71. Explain how asynchronous methods work. How does asynchronicity differ from parallelism?
The key difference between asynchronicity and parallelism is:

Asynchronicity allows a single thread to perform other work while waiting for a long-running operation to complete without blocking the main thread.

Parallelism involves concurrently executing multiple threads, each working on a different task. Parallelism is useful for CPU-bound tasks that can be divided into smaller, independent subtasks. However, it requires more complex synchronization and resource management compared to asynchronicity.

In summary, asynchronicity enables a single thread to be more productive by allowing it to switch between multiple tasks. In contrast, parallelism utilizes multiple threads to work on tasks concurrently. Both approaches can be used to improve the performance and scalability of applications, but they address different types of problems.

 

.NET Framework Interview Questions
72. What exceptions can’t be caught in a catch block?
In C#, certain exceptions cannot be caught in a catch block. These exceptions are known as unhandled exceptions, and they typically occur due to critical errors or resource constraints. Some examples of exceptions that cannot be caught include:

StackOverflowException: This exception occurs when the program runs out of available memory on the stack.
OutOfMemoryException: This exception occurs when the program runs out of available memory on the managed heap.
ThreadAbortException: This exception occurs when a thread is aborted due to a call to the Thread.Abort method.
ExecutionEngineException: This exception occurs when there is an internal error in the common language runtime (CLR).
These exceptions are considered as unhandled exceptions, and they usually result in the termination of the application or the AppDomain.

73. What is the difference between a .NET Standard Class Library and a .NET Core Class Library?
The main difference between a .NET Standard Class Library and a .NET Core Class Library lies in their target frameworks and compatibility:

.NET Standard Class Library: A .NET Standard Class Library is a project type that targets the .NET Standard, a formal specification of APIs intended to be available on all .NET implementations. The .NET Standard enables code sharing across different .NET platforms, including .NET Core, .NET Framework, Xamarin, and others. However, it doesn’t provide any implementation details or runtime components. Instead, it defines a set of APIs the underlying platform must implement.

.NET Core Class Library: A .NET Core Class Library is a project type specifically targeting the .NET Core runtime. It is designed to run on the .NET Core runtime, a cross-platform implementation of .NET. Unlike the .NET Standard Class Library, a .NET Core Class Library can take advantage of platform-specific features and APIs provided by .NET Core.

In general, if you need to create a library that needs to be shared across multiple .NET platforms (e.g., .NET Framework, .NET Core, Xamarin), you would choose a .NET Standard Class Library. However, if you are building a library that will only be used within a .NET Core application, you might prefer a .NET Core Class Library, as it can take advantage of .NET Core-specific features and optimizations.

74. Explain the difference between deferred and immediate execution in LINQ.
In LINQ (Language Integrated Query), there are two types of execution modes: deferred execution and immediate execution. The difference lies in when the query is actually evaluated and executed.

Deferred Execution:
In deferred execution mode, the LINQ query is not executed until the result is actually enumerated or accessed. The query is constructed and stored as an expression tree, and the actual evaluation is deferred until the last possible moment. Deferred execution is the default behavior for most LINQ queries.

Immediate Execution:
In immediate execution mode, the LINQ query is executed immediately, and the results are stored in a data structure (e.g., a list or array). This mode is typically used when you need to work with the query results multiple times or when you need to perform operations that cannot be expressed as a query expression.

75. What is the purpose of the ConfigureServices method in Startup.cs?
In ASP.NET Core applications, the ConfigureServices method in the Startup class is used to configure and register various services that the application will use. It is part of the application’s startup process and is called by the runtime during the application’s initialization.

The main purpose of the ConfigureServices method is to set up and configure the services that the application will use, such as:

Dependency Injection (DI) Services: This method registers services with the built-in Dependency Injection container. Depending on the desired lifetime and usage patterns, services can be registered as singletons, scoped, or transient instances.
Database Context Initialization: If the application uses a database, the ConfigureServices method is often used to configure and register the database context with the DI container.
Options Configuration: This method can be used to configure and bind application settings or options to specific classes or services.
Authentication and Authorization Services: Services related to authentication and authorization can be configured and registered using the ConfigureServices method.
MVC Services: For ASP.NET Core MVC applications, the ConfigureServices method adds and configures MVC services, such as model binders, view engines, and other MVC-related components.
Third-Party Services: Any third-party libraries or packages that provide services can be configured and registered using the ConfigureServices method.
By registering and configuring services using the ConfigureServices method, the application can take advantage of the built-in Dependency Injection system.

76. What is the difference between services.AddTransient and services.AddScoped in ASP.NET Core?
In ASP.NET Core, services.AddTransient and services.AddScoped are methods used to register services with the built-in Dependency Injection (DI) container. The main difference between them lies in the lifetime and scope of the registered service instances.

services.AddTransient:
When a service is registered as transient using services.AddTransient, a new service instance is created every time it is requested from the DI container. It means that a new instance of that service will be created each time a transient service is injected into another class or component.
Transient services are suitable for stateless services or services that do not maintain any state across multiple requests.

services.AddScoped:
When a service is registered as scoped using services.AddScoped, a single instance of the service is created and shared within the same scope. In ASP.NET Core, the scope is typically tied to the current HTTP request. This means that within the same HTTP request, the same instance of the scoped service will be used for all instances that require that service.However, for a new HTTP request, a new instance of the scoped service will be created and used for that request’s scope.

Scoped services are suitable for services that maintain a state related to the current request or operation, such as services that interact with the HTTP context or databases.

The main difference between transient and scoped services lies in the lifetime and sharing of instances:

Transient: A new instance is created every time the service is requested.
Scoped: A single instance is created and shared within the same scope (e.g., HTTP request).

In general, you should use transient services for stateless services or services that do not maintain any state across multiple requests. Scoped services should be used for services that need to maintain state related to the current request or operation.

77. What is Kestrel?
Kestrel is a cross-platform web server for ASP.NET Core applications. It is an open-source web server that was developed by Microsoft as part of the .NET Core project. Kestrel is designed to be lightweight, high-performance, and cross-platform, making it suitable for various deployment scenarios.

Here are some key features and characteristics of Kestrel:

Cross-Platform: Kestrel is a cross-platform web server that can run on multiple operating systems, including Windows, Linux, and macOS.
Lightweight and High-Performance: Kestrel is designed to be lightweight and highly performant. It uses asynchronous I/O operations and a lean architecture, efficiently handling many concurrent connections. Integration with ASP.NET Core: Kestrel is tightly integrated with ASP.NET Core and is the default web server hosting ASP.NET Core applications.
Modular Design: Kestrel has a modular design, allowing developers to configure and extend its functionality. For example, developers can add support for additional protocols or implement custom middleware components.
Reverse Proxy Support: While Kestrel is a capable web server, exposing it directly to the internet is not recommended. Instead, it is typically used in conjunction with a reverse proxy server. Such as Internet Information Services (IIS), Nginx, or Apache, which handles tasks like SSL termination, load balancing, and static file serving. Containerization and Cloud Deployments: Kestrel's lightweight and cross-platform nature makes it well-suited for containerized deployments and cloud environments.
Kestrel is designed to be a lean and efficient web server for ASP.NET Core applications, providing high performance and cross-platform support. However, it is typically used in conjunction with a reverse proxy server in production environments to ensure secure and scalable deployments.

78. Describe the ASP.NET MVC request pipeline.
The ASP.NET MVC request pipeline is a series of steps that occur when an ASP.NET MVC application processes an incoming HTTP request. The request pipeline is responsible for handling the request, routing it to the appropriate controller and action method, and executing the action method. Here’s a breakdown of the main steps in the ASP.NET MVC request pipeline:

Routing: The first step in the pipeline is to route the incoming request to the appropriate controller and action method based on the URL and routing rules defined in the application.
Model Binding: The model binding process occurs if the action method expects input parameters. During model binding, the framework attempts to map the incoming request data (query string, form data, etc.) to the action method's parameters.
Action Filters: Any action filters configured for the controller or action are executed before executing the action method. Action filters allow developers to add custom logic that runs before or after the action method execution.
Action Method Execution: The appropriate action method on the controller is executed, and any logic within the method is performed.
Action Result Creation: After the action method execution, an action result is created. The action result represents the outcome of the action method and contains the data or instructions for generating the response.
Result Filters: Any result filters configured for the controller or action are executed. Result filters allow developers to modify or add logic to the action result before it is rendered.
View Engine Processing: If the action result is a view result, the view engine processes the corresponding view template and generates the final HTML output.
Response: The final response, which may include the HTML output from the view engine or other data (such as JSON or XML), is sent back to the client.
79. How do you configure caching of HTTP responses in ASP.NET Web API?
In ASP.NET Web API, you can enable caching of HTTP responses by setting the appropriate response headers. The key headers for caching are:

– CacheControl: This header specifies caching policies like public/private caching, max-age (duration for which the response can be cached), and other caching directives.

– Expires: This header specifies the date and time after which the cached response should be considered stale.

Using message handlers, you can set these headers in the controller action methods or globally for all Web API controllers.

The CacheControl header allows you to control if the response can be cached publicly or privately and specify the max-age for caching. The Expires header sets an absolute expiration time for the cached response.

By configuring these headers appropriately, you can leverage client-side and intermediate proxy/gateway caching to improve the performance of your Web API.

 

Memory Management
80. What are the heap and the stack? Differences, principles of operation.
The heap and the stack are two different memory regions in the computer’s memory that are used to store data during the execution of a program.

The Stack

The stack is a memory region used for static memory allocation.
It is organized as a last-in, first-out (LIFO) data structure, where the last item pushed onto the stack is the first one to be popped off.
The stack stores function call information, such as local variables, parameters, and return addresses.
Memory allocation and deallocation on the stack are very fast operations.
The stack size is limited and determined at compile-time or during thread creation.
When a function is called, memory is allocated on the stack for its local variables and parameters.
When the function returns, the allocated memory is automatically deallocated (popped off the stack).
The Heap

The heap is a memory region used for dynamic memory allocation.
It is organized as a free pool of memory blocks that can be allocated and deallocated at runtime.
Memory allocation and deallocation on the heap are relatively slower operations than the stack.
The heap size is not fixed and can grow or shrink as needed during program execution.
Objects and data structures with a longer lifetime or dynamically created during runtime are stored on the heap.
Memory allocation on the heap explicitly uses operators like new in C#. At the same time, deallocation is usually handled automatically by the garbage collector in managed languages like C#.
The stack is used for static memory allocation and automatic memory management. In contrast, the heap is used for dynamic memory allocation and requires manual or automatic memory management (e.g., garbage collection). The stack is faster and has a limited size, while the heap is slower but can grow dynamically.

81. How does the Garbage Collector work?
The Garbage Collector (GC) is a key component of the .NET runtime. GC automatically manages the allocation and deallocation of memory for managed objects on the heap. Garbage Collector works by periodically scanning the managed heap and identifying objects that are no longer reachable, and reclaiming the memory occupied by those objects.

Here’s a general overview of how the Garbage Collector works:

Marking Phase: During this phase, the GC identifies the root objects (objects that are currently in use, such as static objects, objects on the stack, and objects referenced by CPU registers). It then traverses all references from these root objects, marking all reachable objects as "live."
Marking Phase Ending: After marking all live objects, the GC checks for sufficient memory to continue execution. If not, it proceeds to the next phase.
Relocating Phase: In this phase, the GC compacts the heap by moving all live objects to one end of the heap, creating a contiguous block of free memory.
Reclaiming Phase: After compacting the heap, the GC reclaims the memory occupied by unreachable (dead) objects, making it available for future allocations.
The GC employs various techniques and algorithms to optimize its performance. These techniques include generational garbage collection, which divides the heap into generations based on object lifetime, and background garbage collection, which allows the GC to run concurrently with the application’s threads.

82. Why do we need the using keyword in C# if .NET has automatic memory management? How is this related to the Disposable pattern, and why is such a complex pattern needed for managed and unmanaged resources?
The using keyword in C# is needed to ensure proper disposal of unmanaged resources, even with .NET’s automatic memory management for managed resources. It’s related to the IDisposable interface and the Disposable pattern, which provides a way to encapsulate the acquisition and release of unmanaged resources. This complex pattern is necessary because while the .NET Garbage Collector handles managed objects, it doesn’t manage unmanaged resources, which must be explicitly released to prevent leaks.

83. What are the peculiarities of working with the Large Object Heap?
Working with the Large Object Heap (LOH) in .NET has several peculiarities:

Objects larger than a certain size threshold (typically 85KB on 64-bit systems) are allocated on the LOH instead of the regular managed heap.
The LOH is more prone to fragmentation, as large objects are less likely to be collected and compacted regularly.
Objects on the LOH are not divided into generations and are not compacted as aggressively as regular objects.
Collecting and compacting objects on the LOH can be expensive, leading to longer garbage collection pauses.
Large objects on the LOH can consume significant memory, potentially causing memory pressure.
Finalizing large objects on the LOH is more expensive due to their size and the overhead of moving them.
Data Types, Collections, and Data Structures
84. When is a generic class of a specific type generated – at runtime or compile-time?
A generic class of a specific type is generated at compile-time through a process called code generation or specialization. When you use a generic class with a specific type argument, the compiler generates the IL (Intermediate Language) code for that specialized version of the class.

85. What is reflection?
Reflection is a mechanism in .NET that allows code to inspect and interact with itself at runtime. This mechanism provides a way to dynamically discover and manipulate types, fields, methods, properties, and other metadata of loaded assemblies during program execution.

86. Tell me about the `LinkedList<T>` collection. How does it differ from other collections?
The LinkedList<T> is a doubly-linked list collection in .NET. It differs from other collections like List<T> and arrays in that it maintains a logical order of its elements and allows efficient insertion and removal operations at any point in the list. Unlike arrays, LinkedList<T> has no need to shift elements when adding or removing items, making it more efficient for frequent modifications.

87. What is an indexer?
An indexer is a special property in C# that allows instances of a class or struct to be accessed similarly to arrays or collections using an index or a set of indices. Indexers provide a convenient syntax for accessing and manipulating data within an object, making the object behave like a virtual array or dictionary.

88. What is an immutable object? What are the benefits of using immutable objects? Propose a way to implement it in .NET.
An immutable object is an object whose state cannot be modified after creation. Once an immutable object is instantiated, its properties and fields remain constant throughout its lifetime.

Benefits of using immutable objects include:

Thread safety: Immutable objects are inherently thread-safe, as their state cannot be modified concurrently.
Simplicity: Immutable objects are simpler to reason about and debug, as their behavior is predictable and deterministic.
Caching: Immutable objects can be safely cached, as their state never changes.

To implement an immutable object in .NET, you can follow these steps:

Make the class immutable by removing all public setters and making all instance fields read-only or private.
Initialize all instance fields through the constructor or Factory methods.
Avoid exposing public methods that modify the object's state.
Return new instances instead of modifying existing ones when state changes are required.
Consider using read-only collections or immutable collection types for any collections the class exposes.
Following these principles, you can create immutable objects that provide thread safety, simplicity, and caching benefits in your .NET applications.

89. When should you use StringBuilder, and when should you use string? How does StringBuilder work?
You should use StringBuilder when performing multiple string operations, such as concatenations, insertions, or modifications.

string is immutable, meaning that any operation that modifies a string creates a new string object, which can lead to performance issues and increased memory usage.

StringBuilder is a mutable object that provides a more efficient way to build strings dynamically. It works by pre-allocating a buffer in memory and allowing you to modify the contents of that buffer directly without creating new string objects for each operation. This approach is more efficient, especially when dealing with large strings or performing many string operations.

Here’s a simplified overview of how StringBuilder works:

01
StringBuilder allocates an initial buffer in memory to store characters
02
As you append, insert, or modify characters, StringBuilder updates the buffer directly without creating new string objects
03
If the buffer becomes too small to hold the new characters, StringBuilder automatically resizes the buffer to accommodate the additional characters
04
When you need the final string, you can call the ToString() method, which creates a new string instance from the contents of the buffer
In general, you should use StringBuilder when performing multiple string operations, especially in loops or performance-critical code. For simple string operations or when you don’t need to modify the string, it’s fine to use the string type.

90. What is tree balancing?
Tree balancing is a technique used in self-balancing binary search trees (such as AVL trees or Red-Black trees) to ensure that the tree remains balanced and maintains its efficiency for operations like insertion, deletion, and search. A balanced tree is one where the heights of the left and right subtrees of every node differ by at most one.

Tree balancing involves performing rotations (left or right) on nodes in the tree to maintain the balance after insertions or deletions. These rotations help redistribute the nodes in the tree, ensuring that the height of the tree remains logarithmic with respect to the number of nodes, which is crucial for efficient operations.

Balancing a tree helps maintain the time complexity of operations like search, insertion, and deletion at O(log n), where n is the number of nodes in the tree. Without balancing, a binary search tree can degenerate into a linked list in the worst case, leading to linear time complexity for these operations.

91. What are key-value structures?
Key-value structures, also known as associative arrays or dictionaries, are data structures that store and organize data as key-value pairs. Each element is associated with a unique key used to access and retrieve the corresponding value in a key-value structure.

Key-value structures are widely used in various applications, such as caching systems, databases, and data processing pipelines. They provide an efficient way to store and retrieve data based on a key, which can be a primitive type (e.g., integer, string) or a custom object.

Examples of key-value structures in .NET include:

Dictionary<TKey, TValue>: A generic collection that stores key-value pairs, where the keys are unique.
Hashtable: A non-generic collection that stores key-value pairs, similar to Dictionary<TKey, TValue>.
SortedDictionary<TKey, TValue>: A sorted collection that stores key-value pairs in ascending order based on the keys.
SortedList<TKey, TValue>: A sorted collection that stores key-value pairs in a list-like structure.

Key-value structures provide efficient lookup, insertion, and deletion operations, with an average time complexity of O(1) for most operations when implemented correctly (e.g., using hash tables).

92. What is a hash function, and why are hash tables needed?
A hash function is a mathematical function that takes an input (e.g., a string, an object, or data collection) and produces a fixed-size output, typically an integer value, known as a hash code or hash value. Hash functions are designed to distribute their outputs in a uniform and pseudo-random manner across the entire range of possible hash values.

Hash tables are data structures that use hash functions to store and retrieve data efficiently. Hash tables are needed because they provide fast average-case time complexity for common operations like insertion, deletion, and lookup, which are typically O(1) on average.

Hash tables are widely used in various applications, such as caching systems, databases, compilers, and data processing pipelines, due to their efficiency in storing and retrieving data based on keys.

93. What properties should an ideal hash function have?
An ideal hash function should have the following properties:

Determinism: The hash function should always produce the same output for a given input. This property ensures consistency and predictability in the behavior of the hash function.
Uniform distribution: The hash function should distribute its outputs as uniformly as possible across the entire range of possible hash values. This property helps minimize collisions in hash tables and ensures efficient use of storage space.
Avalanche effect: A small change in the input should result in a significant change in the output hash value. This property helps prevent predictable patterns in the hash values and makes it harder to cause collisions intentionally.
Speed: The hash function should be computationally efficient and fast to calculate, as it may be called frequently in performance-critical applications.
Collision resistance: Finding two different inputs that produce the same hash value (collisions) should be computationally infeasible. This property is crucial for applications that rely on the uniqueness of hash values, such as cryptographic hash functions.
Irreversibility: It should be computationally infeasible to reconstruct the original input from the hash value alone. This property is essential for applications that use hash functions for data integrity or security purposes.
94. What are collisions, and how do you deal with them?
Collisions in hash tables occur when different keys are mapped to the same index by the hash function. Common techniques to handle collisions include separate chaining, open addressing, and rehashing.

95. What is the time complexity of CRUD operations on `Dictionary<K,V>` in .NET?
The time complexity of CRUD operations on Dictionary<K,V> in .NET is O(1) on average for retrieval, insertion, and removal, assuming a good hash function and proper load factor management.

96. Where are arrays stored? Primitive type arrays?
Arrays are stored on the managed heap in .NET. Primitive type arrays are stored as a contiguous block of memory on the managed heap.

97. What is the difference between an array (`T []`) and a list (`List<T>`)?
An array (T[]) has a fixed size that cannot be changed after creation, while a List<T> is a resizable collection that can grow or shrink dynamically.

98. What is the difference between IList<T> and IEnumerable<T>?
IList<T> is a collection that provides indexed access and modification methods, while IEnumerable<T> is a more basic interface for iterating over a collection.

99. Why do we need Enumerable, Observable, AsyncEnumerable, and what data retrieval models do they implement?
Enumerable, Observable, and AsyncEnumerable implement different data retrieval models:
Enumerable for synchronous pull-based retrieval.
Observable for push-based asynchronous retrieval.
AsyncEnumerable for asynchronous pull-based retrieval.

100. What is the difference between IEnumerable and IQueryable?
IEnumerable represents an in-memory collection, while IQueryable represents a query that can be executed against a data source (e.g., a database).

101. What are enum flags?
Enum flags are special values that can be combined using bitwise operations to represent multiple states or options simultaneously.

 

Databases
102. Explain normal forms in RDBMS.
Normal forms are rules or guidelines for designing relational database tables to minimize data redundancy and improve data integrity. The main normal forms are:

 

01
First Normal Form (1NF):
Eliminates multi-valued attributes and ensures that each cell in a table contains a single value.
02
Second Normal Form (2NF):
Meets 1NF and ensures that non-key attributes fully depend on the primary key.
03
Third Normal Form (3NF):
Meets 2NF and eliminates transitive dependencies, where non-key attributes depend on other non-key attributes.
04
Boyce-Codd Normal Form (BCNF):
Meets 3NF and ensures that every determinant is a candidate key.
05
Fourth Normal Form (4NF):
Meets BCNF and eliminates multi-valued dependencies.
06
Fifth Normal Form (5NF):
Meets 4NF and ensures that there are no redundant joins, also known as join dependencies.
Higher normal forms aim to eliminate more data redundancy and dependencies, leading to a more normalized database design.

103. What is an index in a database?
An index in a database is a data structure that stores a subset of data from a table to improve the speed of data retrieval operations. It works similarly to an index in a book, pointing to the location of specific data values within the table. Indexes are typically created on one or more columns of a table.

104. When should you use indexes? Pros and cons.
Indexes should be used when:

– Frequent queries involve searching, sorting, or retrieving data based on one or more columns.

– You need to enforce uniqueness constraints or foreign key relationships.

– You want to improve the performance of join operations between tables.

Pros of using indexes
Cons of using indexes
Faster data retrieval for queries involving indexed columns

Additional storage space is required for the index data structures

Improved query performance, especially for large tables

Due to index maintenance, increased overhead for data modification operations (inserts, updates, deletes)

Enforced uniqueness and integrity constraints

Potential for index fragmentation over time, leading to performance degradation

105. What types of indexes exist? How do they differ?
There are several types of indexes in databases:

Clustered Index: Physically reorders the data rows in the table based on the index key values. Only one clustered index is allowed per table.
Non-Clustered Index: Stores the index keys and pointers to the corresponding data rows, keeping the data rows' physical order unchanged. Multiple non-clustered indexes are allowed per table.
Unique Index: Ensures that the indexed column(s) have unique values across all rows in the table.
Composite Index: Indexes multiple columns within the same index structure.
Covering Index: Includes all the columns required for a query, eliminating the need to access the data rows directly.
Full-Text Index: Optimized for text-based searches, allowing for pattern matching and linguistic analysis.
Spatial Index: Used for efficiently querying and retrieving spatial data, such as geographic coordinates.
These index types differ in structure, storage mechanisms, and optimizations for various queries and data access patterns.

106. What is ACID?
ACID is an acronym that represents four essential properties of database transactions:

Atomicity: A transaction is an indivisible unit of work; either all of its operations are completed successfully or none are executed.
Consistency: A transaction must leave the database in a valid state, following all defined rules, constraints, and integrity constraints.
Isolation: Concurrent transactions must execute independently and not interfere with each other, even if they operate on the same data.
Durability: Once a transaction is committed, its effects must persist and remain permanent, even in the event of system failure or power outage.

ACID properties ensure database transactions’ reliability, integrity, and consistency, enabling applications to maintain data integrity and prevent corruption or inconsistent states.

107. What transaction isolation levels do you know?
The main transaction isolation levels in databases are:

Read Uncommitted: The lowest isolation level, where a transaction can read data that has been modified but not yet committed by other transactions. It can lead to dirty reads.
Read Committed (Default in SQL Server): A transaction can only read data that has been committed by other transactions, avoiding dirty reads. However, it is still susceptible to non-repeatable reads and phantom reads.
Repeatable Read: A transaction can read the same data multiple times and get consistent results, preventing non-repeatable and phantom reads.
Serializable: The highest isolation level, where transactions are executed as if they were happening one after another, even if they are running concurrently. This level prevents all data anomalies but may reduce concurrency and performance.
108. What is a query execution plan in MS SQL?
A query execution plan in Microsoft SQL Server is a strategy that the database engine generates to execute a given SQL query. It represents the sequence of operations and algorithms the query optimizer chooses to retrieve the requested data efficiently.

The query execution plan provides insights into the following:

The order of operations (e.g., table scans, index seeks, joins, sorts, aggregations)
The specific indexes and data structures used
The estimated cost and resource utilization (CPU, memory, I/O)
The data flow and data access patterns
By analyzing the query execution plan, database administrators and developers can:

Identify potential performance bottlenecks or inefficient operations
Optimize queries by modifying indexing strategies or query structures
Understand the reasoning behind the query optimizer's choices
Diagnose and troubleshoot slow-performing queries
109. Problem: a query is taking a long time to execute. What methods are there for diagnosing and solving this?
When a query is taking a long time to execute, there are several methods you can use to diagnose and solve the issue:

Analyze the Query Execution Plan: Examine the query execution plan to identify potential bottlenecks, such as inefficient index usage, costly operations (e.g., table scans), or suboptimal join strategies.
Check Indexing Strategy: Verify if appropriate indexes exist for the columns involved in the query predicates, joins, and sorting operations. If necessary, create new indexes or modify existing ones.
Review Query Structure: Analyze the query structure and consider rewriting it using more efficient constructs, such as subqueries, derived tables, or common table expressions (CTEs).
Check Statistics:Ensure the database statistics are up-to-date, as outdated statistics can lead to suboptimal query plans.
Monitor Resource Usage: Use monitoring tools to check for resource contention or bottlenecks, such as high CPU usage, memory pressure, or disk I/O issues.
Partition Data: If the query involves large tables, consider partitioning the data to improve query performance and enable parallel execution.
Optimize Database Configuration: Review database configuration settings, such as memory allocation, cost thresholds, and query optimization levels, and adjust them as needed.
Implement Caching: If the query involves repetitive or static data, consider implementing caching mechanisms to avoid redundant database queries.
Parallelize Queries: Investigate if the query can be parallelized or if the database supports parallel query execution to leverage multiple CPU cores.
Denormalize Data: In some cases, denormalizing data by introducing redundancy can improve query performance, but it should be carefully weighed against potential data integrity and maintenance concerns.
Often, a combination of these methods, along with profiling and iterative testing, leads to optimal query performance.

110. How do ORMs (Entity Framework or Entity Framework Core) translate C# code into database query language? What is used for this?
ORMs like Entity Framework and Entity Framework Core use a component called LINQ to Entities (LINQ to EF) to translate C# LINQ queries into database query language (SQL). LINQ to Entities acts as a query provider, taking the LINQ query expression and translating it into an expression tree. This expression tree is then processed by the Entity Framework query pipeline, which generates the corresponding SQL query to be executed against the database. The translation process involves analyzing the expression tree, applying optimization rules, and mapping the LINQ constructs to their SQL equivalents.

 

Parallelism
111. Why use Task.ConfigureAwait?
The Task.ConfigureAwait method controls the context-capturing behavior of await expressions in asynchronous methods. It is particularly important when writing code interacting with user interfaces, such as Windows Presentation Foundation (WPF) or Windows Forms applications.

When an asynchronous method is awaited without ConfigureAwait, the continuation (code after the await) will capture and resume on the same context (e.g., UI thread) that triggered the asynchronous operation. It can lead to performance issues and potential deadlocks if the awaited task is not related to the UI thread’s work.

By calling ConfigureAwait(false), you instruct the asynchronous method to resume its continuation on a different context (e.g., a thread pool thread) rather than capturing the original context. It helps to prevent unnecessary context switches and improves performance, especially in scenarios where the awaited task does not require the UI thread’s context.

In summary, using Task.ConfigureAwait(false) is recommended in non-UI asynchronous methods to avoid unnecessarily capturing the UI thread’s context, which can lead to performance issues and deadlocks.

112. For example, a web server performs a database query for an HTTP request. The server has 16 threads in total. Each HTTP request executes a database query and waits for the results, blocking the thread. Can this be optimized using .NET means?
This scenario can be optimized using asynchronous programming in .NET. Instead of blocking threads waiting for database queries, use async/await with asynchronous database operations, allowing threads to be released back to the thread pool while waiting. Also, consider increasing the maximum thread pool size if expecting high concurrency.

113. Why is the ThreadPool needed? Describe the mechanics: how a thread is allocated and returned to the ThreadPool.
The ThreadPool provides an efficient way to manage and reuse threads for asynchronous/parallel tasks, avoiding the overhead of manual thread creation/termination. When a task is requested, the ThreadPool allocates an available thread from its queue; if none is available and under the max limit, it creates a new thread. After executing the task, the thread is returned to the queue for reuse until an idle timeout, then terminated.

.NET Interview Questions for Senior Developers
For senior .NET developer interviews, initial rounds screen in-depth .NET frameworks knowledge and design patterns. Technical rounds involve architecting complex systems, optimizing performance, and answering senior .NET developer interview questions. Candidates often solve distributed system design and database scalability problems.

Senior .NET developer

General .NET Interview Questions
114. What other practices besides OOP have you used (AOP, FP, etc.)?
Besides OOP, Aspect-Oriented Programming (AOP) is used to cross-cut concerns.
Functional Programming (FP) concepts like LINQ and lambda expressions.
Event-Driven Programming for loosely coupled systems.
Reactive Programming with Reactive Extensions (Rx).
Domain-Driven Design (DDD) for modeling complex domains.

115. Name three of the most complex problems you’ve had to solve. How did you solve them, and how did you arrive at that solution?
Complex problems include implementing a distributed caching system (used Redis, data partitioning, failover), optimizing a data-intensive ETL process (parallelization, performance tuning), and developing a real-time messaging system (used message queues, load balancing, failover). Solutions involved researching technologies, prototyping, performance testing, and iterative design.

116. What is loosely-coupled code? How is it better than tightly-coupled code? How would you achieve loose coupling?
Loosely-coupled code has minimal dependencies between components, enabling independent development and evolution. It’s better than tightly-coupled code, which is harder to maintain and change. Achieve loose coupling through abstractions (interfaces), dependency injection, event-driven communication, and modular design.

117. Does using static classes increase or decrease code coupling?
Static classes can increase code coupling by introducing global states and dependencies across the codebase. Static classes are best used judiciously for utility classes or when truly required.

118. How can you measure code performance? Does the act of measuring affect performance?
Code performance can be measured using profiling tools, benchmarking frameworks, and performance counters. The act of measuring can affect performance due to instrumentation overhead.

119. What are multi-stage builds in Docker, and how do they work?
Multi-stage builds in Docker are a feature that allows you to build your Docker image in multiple stages. It is useful for reducing the final image size by only including the necessary files and dependencies. Each stage can use a different base image, and you can copy artifacts from one stage to the next.

120. How can you tell when a piece of code is consuming a lot of memory or running slowly? What can be a bottleneck in different cases? What are ways to reduce memory usage and memory traffic?
You can use profiling tools like memory and CPU profilers to identify code that consumes a lot of memory or runs slowly. Potential bottlenecks could be CPU-bound tasks, I/O-bound tasks, or memory-intensive operations. You can optimize data structures, limit allocations, and use techniques like memory pooling to reduce memory usage. To reduce memory traffic, you can improve cache utilization, minimize data copying, and optimize memory access patterns.

121. How would you implement a cross-cutting concern (e.g., logging, validation, transactions)?
You can use design patterns like the Decorator or Aspect-Oriented Programming (AOP) approach to implement cross-cutting concerns like logging, validation, or transactions.

122. Tell me about the REST Maturity Model.
The REST Maturity Model is a framework for evaluating the level of “RESTfulness” in an API. It has four levels: Level 0 (the most basic), Level 1 (resource-oriented), Level 2 (HTTP verbs), and Level 3 (hypermedia controls).

123. What are CPU-bound and IO-bound tasks?
CPU-bound tasks, such as mathematical computations, primarily use the CPU. while
I/O-bound tasks involve waiting for external resources, such as reading from a database or making network requests.

124. What is marshaling?
Marshaling is the process of converting an object’s internal representation into a format that can be transmitted, stored, or read from a stream.

125. How does async/await work (in detail)? Why can’t you use async void methods?
Async/await in programming languages like C# and JavaScript allows developers to write asynchronous code that appears synchronous. The await keyword pauses the execution of the current method until the asynchronous operation is complete, allowing the thread to be used for other tasks in the meantime. Async void methods are not recommended because they can be difficult to handle errors and exceptions.

 

.NET Framework Interview Questions
126. How does the lock statement work? Can you use structs inside a lock expression?
The lock statement in C# acquires a mutual exclusion lock on a given object, ensuring that only one thread can execute the code within the lock block at a time. Structs can be used inside a lock expression, but it’s generally not recommended as structs are value types and can lead to unexpected behavior.

127. What are Expression Trees?
Expression Trees represent code in a tree-like data structure, where each node represents a particular code construct, such as a method call, a variable, or an operator. They are used in LINQ and other advanced .NET features to analyze and manipulate code at runtime.

128. How does the Garbage Collector work (in detail)? Why are there three generations in GC, not five, ten, or two?
The .NET Garbage Collector (GC) automatically reclaims memory occupied by objects no longer in use. GC uses a generational approach, with three generations (0, 1, and 2), to optimize performance. Newer objects are placed in generation 0, and if they survive multiple collections, they are promoted to higher generations. This approach collects the most frequently used, short-lived objects more often.

129. How would you set up tracing for Web API services?
You can use tools like Application Insights or Elastic APM to set up tracing for Web API services. These provide out-of-the-box integration with ASP.NET Core and allow you to collect and analyze various telemetry data.

130. How can you configure secret storage for .NET Core applications on developer machines and production environments?
For secret storage in .NET Core applications, you can use solutions like Azure Key Vault, AWS Secrets Manager, or HashiCorp Vault. These provide a secure way to store and manage sensitive information in development and production environments, such as connection strings and API keys.

131. How would you organize the CI/CD process for .NET Core services to deploy them to a cloud infrastructure?
To organize the CI/CD process for .NET Core services, you can use tools like Azure DevOps, GitHub Actions, or Jenkins. These allow you to set up automated build, test, and deployment pipelines, ensuring consistent and reliable deployments to your cloud infrastructure.

132. How do you enable CORS in ASP.NET Core?
In ASP.NET Core, you can enable CORS (Cross-Origin Resource Sharing) by configuring the CorsOptions in the Startup.cs file. It allows you to specify which origins, headers, and HTTP methods are allowed to access your API.

 

Data Types, Collections, and Data Structures
133. How are generics implemented?
Generics in .NET are implemented using a technique called “type erasure.” During compilation, the generic type parameters are replaced with their constrained types, and the resulting code is then compiled as if the generic types were not present.

134. How do you create your immutable type?
To create your immutable type, you can make the class sealed and ensure that all its properties are read-only. You can also make the class’s constructor private and provide a static factory method to create instances of the class.

135. How does IEnumerable<T> work (in detail)?
IEnumerable<T> is a simple interface that defines a single method, GetEnumerator(), which returns an IEnumerator<T>. This interface allows you to iterate over a collection of items without exposing the underlying data structure.

136. What algorithm does the STACK collection use?
The STACK collection uses a Last-In-First-Out (LIFO) algorithm, where elements are added and removed from the top of the stack.

137. What data structures have you implemented yourself for the .NET platform? How did they differ from the standard implementations?
I have implemented several custom data structures for the .NET platform, including a custom Linked List and a Priority Queue. These implementations often differ from the standard .NET collections regarding performance characteristics, memory usage, or specialized functionality.

138. How do interfaces differ from abstract classes? In what cases would you use one or the other?
The main difference between interfaces and abstract classes is that interfaces can only define method signatures, properties, events, and indexers. At the same time, abstract classes can include method implementations, fields, and constructors. Interfaces are generally used to define contracts or APIs, while abstract classes are used to provide a base implementation for related types.

139. Why don’t structs have a default constructor?
Structs in .NET do not have a default constructor because they are value types, and value types are initialized with their default values (e.g., 0 for numeric types, false for bool, null for reference types) when created. Providing a default constructor for a struct would be redundant and could lead to unexpected behavior.

 

Databases
140. How do databases store data?
Databases store data in a structured way, typically in tables with rows and columns. The specific storage mechanisms vary between different database management systems (DBMS). However, they generally use a combination of in-memory caching, disk-based storage, and indexing to optimize performance.

141. What types of databases do you know?
The main types of databases include Relational Database Management Systems (RDBMS), such as SQL Server, PostgreSQL, and MySQL, as well as NoSQL databases like MongoDB, Cassandra, and Redis.

142. When and which databases are better to use?
The choice of database depends on factors like the data model, scalability requirements, performance needs, and the type of queries the application will perform. RDBMS are well-suited for applications with structured data and complex relationships. In contrast, NoSQL databases excel at handling unstructured data and high-volume, high-velocity workloads.

143. What is denormalization?
Denormalization is the process of intentionally duplicating data in a database to improve query performance.

144. When and which transaction isolation levels can you use?
Transaction isolation levels determine how much interference can occur between concurrent transactions. The most common levels are READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, and SERIALIZABLE, each with different trade-offs between consistency and concurrency.

145. How are the ACID principles implemented in popular RDBMSs (SQL Server, PostgreSQL, etc.)?
ACID (Atomicity, Consistency, Isolation, Durability) principles are implemented in RDBMS through features like transaction management, locking mechanisms, and logging/recovery processes.

146. Have you ever optimized a database query? If so, how?
Database queries can be optimized by analyzing execution plans, adding appropriate indexes, and denormalizing data structures.

147. Describe potential issues you know of related to parallel database queries.
Potential issues with parallel database queries include deadlocks, race conditions, and increased contention for shared resources. These issues can lead to performance degradation or data consistency issues.

148. Which database would you use to implement a distributed lock mechanism? Discuss the implementation details.
A distributed lock mechanism can be implemented using a database that supports distributed transactions, such as SQL Server with Distributed Transaction Coordinator (DTC) or PostgreSQL with pg_dist_lock. The implementation would involve creating a table to store lock information and using transactions to acquire, release, and manage the locks.

 

Microservices
149. What problem do microservices solve?
Microservices solve the complexity problem in large, monolithic applications by breaking them down into smaller, independent services that can be developed, deployed, and scaled separately.

150. What are the ways microservices can communicate?
Microservices can communicate using various inter-service communication patterns, such as synchronous HTTP/REST, asynchronous messaging (e.g., queues, event buses), or a hybrid approach.

151. Discuss implementation options for distributed transactions in microservices.
Distributed transactions in microservices can be implemented using techniques like the Saga pattern. It coordinates multiple local transactions to achieve eventual consistency or by using a distributed transaction coordinator (DTC) like the one provided by SQL Server.

152. What is a circuit breaker?
A circuit breaker is a design pattern that helps manage failures in distributed systems by preventing cascading failures and providing fallback options when a downstream service is unavailable.

153. How would you debug a system composed of multiple microservices to trace the full request processing path?
To debug a microservices-based system, you can use distributed tracing tools like Jaeger or Zipkin, which allow you to trace the full request processing path across multiple services.

154. What are message brokers? What are at-least-once, at-most-once semantics? Are there any brokers that guarantee exactly-once semantics?
Message brokers like RabbitMQ, Apache Kafka, or Azure Service Bus facilitate asynchronous communication between microservices. At-least-once semantics ensure that a message is delivered at least once, while at-most-once semantics guarantee that a message is delivered at most once. Exactly-once semantics, which ensures a message is delivered exactly once, can be achieved using techniques like idempotency.

155. How should the broker client code work depending on the chosen semantics?
Depending on the chosen message delivery semantics, the broker client code should appropriately handle retries, timeouts, and error handling.

156. What queue-related tools are you familiar with (both in .NET and standalone products), and which would you choose and why?
I’m familiar with various queue-related tools, such as RabbitMQ, Apache Kafka, and Azure Service Bus. The choice would depend on factors like the application’s specific requirements, the team’s familiarity with the technology, and the overall ecosystem.

 

MS Azure Interview Questions
157. What types of services are available in Service Fabric?
Azure Service Fabric provides several types of services, including Stateless Services, Stateful Services, and Actor-based services. Stateless services are simple, scalable services without any persistent state, while Stateful services maintain their state. Actor-based services are a programming model that simplifies the development of highly scalable and reliable distributed applications.

158. What are the characteristics and limitations of Azure Table Storage?
Azure Table Storage is a NoSQL key-value store with high availability, durability, and scalability. Its key characteristics include eventual consistency, a limited query capability compared to SQL databases, and a maximum table size of 500 TB. It is well-suited for storing large amounts of semi-structured data, such as user profiles, device information, and log data.

159. How do you deal with the cold start problem in Azure Functions?

The cold start problem in Azure Functions refers to the delay in function execution when the runtime needs to spin up a new instance to handle a request. To mitigate this, you can use strategies like keeping the function app warm, using a consumption plan with a pre-warmed instance, or leveraging a dedicated App Service plan.

160. What’s the difference between queues and topics in Azure Service Bus?

In Azure Service Bus, queues deliver simple first-in, first-out (FIFO) message. At the same time, topics enable a publish-subscribe model where multiple subscriber rules can be defined to filter messages. Queues are useful for one-to-one communication, while topics are better suited for one-to-many scenarios.

.NET Core Interview Questions and Answers in 2025
.NET Core Interview Questions and Answers for Freshers/Beginners
1. What is .NET Core, and how is it different from the .NET Framework?‍
.NET Core is a cross-platform, high-performance framework for building modern cloud-based, internet-connected applications. Unlike the .NET Framework, which runs only on Windows, .NET Core supports Windows, macOS, and Linux, making it more versatile for cross-platform development.

2. How do you install .NET Core SDK?‍
You can download the .NET Core SDK from the official .NET website. Follow the installation guide for your specific operating system (Windows, macOS, or Linux).

3. What is the purpose of the dotnet new command?‍
The dotnet new command creates a new .NET Core project with a specific template (e.g., console app, web app, etc.). For example, dotnet new console creates a new console application.

4. How does .NET Core support cross-platform development?‍
.NET Core is designed to be platform-independent. It uses a runtime (CoreCLR) that can run on different operating systems. The same .NET Core application can run on Windows, macOS, and Linux without modification.

5. What are the main benefits of using .NET Core for application development?
Cross-platform support (Windows, macOS, Linux)
High performance and scalability
Modern development (support for cloud, microservices)
Open-source and community-driven
Unified development (build web, desktop, mobile, and cloud apps)
6. What is the role of the Common Language Runtime (CLR) in .NET Core?‍
The CLR is the runtime environment in .NET Core that manages the execution of .NET applications, providing services like memory management, exception handling, and garbage collection.

7. Explain the structure of a .NET Core project.‍
A typical .NET Core project contains files like Program.cs (entry point), Startup.cs (configuration), and appsettings.json (configuration settings). It also includes directories like Controllers, Views, wwwroot, and dependencies listed in the csproj file.

8. What is the difference between dotnet run and dotnet build commands?
dotnet build compiles the application without running it.
dotnet run compiles and runs the application.
9. How do you create a new ASP.NET Core MVC project from scratch?‍
Run the command dotnet new mvc -n ProjectName to create a new ASP.NET Core MVC project. Then, navigate to the project directory and run dotnet run to launch the project.

10. What is Kestrel, and why is it used in .NET Core?‍
Kestrel is a cross-platform web server for ASP.NET Core applications. It is used to serve HTTP requests and can run behind other web servers like IIS or Nginx, or as a standalone server.

11. How does .NET Core support dependency injection?‍
.NET Core has built-in support for dependency injection (DI) through the IServiceCollection and IServiceProvider interfaces. You can register services in the Startup.cs file using methods like AddSingleton, AddScoped, and AddTransient.

12. Explain what middleware is in ASP.NET Core.‍
Middleware is software that handles requests and responses in an ASP.NET Core application. Middleware components are executed in a pipeline, where each component can either pass the request to the next component or terminate the pipeline.

13. How does routing work in ASP.NET Core MVC?‍
Routing in ASP.NET Core MVC maps incoming requests to controller actions. Routes are defined in the Startup.cs file, typically using the UseEndpoints or MapControllerRoute methods.

14. What is an API controller, and how does it differ from an MVC controller in .NET Core?‍
API controllers are specifically used for building Web APIs. They return data (e.g., JSON) rather than views. API controllers use the [ApiController] attribute to enable features like automatic model validation.

15. What is appsettings.json, and how do you configure settings in it?‍
appsettings.json is a configuration file used in .NET Core applications to store settings like database connection strings, environment settings, and more. You can access these settings through the IConfiguration interface in .NET Core.

16. What is Entity Framework Core, and what is its primary use?‍
Entity Framework Core (EF Core) is an Object-Relational Mapping (ORM) framework that allows developers to interact with databases using .NET objects, eliminating the need for most SQL queries.

17. How do you connect a .NET Core application to a SQL Server database?‍
Add a connection string to appsettings.json, then configure it in Startup.cs using the AddDbContext method. You can then inject the DbContext into your application to interact with the database.

18. How does the IConfiguration interface work in .NET Core?‍
The IConfiguration interface provides access to configuration settings, allowing you to read key-value pairs from files like appsettings.json, environment variables, or command-line arguments.

19. What are NuGet packages, and how are they used in .NET Core projects?‍
NuGet is a package manager for .NET. NuGet packages are libraries that you can add to your project to use third-party or shared code. You can install them via the dotnet add package command.

20. Explain how you handle errors using try-catch in .NET Core.‍
The try-catch block is used to handle exceptions. You place the code that might throw an exception inside the try block and handle the exception in the catch block.

21. What is the role of the Program.cs file in a .NET Core project?‍
Program.cs is the entry point of a .NET Core application. It contains the Main method, which starts the application by calling CreateHostBuilder and setting up the host.

22. What is Startup.cs, and what are its responsibilities?‍
Startup.cs configures the services and the request pipeline for the application. It defines the ConfigureServices method for DI configuration and Configure method for request processing pipeline configuration.

23. How do you enable HTTPS in a .NET Core application?‍
To enable HTTPS, configure your project to use HTTPS in launchSettings.json. Also, add middleware like UseHttpsRedirection in the Startup.cs file.

24. How do you implement basic logging in .NET Core?‍
.NET Core provides built-in logging support through the ILogger interface. You can inject ILogger into controllers or services and log information using methods like LogInformation, LogWarning, and LogError.

25. What is model binding in ASP.NET Core MVC?‍
Model binding is the process of mapping incoming request data (such as form data or query parameters) to action method parameters.

26. Explain what ViewData, ViewBag, and TempData are in ASP.NET Core.
ViewData: A dictionary for passing data from controller to view.
ViewBag: A dynamic wrapper around ViewData for easier access to data.
TempData: Used to store data temporarily between two requests, typically after a redirect.
27. How do you implement validation in ASP.NET Core using data annotations?‍
Data annotations are attributes applied to model properties to enforce validation. For example, [Required], [Range], and [StringLength] are used for validation. These attributes are checked automatically by the model binder.

28. What is a RESTful API, and how do you build one using ASP.NET Core?‍
A RESTful API follows REST principles like stateless communication, resource representation, and HTTP methods. You can create a RESTful API in ASP.NET Core by creating controllers that return data (usually JSON) and use HTTP methods like GET, POST, PUT, and DELETE.

29. How do you consume a Web API in a .NET Core application?‍
You can use HttpClient to consume a Web API. Create an instance of HttpClient, send a request using GetAsync or PostAsync, and process the response.

30. How do you manage cookies in an ASP.NET Core application?‍
You can manage cookies using the HttpContext.Response.Cookies.Append method to set cookies and HttpContext.Request.Cookies to read them.

31. What are filters in ASP.NET Core?‍
Filters allow you to run code before or after an action method executes. Examples include authorization filters, resource filters, action filters, and exception filters.

32. How do you handle user authentication in an ASP.NET Core application?‍
ASP.NET Core supports authentication through Identity, JWT, or OAuth. You configure authentication in Startup.cs and use middleware to handle login, registration, and token validation.

33. What is Razor, and how is it used in ASP.NET Core MVC?‍
Razor is a templating engine used to generate dynamic HTML in MVC views. It allows you to embed C# code into HTML using the @ symbol.

34. How do you serve static files in a .NET Core application?‍
Use the Use Static Files middleware in Startup. cs to serve static files from the www root folder.

35. What is the View Component in ASP.NET Core MVC?‍
A View Component is a reusable component that renders part of a page. It is similar to partial views but allows for more complex logic.

36. How do you return JSON data from a controller in ASP.NET Core?‍
Return a JSON result from an action method using return J son(object) or return Ok(object) in an API controller.

37. How do you perform file uploads in ASP.NET Core?‍
Use the I Form File interface to handle file uploads. In the controller, read the uploaded file, process it, and save it to a specified location.

38. What are Tag Helpers in ASP.NET Core?‍
Tag Helpers are server-side components that generate HTML and provide a way to interact with Razor views. Examples include asp-for, asp-controller, and asp-action.

39. How do you publish a .NET Core application?‍
Use the dotnet publish command to compile and package the application for deployment. You can also specify the target runtime (e.g., Windows, Linux) during the publishing process.

40. What are global exception handlers, and how do you implement them in .NET Core?‍
Global exception handling can be implemented using middleware. You create custom middleware that catches exceptions and handles them centrally, ensuring that all unhandled exceptions are captured.

.NET Core Interview Questions and Answers for Intermediates
1. How do you implement Dependency Injection (DI) in .NET Core?
Dependency Injection (DI) is a design pattern used to implement IoC (Inversion of Control), allowing you to manage the dependencies of classes. In .NET Core, DI is a first-class citizen, and the framework provides built-in support for it.

To implement DI in .NET Core:

Register services: You define the service in the Startup.cs file, inside the ConfigureServices method. You can register services with different lifetimes like Transient, Scoped, or Singleton.

Example:

public void ConfigureServices(IServiceCollection services)
{
    // Register IMyService with MyService as a dependency
    services.AddTransient<IMyService, MyService>();
}
AddTransient: A new instance of the service is created every time it is requested.
AddScoped: The same instance is used within a request, but different instances are created for different requests.
AddSingleton: A single instance is used throughout the application's lifetime.
Inject services: You inject the registered services into a class, typically via the constructor.

Example:

public class MyController : Controller
{
    private readonly IMyService _myService;

    // Constructor Injection
    public MyController(IMyService myService)
    {
        _myService = myService;
    }

    public IActionResult Index()
    {
        var result = _myService.DoSomething();
        return View(result);
    }
}
‍

Resolve services: The framework automatically resolves and provides the dependency at runtime based on what’s registered in the service container.

This approach reduces tight coupling, improves testability (by injecting mock services in unit tests), and makes your code cleaner and more maintainable.

2. What are the different service lifetimes in ASP.NET Core (Transient, Scoped, Singleton)?
‍In ASP.NET Core, services can be registered with different lifetimes, depending on how they should behave during the application's lifecycle. There are three main lifetimes:

Transient:

A new instance of the service is created each time it is requested.
Best for lightweight, stateless services where each request requires a fresh instance.
Example:

services.AddTransient<IMyService, MyService>();
‍

Use case: For services that maintain a global state, such as configuration settings or logging mechanisms.

Choosing the right lifetime depends on the service's behavior and how it manages state. For instance, services that don’t need to share state should be transient, while services that manage state for the application should be singletons.

‍3. How do you register services in the Startup .cs file in .NET Core?
‍In ASP.NET Core, service registration is handled within the Configure Services method in the Startup. cs file. You use the I Service Collection interface to register your dependencies. There are three common types of service lifetimes: Transient, Scoped, and Singleton (as described above), and each type is registered by calling a corresponding method on I Service Collection.

Example of registering services:

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        // Register a transient service
        services.AddTransient<IEmailService, EmailService>();

        // Register a scoped service
        services.AddScoped<IUserService, UserService>();

        // Register a singleton service
        services.AddSingleton<ILogger, Logger>();

        // Register framework services
        services.AddControllers();
    }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        // Configure the middleware pipeline
        app.UseRouting();
        app.UseEndpoints(endpoints =>
        {
            endpoints.MapControllers();
        });
    }
}
‍

Steps:

Define the interface and implementation classes: These classes define the service logic.
Add them to IServiceCollection in ConfigureServices: Register each service with its appropriate lifetime (AddTransient, AddScoped, AddSingleton).
Inject them where needed: Once registered, you can inject these services into controllers, other services, or middleware using constructor injection.
This approach ensures that your application’s dependencies are centralized and easy to manage, while supporting the core principles of DI and IoC.

4. Explain the difference between IActionResult and ActionResult in an ASP.NET Core controller.
Both IActionResult and ActionResult are used as return types for ASP.NET Core controller actions, but there are some key differences:

IActionResult:

IActionResult is an interface that represents a wide variety of possible return types for controller actions.
It allows for greater flexibility as it can represent any type that implements IActionResult, such as ViewResult, JsonResult, RedirectResult, ContentResult, etc.
Example:

public IActionResult MyAction()
{
    return View();  // ViewResult
}
‍

Action Result:

Action Result is a concrete class that inherits from IAction Result. It provides additional helper methods like Ok(), BadRequest(), NotFound(), etc.
Using Action Result provides more specific types for returning standardized HTTP responses.
Example:

public ActionResult MyAction()
{
    return Ok();  // Returns a 200 OK status with a response body.
}
‍

When to use which?

Use IActionResult when you want more flexibility and the method could return various response types.
Use ActionResult when you specifically want to return HTTP status code responses like Ok, BadRequest, NotFound.
5. What is model validation, and how do you handle it in ASP.NET Core MVC?
Model validation is the process of ensuring that incoming data from HTTP requests conforms to the rules defined in your data models. ASP.NET Core provides a built-in mechanism to validate models using data annotations.

Defining validation rules: Use data annotations to apply validation rules to your model properties:

public class UserModel
{
    [Required(ErrorMessage = "Username is required")]
    [StringLength(50, MinimumLength = 3, 
    ErrorMessage = "Username must be between 3 and 50 characters")]
    public string Username { get; set; }

    [Required]
    [EmailAddress(ErrorMessage = "Invalid email format")]
    public string Email { get; set; }
}
‍

Handling validation in the controller: In your controller action, you can check if the model is valid using ModelState.IsValid:

public IActionResult Register(UserModel userModel)
{
    if (ModelState.IsValid)
    {
        // Process the valid model
        return RedirectToAction("Success");
    }

    // If the model is invalid, return the same view with validation messages
    return View(userModel);
}
‍

Displaying validation messages in the view: In the Razor view, use HTML helpers to display validation messages:

<form asp-action="Register">
    <input asp-for="Username" />
    <span asp-validation-for="Username" class="text-danger"></span>

    <input asp-for="Email" />
    <span asp-validation-for="Email" class="text-danger"></span>

    <button type="submit">Register</button>
</form>
‍

Custom validation attributes: If the built-in validation attributes are not sufficient, you can create custom validation attributes by inheriting from Validation Attribute:

public class CustomValidationAttribute : ValidationAttribute
{
    protected override ValidationResult IsValid
    (object value, ValidationContext validationContext)
    {
        // Custom logic
        return ValidationResult.Success;
    }
}
‍

Model validation ensures that data is clean and reliable before it is processed by the application, helping to prevent errors and inconsistencies.

‍6. What is Middleware in ASP.NET Core? How does it work?
Middleware in ASP.NET Core is software that sits between the incoming HTTP request and the outgoing HTTP response. It is responsible for handling and processing HTTP requests, and each piece of middleware can either:

Process the request and generate a response, or
Pass the request to the next middleware in the pipeline.
Middleware components are executed in the order they are registered in the Startup.cs file, and each one has the option to terminate the request by generating its own response or delegate the request to the next middleware.

‍Example:

public class Startup
{
    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        // Middleware to log requests
        app.Use(async (context, next) =>
        {
            Console.WriteLine("Incoming Request: " + context.Request.Path);
            await next.Invoke(); // Pass to the next middleware
            Console.WriteLine("Outgoing Response: " + context.Response.StatusCode);
        });

        // Static files middleware
        app.UseStaticFiles();

        // Routing middleware
        app.UseRouting();

        // Endpoint middleware
        app.UseEndpoints(endpoints =>
        {
            endpoints.MapControllers();
        });
    }
}
‍

In this example, the first middleware logs the request and response. It calls next.Invoke() to pass control to the next middleware in the pipeline (static files, routing, etc.).

Middleware is highly customizable and plays a central role in configuring the HTTP request pipeline in ASP.NET Core.

7. Explain the concept of Routing in ASP.NET Core.
Routing in ASP.NET Core is a mechanism to map incoming HTTP requests to the appropriate controller actions or endpoints. Routing can be convention-based or attribute-based.

Convention-based routing: You define routing patterns in the Startup.cs file using UseRouting() and UseEndpoints(). The routing pattern can include parameters for controllers, actions, and route variables.

Example:

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllerRoute(
            name: "default",
            pattern: "{controller=Home}/{action=Index}/{id?}");
    });
}
‍

This routing pattern maps requests to the appropriate controller and action, with an optional id parameter.

Attribute routing: You can use attributes to define routing directly on controllers or actions. This allows for more fine-grained and flexible routing.

Example:

[Route("products")]
public class ProductsController : Controller
{
    [Route("details/{id}")]
    public IActionResult Details(int id)
    {
        // Return product details based on id
        return View();
    }
}
‍

This route will match /products/details/{id}, where id is a route parameter.

Routing is a key component in directing incoming requests to the right controller or action, and ASP.NET Core allows you to mix both convention-based and attribute-based routing in the same application.

‍8. How do you handle exceptions in ASP.NET Core?
‍ASP.NET Core provides several mechanisms for handling exceptions: Developer Exception Page: For development environments, you can use the developer exception page to display detailed error information.

This is useful for debugging.

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
}
‍

Exception Handling Middleware: In production environments, you use exception handling middleware to catch and handle exceptions globally. You can redirect to a custom error page, log the error, or return a generic response.

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (!env.IsDevelopment())
    {
        app.UseExceptionHandler("/Home/Error");
        app.UseHsts();
    }
}
‍

In this case, any unhandled exceptions will be caught and the user will be redirected to the /Home/Error route.

Custom exception handling middleware: You can also create custom middleware to handle exceptions and log them.

app.Use(async (context, next) =>
{
    try
    {
        await next();
    }
    catch (Exception ex)
    {
        // Log exception
        await context.Response.WriteAsync("An error occurred.");
    }
});
‍

Global Exception Filters: In MVC, you can handle exceptions globally by using exception filters.

public class CustomExceptionFilter : IExceptionFilter
{
    public void OnException(ExceptionContext context)
    {
        context.Result = new RedirectToActionResult("Error", "Home", null);
    }
}
‍

This filter can be applied globally to handle exceptions in all actions and controllers.

Exception handling ensures that errors are properly logged, and users are presented with user-friendly error messages instead of seeing raw exception details.

‍9. What is the difference between I Application Builder. Use and I Application Builder. Run in ASP.NET Core?
‍In ASP.NET Core, both Use and Run are methods used to add middleware to the HTTP request pipeline, but they serve different purposes.

Use:

Use allows you to execute a piece of middleware and then pass control to the next middleware in the pipeline using next().
It is useful when you want to perform some action and still allow subsequent middleware to run.
Example:

app.Use(async (context, next) =>
{
    // Perform some logic
    Console.WriteLine("Inside Use Middleware");

    await next(); // Pass control to the next middleware
});
‍

Run:

Run is a terminal middleware. Once Run is called, the pipeline is short-circuited, and no further middleware will be executed.
Example:

app.Run(async (context) =>
{
    await context.Response.WriteAsync("Hello from Run Middleware");
});
‍

In this case, no other middleware registered after Run will be executed, as Run terminates the pipeline.

Key difference:

Use allows the request to flow through the pipeline, invoking subsequent middleware, while Run terminates the pipeline after it is executed.
10. What are Filters in ASP.NET Core MVC? What are the types of filters?
Filters in ASP.NET Core MVC are used to execute custom logic before or after certain stages in the request pipeline, such as before an action is executed or after a result is returned. Filters provide a way to implement cross-cutting concerns like logging, authorization, caching, and exception handling.There are several types of filters:

Authorization Filters:

Run before the action is executed to determine whether the user is authorized to execute the action.
Example: [Authorize] attribute is an authorization filter.
Custom Authorization Filter:

public class CustomAuthFilter : IAuthorizationFilter
{
    public void OnAuthorization(AuthorizationFilterContext context)
    {
        // Custom authorization logic
    }
}
‍

Action Filters:

Run before or after the action method is executed.
Use case: Logging or modifying input parameters.
Example:

public class CustomActionFilter : IActionFilter
{
    public void OnActionExecuting(ActionExecutingContext context) { }
    public void OnActionExecuted(ActionExecutedContext context) { }
}
‍

Exception Filters:

Handle exceptions thrown during the execution of an action or result.
Use case: Logging errors or returning a custom error response.
Example:

public class CustomExceptionFilter : IExceptionFilter
{
    public void OnException(ExceptionContext context)
    {
        context.Result = new RedirectToActionResult("Error", "Home", null);
    }
}
‍

Result Filters:

Run before or after the action result is executed.
Use case: Modifying or processing the result before it's sent to the client.
Example:

public class CustomResultFilter : IResultFilter
{
    public void OnResultExecuting(ResultExecutingContext context) { }
    public void OnResultExecuted(ResultExecutedContext context) { }
}
‍

Filters provide a way to inject custom behavior at different stages of the request processing pipeline, making them useful for cross-cutting concerns like authentication, caching, or logging.

‍11. What are Tag Helpers in ASP.NET Core?
Tag Helpers in ASP.NET Core are used to extend the functionality of HTML elements in Razor views. They allow you to add server-side processing logic to HTML tags in a clean and readable way, making your Razor views more expressive and maintainable.Tag Helpers are processed on the server, and they help you build dynamic content while still working with familiar HTML syntax.

‍Example:

<a asp-controller="Home" asp-action="Index">Home</a>
In this example:

asp-controller="Home": Specifies the controller to be used.
asp-action="Index": Specifies the action to be invoked in the HomeController.
ASP.NET Core includes many built-in Tag Helpers, such as:

asp-for: Generates HTML input elements bound to model properties.
asp-action, asp-controller: Used to generate hyperlinks to actions.
asp-validation-for: Displays validation messages for form fields.
You can also create custom Tag Helpers by inheriting from the TagHelper base class.

Creating a custom Tag Helper:

public class EmailTagHelper : TagHelper
{
    public string Address { get; set; }
    public string Display { get; set; }

    public override void Process(TagHelperContext context, TagHelperOutput output)
    {
        output.TagName = "a"; // Replaces <email> with <a> tag
        output.Attributes.SetAttribute("href", $"mailto:{Address}");
        output.Content.SetContent(Display);
    }
}
‍

Then, in your Razor view:

<email address="info@domain.com" display="Contact Us"></email>
‍

Tag Helpers are a powerful feature of ASP.NET Core that provide a clean way to generate dynamic content within Razor views, helping to separate presentation from logic.

12. How does ASP.NET Core support Cross-Origin Resource Sharing (CORS)?
Cross-Origin Resource Sharing (CORS) is a security feature implemented by web browsers to prevent unauthorized access to resources from different origins (domains). ASP.NET Core provides built-in support for configuring CORS policies to allow or restrict cross-origin requests.

Enable CORS in Startup.cs: You need to configure CORS in the Startup.cs file by using the services.AddCors() method inside ConfigureServices and applying CORS policies in Configure().
Example:

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddCors(options =>
        {
            options.AddPolicy("AllowSpecificOrigin",
                builder => builder.WithOrigins("https://example.com")
                                  .AllowAnyHeader()
                                  .AllowAnyMethod());
        });

        services.AddControllers();
    }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        app.UseCors("AllowSpecificOrigin");  // Apply the policy
        app.UseRouting();
        app.UseEndpoints(endpoints => endpoints.MapControllers());
    }
}
‍

In this example:

The policy "AllowSpecificOrigin" only allows requests from https://example.com.
AllowAnyHeader() allows all HTTP headers.
AllowAnyMethod() allows all HTTP methods (GET, POST, PUT, etc.).
Allowing CORS for All Origins: To allow requests from any origin, use the following:

builder.AllowAnyOrigin();
‍

Applying CORS Globally or to Specific Controllers: You can apply CORS globally or only to specific controllers/actions using the [EnableCors] attribute.

[EnableCors("AllowSpecificOrigin")]
public class MyController : Controller
{
    // Action methods
}
‍

CORS is essential for securing web applications and ensuring that only trusted domains can access your resources.

‍13. What is View Model in ASP.NET Core MVC? How is it different from a Model?
‍In ASP.NET Core MVC, a View Model is a class that represents the data and logic required specifically for the view. It is designed to transfer data between the controller and the view, and is often a combination of multiple models or properties tailored for the view's needs. Difference between View Model and Model:

Model:

Represents the domain or business logic of the application.
Contains data and validation rules for entities like User, Product, etc.
Used to interact with the database through ORM frameworks like Entity Framework.
ViewModel:

A custom class designed for the view, containing only the data needed for display or user interaction.
Can include properties from multiple models, as well as additional logic or formatting specific to the view.
Not tied to the database.
Example: If you have a User model:

public class User
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
}
‍

But your view needs both User information and some additional data like Role, you create a ViewModel:

public class UserViewModel
{
    public User User { get; set; }
    public string Role { get; set; }
}
‍

This UserViewModel provides the data required by the view, combining user information with role data.

ViewModels help decouple the view from the business logic, ensuring that only the necessary data is passed to the view, improving maintainability and security.

14. What is Kestrel, and why is it used in ASP.NET Core?
Kestrel is a cross-platform web server for ASP.NET Core. It is the default web server included with ASP.NET Core and provides high performance for handling HTTP requests.

Key features of Kestrel:

Cross-platform: Works on Windows, Linux, and macOS.
Performance: Designed for high performance, Kestrel can handle a large number of requests efficiently.
Lightweight: Kestrel is a lightweight server that is optimized for both development and production.
When to use Kestrel:

Kestrel can be used directly to serve ASP.NET Core applications during development and in production for scenarios where no additional reverse proxy (like IIS, Nginx, or Apache) is required.
For security and performance reasons, in a production environment, it is common to pair Kestrel with a reverse proxy like Nginx or IIS. The reverse proxy handles things like SSL termination, static file serving, and load balancing, while Kestrel manages dynamic content generation.
Example of configuring Kestrel in Program. cs:

public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseKestrel();  // Configures Kestrel as the web server
                webBuilder.UseStartup<Startup>();
            });
}
‍

Kestrel provides fast and lightweight server capabilities, making it ideal for serving ASP.NET Core applications.

15. How does ASP.NET Core support logging? What logging providers are available?
ASP.NET Core includes built-in support for logging to help developers capture and monitor events, errors, and application behavior. It provides a flexible and extensible logging framework that supports different logging providers.

Basic Logging Setup: Logging is configured in the Startup.cs file, and you can inject ILogger<T> into your classes to log messages.

Example:

public class HomeController : Controller
{
    private readonly ILogger<HomeController> _logger;

    public HomeController(ILogger<HomeController> logger)
    {
        _logger = logger;
    }

    public IActionResult Index()
    {
        _logger.LogInformation("Executing Index action");
        return View();
    }
}
‍

Logging Levels: ASP.NET Core provides several logging levels that indicate the severity of a log message:

Trace: Very detailed logs, used mainly for development.
Debug: Less detailed than trace, typically used for development debugging.
Information: General information about the application flow.
Warning: Indication of a possible issue.
Error: Errors that prevent the operation from continuing.
Critical: Critical errors causing the application to crash.
Logging Providers: ASP.NET Core supports multiple logging providers to log data to different outputs:

Console: Logs messages to the console.
Debug: Logs messages to the Visual Studio output window.
EventLog: Logs messages to the Windows Event Log (on Windows).
Azure Application Insights: For cloud-based logging and performance monitoring.
Third-party providers: Libraries like Serilog, NLog, and Log4Net can be integrated for advanced logging features.
Configure Logging in appsettings.json: You can configure logging settings (such as logging levels) in the appsettings.json file.

{
    "Logging": {
        "LogLevel": {
            "Default": "Information",
            "Microsoft": "Warning"
        }
    }
}
‍

ASP.NET Core provides a powerful and extensible logging framework that makes it easy to log messages, capture errors, and monitor application health using different logging providers.

‍16. What is Dependency Injection (DI) in ASP.NET Core?
Dependency Injection (DI) is a design pattern used in ASP.NET Core to achieve Inversion of Control (IoC), where the creation of dependencies (objects) is managed by an external component rather than the class that uses them. DI allows for better code maintainability, testability, and flexibility by promoting loose coupling between classes.ASP.NET Core has built-in support for DI, making it easy to inject dependencies into controllers, services, and other components.Types of Dependency Injection:

Constructor Injection (most common): Dependencies are provided via the constructor.
Method Injection: Dependencies are provided via method parameters.
Property Injection: Dependencies are provided via public properties.
Example of Constructor Injection:

Service Interface:

public interface IEmailService
{
    void SendEmail(string to, string subject, string body);
}
Service Implementation:

public class EmailService : IEmailService
{
    public void SendEmail(string to, string subject, string body)
    {
        // Email sending logic
    }
}
Registering Service in Startup.cs:

public void ConfigureServices(IServiceCollection services)
{
    services.AddTransient<IEmailService, EmailService>();
    services.AddControllers();
}
Injecting Service in Controller:

public class HomeController : Controller
{
    private readonly IEmailService _emailService;

    public HomeController(IEmailService emailService)
    {
        _emailService = emailService;
    }

    public IActionResult Index()
    {
        _emailService.SendEmail("example@domain.com", "Subject", "Body");
        return View();
    }
}
Lifetime of Services:

Transient: A new instance is created each time it is requested.
Scoped: A new instance is created per request.
Singleton: A single instance is created and shared throughout the application's lifetime.
17. What is the purpose of the Configure Services method in Startup. cs?
‍The Configure Services method in ASP.NET Core's Startup. cs file is used to configure the Dependency Injection (DI) container. It is where services are registered for use in the application. ASP.NET Core uses this method to register services such as MVC, custom services, middleware components, authentication services, database contexts, and more.

‍Example of Configure Services method:

public void ConfigureServices(IServiceCollection services)
{
    // Register MVC services
    services.AddControllersWithViews();
    
    // Register a custom service
    services.AddScoped<IEmailService, EmailService>();
    
    // Register a database context
    services.AddDbContext<ApplicationDbContext>(options =>
        options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
    
    // Add identity services for authentication
    services.AddIdentity<ApplicationUser, IdentityRole>()
            .AddEntityFrameworkStores<ApplicationDbContext>()
            .AddDefaultTokenProviders();
}
‍

In this example:

MVC services (AddControllersWithViews) are registered.
Custom services (IEmailService and EmailService) are registered with scoped lifetime.
A database context (ApplicationDbContext) is registered to use SQL Server.
Identity services are configured for authentication.
Once services are registered in ConfigureServices, they can be injected and used throughout the application via Dependency Injection.

18. What is the Configure method in Startup.cs used for in ASP.NET Core?
The Configure method in ASP.NET Core's Startup.cs file is used to define how the application will respond to incoming HTTP requests. It configures the middleware components that make up the HTTP request pipeline.

The order in which middleware components are added in the Configure method is critical because they are executed sequentially as the request flows through the pipeline.

Example of Configure method:

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    else
    {
        app.UseExceptionHandler("/Home/Error");
        app.UseHsts();
    }

    app.UseHttpsRedirection();
    app.UseStaticFiles();

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllerRoute(
            name: "default",
            pattern: "{controller=Home}/{action=Index}/{id?}");
    });
}
‍

In this example:

UseDeveloperExceptionPage: Shows detailed error information during development.
UseHttpsRedirection: Redirects HTTP requests to HTTPS.
UseStaticFiles: Enables serving static files (CSS, JS, images).
UseRouting: Enables routing to map requests to controllers and actions.
UseAuthentication and UseAuthorization: Enables authentication and authorization.
UseEndpoints: Defines the endpoints for the application, such as routing to controllers.
The Configure method sets up the middleware components that handle different stages of the request and response process.

19. What is the difference between AddScoped, AddTransient, and AddSingleton in ASP.NET Core?
In ASP.NET Core, service lifetimes define how long instances of services are kept in memory. When registering services in the DI container, you can specify one of three lifetimes: AddScoped, AddTransient, or AddSingleton.

AddTransient:

A new instance of the service is created each time it is requested.
Suitable for lightweight, stateless services.
Example:

services.AddTransient<IEmailService, EmailService>();
‍

AddScoped:

A new instance is created once per request (i.e., the same instance is used throughout the entire request).
Useful for services that should maintain state or cache data for the duration of the request.
Example:

services.AddScoped<IUserService, UserService>();
‍

AddSingleton:

A single instance is created once for the entire application lifetime (across all requests).
Suitable for services that are heavy to initialize or that should maintain a shared state.
Example:

services.AddSingleton<ILogger, Logger>();
‍

Key differences:

Transient: A new instance is provided each time the service is requested.
Scoped: A new instance is provided per request.
Singleton: A single instance is shared across the entire application.
Choosing the correct service lifetime is crucial for optimizing memory usage and ensuring the correct behavior of your services.

‍20. How do you implement Authentication and Authorization in ASP.NET Core?
Authentication and Authorization are essential aspects of securing ASP.NET Core applications.

Authentication:
Authentication is the process of verifying the user's identity (e.g., login credentials).
ASP.NET Core supports various authentication mechanisms such as cookies, JWT tokens, OAuth, and OpenID Connect.
Example of Cookie Authentication:

‍In Startup .cs, configure authentication in Configure Services:

public void ConfigureServices(IServiceCollection services)
{
    services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
            .AddCookie(options =>
            {
                options.LoginPath = "/Account/Login";
            });

    services.AddControllersWithViews();
}
In Configure, use app. Use Authentication() and app. Use Authorization():

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
    });
}
Authorization:
Authorization determines what actions a user can perform after their identity has been authenticated.
ASP.NET Core uses roles or claims for implementing authorization.
Example of Role-Based Authorization:

[Authorize(Roles = "Admin")]
public class AdminController : Controller
{
    public IActionResult Index()
    {
        return View();
    }
}
In this example, only users who belong to the "Admin" role can access the AdminController.

ASP.NET Core provides several built-in authorization mechanisms, including:

Role-based Authorization: Restrict actions to specific user roles.
Claims-based Authorization: Restrict actions based on specific claims or attributes of the user.
By combining authentication and authorization, you can effectively manage access control in ASP.NET Core applications.

‍

21. What is the purpose of the IApplicationBuilder interface in ASP.NET Core?
The IApplicationBuilder interface is used to configure the HTTP request pipeline in ASP.NET Core applications. It provides methods to define middleware components that process requests and responses as they pass through the pipeline.

The IApplicationBuilder instance is available in the Configure method of Startup.cs, and it is used to register middleware components such as routing, authentication, and static file serving.

Key methods of I Application Builder:

Use Routing: Sets up endpoint routing in the pipeline.
Use Authentication: Adds authentication middleware for validating user credentials.
Use Authorization: Adds authorization middleware to enforce access control based on user roles or claims.
Use Endpoints: Defines the routing endpoints for controllers, Razor pages, etc.
Use StaticFiles: Serves static files (CSS, JS, images, etc.) directly from the web root.
Example of I Application Builder in the Configure method:

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    else
    {
        app.UseExceptionHandler("/Home/Error");
        app.UseHsts();
    }

    app.UseHttpsRedirection();
    app.UseStaticFiles();
    app.UseRouting();
    app.UseAuthentication();
    app.UseAuthorization();
    
    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllerRoute(
            name: "default",
            pattern: "{controller=Home}/{action=Index}/{id?}");
    });
}
In this example, IApplicationBuilder is used to configure middleware components like error handling, HTTPS redirection, static file serving, routing, authentication, and authorization.

22. What is Middleware in ASP.NET Core, and how does it work?
Middleware in ASP.NET Core is software that is assembled into the application's request pipeline to handle requests and responses. Each middleware component can either process an incoming request and pass it to the next middleware in the pipeline or terminate the request by generating a response.

Middleware is executed in the order it is registered in the Configure method, which makes the order of middleware components critical.

Common ASP.NET Core middleware components:

UseRouting: Sets up endpoint routing.
UseAuthentication: Handles authentication.
UseAuthorization: Handles authorization based on user roles or claims.
UseStaticFiles: Serves static files like CSS, JavaScript, and images.
UseExceptionHandler: Handles exceptions globally.
Creating Custom Middleware: You can create custom middleware by implementing a class that takes an HttpContext object, processes the request, and either generates a response or passes the request to the next middleware component.

‍Example of custom middleware:

public class RequestLoggingMiddleware
{
    private readonly RequestDelegate _next;

    public RequestLoggingMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Log the incoming request
        Console.WriteLine($"Request: {context.Request.Method} {context.Request.Path}");
        
        // Call the next middleware in the pipeline
        await _next(context);
        
        // Log the response
        Console.WriteLine($"Response: {context.Response.StatusCode}");
    }
}
To use this middleware, it is added to the request pipeline in the Configure method:

public void Configure(IApplicationBuilder app)
{
    app.UseMiddleware<RequestLoggingMiddleware>();
}
Middleware in ASP.NET Core is an essential component for building modular and flexible request pipelines that can handle tasks like authentication, routing, and error handling.

23. How does the IHostingEnvironment interface help in configuring different environments in ASP.NET Core?
The IHostingEnvironment (or IWebHostEnvironment in later versions of ASP.NET Core) interface is used to provide information about the hosting environment of the application. This is helpful for configuring different settings or behaviors based on whether the application is running in Development, Staging, or Production.

Key properties of IWebHostEnvironment:

EnvironmentName: The name of the current environment (e.g., "Development", "Staging", "Production").
WebRootPath: The absolute path to the web root directory (typically wwwroot).
ContentRootPath: The absolute path to the root of the content files (e.g., appsettings.json).
ASP.NET Core uses environment variables (like ASPNETCORE_ENVIRONMENT) to determine the current environment. By default, the environment is set to "Production" unless specified otherwise.

Example of using IWebHostEnvironment in Startup.cs:

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();  // Only show detailed errors in Development
    }
    else
    {
        app.UseExceptionHandler("/Home/Error");  // Use generic error page in Production
        app.UseHsts();
    }

    app.UseHttpsRedirection();
    app.UseStaticFiles();
    app.UseRouting();
    app.UseAuthentication();
    app.UseAuthorization();
}
Configure different settings for different environments:

appsettings.json files can have environment-specific versions like appsettings.Development.json or appsettings.Production.json, which override default settings.
Example of loading different configurations based on the environment:

public void ConfigureServices(IServiceCollection services)
{
    if (env.IsDevelopment())
    {
        services.AddDbContext<ApplicationDbContext>(options =>
            options.UseSqlServer(Configuration.GetConnectionString("DevConnection")));
    }
    else
    {
        services.AddDbContext<ApplicationDbContext>(options =>
            options.UseSqlServer(Configuration.GetConnectionString("ProdConnection")));
    }
}
Using IWebHostEnvironment allows you to configure your application differently based on the environment, which is essential for debugging, testing, and deploying in production.

24. What is the role of UseEndpoints in ASP.NET Core, and how does endpoint routing work?
UseEndpoints is a middleware component in ASP.NET Core that is used to define and configure the endpoints that the application will respond to. It works in conjunction with endpoint routing, which allows you to map incoming requests to specific controllers, actions, or Razor Pages.

Endpoint routing is a feature that helps manage how requests are routed to controllers and Razor Pages, making routing more flexible and extensible.

How UseEndpoints works:

UseRouting: This middleware is responsible for matching the incoming request URL with the appropriate endpoint (controller, Razor Page, etc.).
UseEndpoints: This middleware processes the matched endpoint and generates the response.
Example of using UseEndpoints in the request pipeline:

public void Configure(IApplicationBuilder app)
{
    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllerRoute(
            name: "default",
            pattern: "{controller=Home}/{action=Index}/{id?}");
    });
}
In this example, UseRouting enables routing to endpoints, and UseEndpoints defines the endpoints (in this case, mapping requests to controllers and actions).

Common Endpoint Mapping Methods:

MapControllerRoute: Routes requests to MVC controllers.
MapRazorPages: Routes requests to Razor Pages.
MapGet, MapPost, MapPut, etc.: Routes specific HTTP verbs to handlers.
Endpoint routing is a powerful feature of ASP.NET Core that helps you manage how HTTP requests are routed and handled in a structured and efficient way.

25. How does ASP.NET Core handle static files?
ASP.NET Core can serve static files (such as HTML, CSS, JavaScript, images, and fonts) directly from the file system without needing to pass through the MVC pipeline. The static files are typically stored in the wwwroot folder, which acts as the web root for the application.

To enable static file serving in ASP.NET Core, you need to use the UseStaticFiles middleware.

Example of serving static files:

public void Configure(IApplicationBuilder app)
{
    app.UseStaticFiles();  // Enable static file serving
    app.UseRouting();
    
    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllerRoute(
            name: "default",
            pattern: "{controller=Home}/{action=Index}/{id?}");
    });
}
By default, static files are served from the wwwroot directory. You can place static assets like CSS, JavaScript, and images inside wwwroot and reference them in your views.

Example:

<link rel="stylesheet" href="/css/site.css" />
<img src="/images/logo.png" alt="Logo" />
If you want to serve static files from a different directory or configure caching for static files, you can use additional options:

app.UseStaticFiles(new StaticFileOptions
{
    FileProvider = new PhysicalFileProvider
    (Path.Combine(Directory.GetCurrentDirectory(), "MyStaticFiles")),
    RequestPath = "/StaticFiles"
});
In this example, static files are served from the "MyStaticFiles" directory, and they are accessed via the /StaticFiles URL.

Handling static files in ASP.NET Core is simple and efficient, allowing for direct file serving with optional caching and customization options.

Here are the next five intermediate-level .NET Core interview questions and their detailed answers:

26. What is Kestrel in ASP.NET Core, and why is it used?
Kestrel is a cross-platform, high-performance, open-source web server built into ASP.NET Core. It is the default web server used to host ASP.NET Core applications.

Kestrel is designed to be lightweight and fast, making it suitable for serving applications directly in both development and production environments. However, for security reasons, it is often used behind a reverse proxy such as Nginx or IIS in production deployments.

Why Kestrel is used:

Cross-platform support: It runs on Windows, Linux, and macOS.
High performance: Kestrel is optimized for low-latency and high-throughput applications.
Lightweight: It has a small memory footprint and minimal overhead.
Concurrency: Kestrel can handle multiple connections and requests efficiently using libuv or the newer I/O APIs available in .NET.
How to configure Kestrel in Program.cs:

public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseKestrel();  // Configures the app to use Kestrel
                webBuilder.UseStartup<Startup>();
            });
}
You can configure Kestrel-specific options like SSL certificates, request limits, and port numbers in the ConfigureWebHostDefaults section.

Example of configuring Kestrel:

webBuilder.UseKestrel(options =>
{
    options.Listen(IPAddress.Loopback, 5001);  // Bind to a specific port
    options.Listen(IPAddress.Loopback, 5002, listenOptions =>
    {
        listenOptions.UseHttps
        ("path-to-certificate.pfx", "password");  // HTTPS configuration
    });
});
In production environments, Kestrel is typically used behind a reverse proxy for better security and scalability.

27. What is the purpose of appsettings.json in ASP.NET Core?
The appsettings.json file is used in ASP.NET Core to store configuration settings in a JSON format. This file is a convenient way to store settings like connection strings, API keys, application behavior, and environment-specific settings. It is a replacement for the web.config file used in previous ASP.NET versions.

Key features of appsettings.json:

Environment-specific configuration: You can have different versions of the settings file, such as appsettings.Development.json or appsettings.Production.json, which override or extend the base configuration.
Hierarchical structure: The settings are organized in a key-value structure, with support for nested sections.
Example of an appsettings.json file:

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Server=myServer;Database=myDB;
    User Id=myUser;Password=myPassword;"
  },
  "AppSettings": {
    "ApiKey": "12345",
    "ApiUrl": "https://api.example.com"
  }
}
Using appsettings.json in code: To access the settings, you inject the IConfiguration interface into your classes.

Example:

public class HomeController : Controller
{
    private readonly IConfiguration _configuration;

    public HomeController(IConfiguration configuration)
    {
        _configuration = configuration;
    }

    public IActionResult Index()
    {
        var apiKey = _configuration["AppSettings:ApiKey"];
        var apiUrl = _configuration["AppSettings:ApiUrl"];
        return View();
    }
}
In this example, the ApiKey and ApiUrl values from appsettings.json are accessed using IConfiguration.

appsettings.json provides a flexible, JSON-based way to manage configurations, and ASP.NET Core automatically loads and binds it to the IConfiguration object.

28. How can you read environment-specific settings from appsettings.{Environment}.json?
ASP.NET Core supports environment-specific configurations through additional configuration files, such as appsettings.Development.json or appsettings.Production.json. These files override the values defined in the default appsettings.json based on the current environment.

The current environment is determined by the ASPNETCORE_ENVIRONMENT environment variable. The common environment names are Development, Staging, and Production.

Steps to read environment-specific settings:

Set the environment variable ASPNETCORE_ENVIRONMENT to "Development", "Staging", or "Production".
Create an appsettings.{Environment}.json file to override or add settings for that specific environment.
Example of environment-specific appsettings.Development.json:

{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft": "Debug"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost;
    Database=myDevDB;User Id=myDevUser;Password=myDevPassword;"
  }
}
In the Startup class, the environment-specific file is automatically loaded and merged with appsettings.json:

Example of setting environment in Program.cs:

public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureAppConfiguration((hostingContext, config) =>
        {
            var env = hostingContext.HostingEnvironment;
            config.AddJsonFile
            ("appsettings.json", optional: true, reloadOnChange: true)
                  .AddJsonFile
                  ($"appsettings.{env.EnvironmentName}.json", 
                  optional: true, reloadOnChange: true);
        })
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseStartup<Startup>();
        });
When the application is running in the Development environment, ASP.NET Core will automatically load appsettings.Development.json in addition to the default appsettings.json.

This mechanism allows you to easily manage settings that change between environments, like database connection strings, API keys, or logging levels.

29. What is ViewComponent in ASP.NET Core, and how is it different from a PartialView?
A ViewComponent in ASP.NET Core is a reusable component that encapsulates rendering logic, similar to a controller action but with the purpose of rendering a specific part of a view. ViewComponents are ideal for building complex UI components that may include their own logic and models, independent of the main page or view model.

Key features of ViewComponent:

It is reusable across multiple views.
It has its own logic and view.
It doesn't participate in the MVC action pipeline but is invoked directly from a view.
It can return HTML, JSON, or other formats.
Differences between ViewComponent and PartialView:

ViewComponent: Contains both rendering logic (C# code) and a view (UI part). It has its own model and can perform complex logic before rendering the view.
PartialView: Is purely a view (UI component) without any logic. It shares the model of the parent view.
Example of a ViewComponent:

Create the ViewComponent class:

public class RecentPostsViewComponent : ViewComponent
{
    private readonly IPostService _postService;

    public RecentPostsViewComponent(IPostService postService)
    {
        _postService = postService;
    }

    public async Task<IViewComponentResult> InvokeAsync(int count)
    {
        var posts = await _postService.GetRecentPostsAsync(count);
        return View(posts);
    }
}
Create the View for the ViewComponent (e.g., Views/Shared/Components/RecentPosts/Default.cshtml):

<ul>
    @foreach (var post in Model)
    {
        <li>@post.Title</li>
    }
</ul>
Invoke the ViewComponent from a View:

@await Component.InvokeAsync("RecentPosts", new { count = 5 })
3.In this example, the RecentPostsViewComponent fetches recent posts and passes them to a view for rendering.

‍30. What are Filters in ASP.NET Core, and how do they work?
Filters in ASP.NET Core are used to execute code before or after certain stages in the request pipeline. They provide a way to inject cross-cutting concerns, such as logging, error handling, or authorization, into your application's action methods.

‍Types of filters in ASP.NET Core:

Authorization Filters: Run before any other filters to verify whether the user is authorized to access the resource.
Resource Filters: Execute before and after model binding.
Action Filters: Run before and after the execution of the action method.
Exception Filters: Handle any exceptions thrown during the processing of the request.
Result Filters: Run before and after the execution of the action result.
Example of an Action Filter:

public class LogActionFilter : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext context)
    {
        // Code that runs before the action method
        Console.WriteLine("Action executing: " + context.ActionDescriptor.DisplayName);
    }

    public override void OnActionExecuted(ActionExecutedContext context)
    {
        // Code that runs after the action method
        Console.WriteLine("Action executed");
    }
}
You can apply this filter globally, on a controller, or on an individual action method.

Applying the filter globally:

public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews(options =>
    {
        options.Filters.Add(new LogActionFilter());
    });
}
Applying the filter to a controller or action:

[LogActionFilter]
public class HomeController : Controller
{
    public IActionResult Index()
    {
        return View();
    }
}
Filters allow you to centralize logic that applies across multiple actions or controllers, making your code more modular and maintainable.

Here are the next five intermediate-level .NET Core interview questions and their detailed answers:

31. What is Dependency Injection (DI) in ASP.NET Core, and how is it implemented?
Dependency Injection (DI) is a design pattern used in ASP.NET Core to decouple the instantiation of classes from their dependencies. This enables better maintainability, testing, and flexibility of the application. DI allows objects to declare their dependencies through constructors, and the DI framework takes care of providing the necessary dependencies.

ASP.NET Core provides built-in support for DI, making it easy to implement throughout the application.

How DI works in ASP.NET Core:

Services (dependencies) are registered in the Startup.cs class, usually inside the ConfigureServices method.

Services can be registered with different lifetimes:

Singleton: One instance is created and shared throughout the application's lifetime.
Scoped: A new instance is created for each HTTP request.
Transient: A new instance is created each time it is requested.
Example of configuring DI in ASP.NET Core:

Registering services in Startup.cs:

public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton<IMySingletonService, MySingletonService>();
    services.AddScoped<IMyScopedService, MyScopedService>();
    services.AddTransient<IMyTransientService, MyTransientService>();
}
1. Injecting services into a controller:

public class HomeController : Controller
{
    private readonly IMySingletonService _singletonService;
    private readonly IMyScopedService _scopedService;
    private readonly IMyTransientService _transientService;

    public HomeController(IMySingletonService singletonService, 
                          IMyScopedService scopedService, 
                          IMyTransientService transientService)
    {
        _singletonService = singletonService;
        _scopedService = scopedService;
        _transientService = transientService;
    }

    public IActionResult Index()
    {
        // Use the injected services
        return View();
    }
}
2. Benefits of Dependency Injection:

Loose coupling: The dependencies are not tightly bound to the classes.
Improved testability: Dependencies can be easily mocked during unit testing.
Better maintainability: It is easier to modify and extend code without changing class implementations.
DI is a core feature of ASP.NET Core, simplifying application architecture and enhancing flexibility.

‍32. What is IServiceProvider, and how is it used in ASP.NET Core?
IServiceProvider is the interface used to resolve services (dependencies) that have been registered in the DI container. It is the core part of ASP.NET Core’s dependency injection mechanism. The IServiceProvider is responsible for providing instances of services when they are requested by controllers, middleware, or other components.

‍How IServiceProvider works:

When services are registered in the ConfigureServices method of Startup.cs, they are stored in the service container.
The IServiceProvider is used by the framework to resolve services from this container.
It can be injected into your classes or used manually when resolving services that are not known at compile time.
Example of manually using IServiceProvider:

public class MyClass
{
    private readonly IServiceProvider _serviceProvider;

    public MyClass(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }

    public void UseService()
    {
        var myService = _serviceProvider.GetService<IMyService>();
        // Use the resolved service
    }
}
In this example, IServiceProvider is injected into the class, and the service IMyService is resolved dynamically at runtime.

Common methods of IServiceProvider:

GetService<TService>(): Returns the requested service if registered, or null if it is not.
GetRequiredService<TService>(): Returns the requested service, but throws an exception if the service is not registered.
In most scenarios, you rely on constructor injection for services, but IServiceProvider is useful when you need dynamic or late-bound service resolution.

33. How does logging work in ASP.NET Core?
ASP.NET Core includes built-in support for logging via the Microsoft.Extensions.Logging library. This system allows you to record log messages of varying severity to various outputs, such as the console, files, or third-party services like Azure or Serilog.

Key features of ASP.NET Core logging:

Log levels: Logging supports different severity levels:

Trace
Debug
Information
Warning
Error
Critical
Logging providers: ASP.NET Core includes several logging providers, such as Console, Debug, EventSource, and EventLog. You can also add third-party providers like Serilog or NLog.

How to configure logging:

In appsettings.json:

{
  "Logging": {
    "LogLevel": {
      "Default": "Warning",
      "Microsoft": "Information",
      "System": "Error"
    }
  }
}
In Startup.cs:

public void Configure
(IApplicationBuilder app, IWebHostEnvironment env, ILogger<Startup> logger)
{
    logger.LogInformation("Application is starting");

    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
        logger.LogDebug("In development mode");
    }
}
In this example, logging levels are defined in appsettings.json, and the ILogger is injected into the Startup.cs class for use.

‍Injecting the ILogger in a controller:

public class HomeController : Controller
{
    private readonly ILogger<HomeController> _logger;

    public HomeController(ILogger<HomeController> logger)
    {
        _logger = logger;
    }

    public IActionResult Index()
    {
        _logger.LogInformation("Home page accessed.");
        return View();
    }
}
Adding third-party logging providers (e.g., Serilog):

public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .UseSerilog((context, configuration) =>
        {
            configuration
                .WriteTo.Console()
                .WriteTo.File("logs/log.txt", rollingInterval: RollingInterval.Day);
        })
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseStartup<Startup>();
        });
Logging in ASP.NET Core is flexible, allowing developers to capture useful information during development and in production for debugging and auditing purposes.

34. What is IConfiguration in ASP.NET Core, and how does it help in managing settings?
IConfiguration is an interface in ASP.NET Core used to access configuration settings from various sources like JSON files, environment variables, command-line arguments, and user secrets. It is part of the Microsoft.Extensions.Configuration namespace and provides a unified way to handle configurations in the application.

Key features of IConfiguration:

Supports hierarchical key-value pairs.
Allows configurations to be loaded from multiple sources and merged.
Supports strongly-typed configuration models.
Common configuration sources:

appsettings.json and environment-specific JSON files (like appsettings.Development.json).
Environment variables.
Command-line arguments.
User secrets (for storing sensitive data during development).
How IConfiguration works:

In Startup.cs, it is injected into the constructor:

public class Startup
{
    private readonly IConfiguration _configuration;

    public Startup(IConfiguration configuration)
    {
        _configuration = configuration;
    }

    public void ConfigureServices(IServiceCollection services)
    {
        var mySetting = _configuration["MySettingKey"];
    }
}
1. Accessing nested settings:

var connectionString = _configuration["ConnectionStrings:DefaultConnection"];
2. Example of binding configuration to a strongly-typed model:

public class MySettings
{
    public string ApiKey { get; set; }
    public string ApiUrl { get; set; }
}

public void ConfigureServices(IServiceCollection services)
{
    services.Configure<MySettings>(_configuration.GetSection("MySettings"));
}
Reading environment variables:

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Server=myServer;Database=myDB;"
  }
}
The IConfiguration interface in ASP.NET Core makes it easy to manage settings in a flexible, environment-friendly way, allowing developers to centralize and configure application settings without hardcoding them.

35. What is the IOptions<T> pattern in ASP.NET Core?
The IOptions<T> pattern in ASP.NET Core is used to access strongly-typed configuration settings. It allows you to bind configuration sections from appsettings.json or other sources directly to C# classes, making it easier to manage and access configuration values throughout the application.

How IOptions<T> works:

**Define a class that represents the configuration
Bind the configuration section to the class using the Configure<T> method.
Access the configuration values through dependency injection.
Example:

Create a settings class:

public class MySettings
{
    public string ApiUrl { get; set; }
    public string ApiKey { get; set; }
}
1.Configure the settings in Startup.cs:

public void ConfigureServices(IServiceCollection services)
{
    services.Configure<MySettings>(_configuration.GetSection("MySettings"));
}
2. Access the settings using IOptions<T> in a controller:

public class HomeController : Controller
{
    private readonly MySettings _mySettings;

    public HomeController(IOptions<MySettings> mySettings)
    {
        _mySettings = mySettings.Value;
    }

    public IActionResult Index()
    {
        var apiUrl = _mySettings.ApiUrl;
        var apiKey = _mySettings.ApiKey;
        return View();
    }
}
IOptionsSnapshot<T> and IOptionsMonitor<T> are advanced variations that allow for runtime updates of configuration settings.The IOptions<T> pattern helps maintain clean and organized code by separating configuration management into its own class, simplifying access to application settings.

‍36. What is Middleware in ASP.NET Core, and how do you create custom Middleware?
‍In ASP.NET Core, Middleware is a component that processes HTTP requests and responses in a pipeline. Each middleware component can:

Handle the request (e.g., authentication, routing).
Pass the request to the next middleware in the pipeline.
Modify the response.
The request flows through the middleware pipeline, and each component can modify the request or response at various stages.How Middleware works:

The middleware pipeline is configured in the Startup.cs file inside the Configure method.
The order in which middleware is added is important because each middleware component can influence the next.
Common built-in middleware includes authentication, routing, static files, and exception handling.
Example of the middleware pipeline:

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseRouting();
    app.UseAuthentication();
    app.UseAuthorization();
    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
    });
}
Creating custom middleware:

To create custom middleware, you can define a class that processes the request and calls the next middleware in the pipeline.

Steps:

Create a middleware class.
Implement a method called InvokeAsync that takes HttpContext and RequestDelegate.
Register the middleware in the pipeline.
Example of custom middleware:

public class CustomMiddleware
{
    private readonly RequestDelegate _next;

    public CustomMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Custom logic before the next middleware
        Console.WriteLine("Before Request");

        // Call the next middleware in the pipeline
        await _next(context);

        // Custom logic after the next middleware
        Console.WriteLine("After Request");
    }
}
Register custom middleware in Startup.cs:

public void Configure(IApplicationBuilder app)
{
    app.UseMiddleware<CustomMiddleware>();
    app.UseRouting();
}
Middleware is a fundamental concept in ASP.NET Core, allowing for modular and reusable components that process HTTP requests.

37. How does session management work in ASP.NET Core?
In ASP.NET Core, session management is used to store temporary data specific to a user across multiple HTTP requests. Unlike cookies, session data is stored server-side, and a session ID is passed to the client via a cookie.

How session management works:

Session data is stored in the server's memory, a distributed cache, or a database.
The session ID is stored in a cookie on the client.
Each time the user makes a request, the session ID is sent with the request, and the server retrieves the corresponding session data.
Configuring session management:

Add the required session services in Startup.cs:

public void ConfigureServices(IServiceCollection services)
{
    services.AddDistributedMemoryCache(); // Required for session
    services.AddSession(options =>
    {
        options.IdleTimeout = TimeSpan.FromMinutes(30);
        options.Cookie.HttpOnly = true;
        options.Cookie.IsEssential = true;
    });
}
1. Use session middleware in the request pipeline:

public void Configure(IApplicationBuilder app)
{
    app.UseSession();
}
2. Store and retrieve session data in a controller:

public IActionResult Index()
{
    HttpContext.Session.SetString("Username", "JohnDoe");
    string username = HttpContext.Session.GetString("Username");

    return View();
}
3. Session storage options:

In-memory (default): Stores session data in memory (useful for development).
Distributed cache: Stores session data in a distributed cache like Redis or SQL Server.
Session management in ASP.NET Core is useful for maintaining user-specific data across multiple requests in a secure and scalable way.

‍38. What is the difference between IApplicationBuilder.Use() and IApplicationBuilder.Run()?
‍Both Use() and Run() are used to add middleware components to the ASP.NET Core middleware pipeline, but they serve different purposes:

IApplicationBuilder.Use():

Adds middleware that can pass the request to the next middleware in the pipeline.
It calls the next middleware by invoking next() within its delegate.
Middleware registered with Use() can modify both the incoming request and outgoing response.
Example of Use():

app.Use(async (context, next) =>
{
    // Logic before the next middleware
    Console.WriteLine("Before next middleware");

    await next(); // Call the next middleware

    // Logic after the next middleware
    Console.WriteLine("After next middleware");
});
IApplicationBuilder.Run():

Terminates the request processing pipeline.
It does not call the next middleware. Once Run() is called, no other middleware is invoked after it.
Typically used for middleware that should handle the request completely (e.g., error handling, static files).
Example of Run():

app.Run(async context =>
{
    await context.Response.WriteAsync("Request handled completely");
});
Key difference:

Use() calls the next middleware in the pipeline, while Run() stops the pipeline from continuing.
You can chain multiple Use() calls, but Run() usually appears last, as it terminates the pipeline.
39. What is UseEndpoints() in ASP.NET Core, and how does it differ from UseMvc()?
‍UseEndpoints() and UseMvc() are methods in ASP.NET Core used to configure request handling, but they differ in how they manage routing and endpoints.

UseMvc():

Part of the older routing system in ASP.NET Core 2.x.
Configures routing based on controller actions, with routes defined explicitly in Startup.cs or using attribute-based routing.
It was commonly used with services.AddMvc() in the ConfigureServices() method.
Example:

public void Configure(IApplicationBuilder app)
{
    app.UseMvc(routes =>
    {
        routes.MapRoute(
            name: "default",
            template: "{controller=Home}/{action=Index}/{id?}");
    });
}
UseEndpoints():

Introduced in ASP.NET Core 3.x as part of the endpoint routing system.
Allows for routing based on different endpoints, such as MVC controllers, Razor pages, gRPC services, and SignalR hubs, in a more unified way.
Typically used with services.AddControllers(), services.AddRazorPages(), etc.
Example:

public void Configure(IApplicationBuilder app)
{
    app.UseRouting();
    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllerRoute(
            name: "default",
            pattern: "{controller=Home}/{action=Index}/{id?}");
        endpoints.MapRazorPages();
    });
}
Key difference:

UseMvc() is tied to the older non-endpoint routing system.
UseEndpoints() is part of the modern endpoint routing system, allowing greater flexibility in how routing is handled for multiple types of requests.
Endpoint routing is the recommended approach in ASP.NET Core 3.x and later, as it simplifies and unifies routing across different types of requests (MVC, Razor Pages, SignalR, etc.).

‍40. How do you implement exception handling in ASP.NET Core?
‍In ASP.NET Core, exception handling can be managed using middleware that catches unhandled exceptions and returns appropriate responses, typically through custom error pages or JSON responses for API endpoints.Key techniques for exception handling:

Developer Exception Page (for development environments):

Shows detailed exception information during development.
Use this only in a development environment.
Example:

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
}
Exception Handling Middleware (for production environments):

Catches exceptions globally and allows you to show custom error pages or responses.
Typically used in production environments.
Example:

public void Configure(IApplicationBuilder app)
{
    app.UseExceptionHandler("/Home/Error"); // Custom error page for exceptions
}
Custom Exception Handling Middleware:

You can create your own middleware to handle exceptions in a more customized way, such as returning JSON for APIs or logging errors.
Example of custom exception handling middleware:

public class CustomExceptionMiddleware
{
    private readonly RequestDelegate _next;

    public CustomExceptionMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            // Handle exception
            context.Response.StatusCode = 500;
            await context.Response.WriteAsync("An error occurred.");
        }
    }
}

// Register the middleware in Startup.cs
public void Configure(IApplicationBuilder app)
{
    app.UseMiddleware<CustomExceptionMiddleware>();
}
Logging exceptions:

ASP.NET Core integrates with logging frameworks to log exceptions in production environments using providers like Serilog, NLog, or the built-in logging system.
By setting up proper exception handling middleware, you can ensure that unhandled exceptions are captured, logged, and returned in a user-friendly way based on the application type (MVC, API, etc.).

.Net Core Interview Questions & Answers For Experienced
1. What is the CQRS (Command Query Responsibility Segregation) pattern, and how do you implement it in .NET Core?
CQRS Pattern: CQRS is a pattern that separates read and write operations into different models. The idea is to allow for optimization of both sides independently, making the system more scalable and maintainable.

Implementation in .NET Core:

Define Commands and Queries: Create separate classes for commands (write operations) and queries (read operations).
Use Command Handlers: Implement command handlers that process the commands. Use the IRequestHandler<TRequest, TResponse> interface from the MediatR library.
Use Query Handlers: Similarly, create query handlers for handling queries.
Set Up Repositories: Use repositories to interact with the database. You can have different databases for reading and writing.
Service Layer: Create a service layer that interacts with command and query handlers.
Example:

public class CreateProductCommand : IRequest<Product>
{
    public string Name { get; set; }
    public decimal Price { get; set; }
}

public class CreateProductCommandHandler : IRequestHandler
<CreateProductCommand, Product>
{
    public async Task<Product> Handle
    (CreateProductCommand request, CancellationToken cancellationToken)
    {
        // Logic to create a product
    }
}

// Query
public class GetProductQuery : IRequest<Product>
{
    public int Id { get; set; }
}

public class GetProductQueryHandler : IRequestHandler
<GetProductQuery, Product>
{
    public async Task<Product> Handle
    (GetProductQuery request, CancellationToken cancellationToken)
    {
        // Logic to get a product by ID
    }
}
2. How do you handle distributed transactions in a microservice architecture using .NET Core?
Handling Distributed Transactions: In microservice architecture, handling distributed transactions can be complex. Here are some approaches:

Two-Phase Commit (2PC): While this is a traditional approach, it can lead to tight coupling between services, making it less favorable.
Saga Pattern: This is a more common approach. It consists of a series of local transactions where each transaction updates a service and publishes an event or message to trigger the next transaction.
Compensating Transactions: If a step fails, the previous steps must be undone, often using compensating transactions.
Eventual Consistency: Accept that not all operations are completed in one transaction. Instead, rely on asynchronous messaging to eventually synchronize states across services.
3. How do you implement the Event Sourcing pattern in .NET Core?
Event Sourcing Pattern: Event sourcing stores the state of a system as a sequence of events. Instead of storing just the current state, you store every change that has occurred.

Implementation Steps:

Define Events: Create event classes that represent the changes in the system.
Event Store: Use an event store to save events. This could be a database or a message queue.
Aggregate Roots: Use aggregate roots to handle the business logic and ensure that all changes are consistent.
Replay Events: To rebuild the current state, replay the events from the event store.
Example:

public class ProductCreatedEvent
{
    public int ProductId { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}

// Store events in a database
public void SaveEvent(Event @event)
{
    // Logic to save the event
}

// Replay events to get the current state
public Product GetProductById(int id)
{
    var events = _eventStore.GetEventsForAggregate(id);
    // Logic to replay events
}
4. Explain the Saga pattern for handling distributed transactions in .NET Core microservices.
Saga Pattern: The Saga pattern is a way to manage distributed transactions by breaking them down into a series of smaller, manageable transactions that can be completed independently. It can be implemented in two ways:

Choreography: Each service produces and listens for events. The services are loosely coupled and can operate independently.
Orchestration: A central orchestrator service directs the flow of the saga, coordinating the various services.
Implementation Steps:

Define the Saga: Identify the sequence of operations that need to be completed.
Implement Choreography: Each service publishes events when it completes its operation, triggering the next service in the saga.
Implement Orchestration: Use a saga orchestrator that manages the flow and calls each service in the correct order.
Compensating Transactions: Define compensating actions for each step in case a step fails.
5. How do you integrate .NET Core with Docker, and what are the benefits?
Integrating .NET Core with Docker:

Dockerfile: Create a Dockerfile in your .NET Core project that defines how to build your application in a Docker container.
Example Dockerfile:

# Use the official .NET SDK image
FROM mcr.microsoft.com/dotnet/sdk:7.0 AS build
WORKDIR /app
COPY . .
RUN dotnet restore
RUN dotnet publish -c Release -o out

# Use the official .NET runtime image
FROM mcr.microsoft.com/dotnet/aspnet:7.0
WORKDIR /app
COPY --from=build /app/out .
ENTRYPOINT ["dotnet", "YourApp.dll"]
Docker Compose: Use Docker Compose to define and run multi-container Docker applications.
Benefits of Using Docker:

Environment Consistency: Ensures that applications run the same way in development, testing, and production.
Isolation: Each service runs in its own container, isolating dependencies and configurations.
Scalability: Easier to scale services independently.
Portability: Docker containers can run on any system that supports Docker, making deployments easier.
‍6. How do you handle logging in microservices using centralized logging in .NET Core?
Centralized Logging: Centralized logging collects logs from various microservices into a single location, facilitating monitoring and analysis.Implementation Steps:

Choose a Logging Framework: Use frameworks like Serilog, NLog, or log4net that support structured logging.
Centralized Log Storage: Use solutions like ELK Stack (Elasticsearch, Logstash, Kibana), Azure Application Insights, or Splunk.
Structured Logging: Log data in a structured format (e.g., JSON) to make querying and analysis easier.
Configure Logging: Update appsettings.json to configure logging.
Example using Serilog:

public class Program
{
    public static void Main(string[] args)
    {
        Log.Logger = new LoggerConfiguration()
            .MinimumLevel.Debug()
            .WriteTo.Console()
            .WriteTo.Elasticsearch(new ElasticsearchSinkOptions(new Uri("http://localhost:9200"))
            {
                AutoRegisterTemplate = true
            })
            .CreateLogger();

        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .UseSerilog() // Using Serilog for logging
            .ConfigureWebHostDefaults(webBuilder => { webBuilder.UseStartup<Startup>(); });
}
7. How do you implement Polly for handling transient faults in .NET Core applications?
Polly Overview: Polly is a resilience library for .NET that helps manage transient faults by implementing policies such as retries, circuit breakers, and timeouts.

Implementation Steps:

Install Polly: Add the Polly NuGet package to your project.
Define Resilience Policies: Create policies for retry, circuit breaker, etc.
Wrap HTTP Calls: Use the defined policies around HTTP calls to external services.
Example of a Retry Policy:

var retryPolicy = Policy
    .Handle<HttpRequestException>()
    .RetryAsync(3); // Retries 3 times

await retryPolicy.ExecuteAsync(async () =>
{
    // Your HTTP call
});
8. How do you integrate gRPC in a .NET Core application for inter-service communication?
gRPC Integration Steps:

Add gRPC Packages: Include Grpc.AspNetCore and Google.Protobuf packages.
Define Protos: Create .proto files to define service methods and messages.
Generate Code: Use the Protobuf compiler to generate C# code from .proto files.
Configure Services in Startup: Register gRPC services in the Startup.cs.
Example Proto File:

// product.proto
syntax = "proto3";

service ProductService {
    rpc GetProduct (ProductRequest) returns (ProductResponse);
}

message ProductRequest {
    int32 id = 1;
}

message ProductResponse {
    string name = 1;
    double price = 2;
}
Startup Configuration:

public void ConfigureServices(IServiceCollection services)
{
    services.AddGrpc(); // Add gRPC services
}

// In the Configure method
app.UseEndpoints(endpoints =>
{
    endpoints.MapGrpcService<ProductService>(); // Map the gRPC service
});
9. What are the best practices for optimizing performance in high-traffic .NET Core applications?
Performance Optimization Best Practices:

Asynchronous Programming: Utilize async/await to prevent blocking threads.
Caching: Implement caching strategies (in-memory, distributed) to reduce repetitive database calls.
Load Balancing: Use load balancers to evenly distribute traffic among instances.
Efficient Database Access: Optimize queries and use appropriate indexing.
Connection Pooling: Use connection pooling for efficient database connections.
Minimize Middleware: Limit the use of middleware to essential components.
Response Compression: Enable gzip compression to reduce the size of responses.
10. How do you implement Circuit Breaker and Retry patterns using Polly in .NET Core?
Circuit Breaker and Retry Patterns: You can create a combined policy using Polly for circuit breaking and retries.

Example Implementation:

var retryPolicy = Policy
    .Handle<HttpRequestException>()
    .RetryAsync(3); // Retry 3 times

var circuitBreakerPolicy = Policy
    .Handle<HttpRequestException>()
    .CircuitBreakerAsync
    (2, TimeSpan.FromMinutes(1)); // Break after 2 failures for 1 minute

var combinedPolicy = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);

await combinedPolicy.ExecuteAsync(async () =>
{
    // Your HTTP call here
});
11. How do you manage caching at scale for distributed applications in .NET Core?
Managing Caching at Scale:

Distributed Caching: Use Redis or Memcached for distributed caching to share data across instances.
Cache Invalidation: Implement strategies for cache invalidation to ensure data consistency.
Partitioning Data: Partition data across multiple cache nodes to balance load.
Expiration Policies: Set appropriate expiration for cached items to manage memory usage efficiently.
Example using Redis:

services.AddStackExchangeRedisCache(options =>
{
    options.Configuration = "localhost:6379";
});
12. How do you deploy a .NET Core application to a Kubernetes cluster?
Deployment Steps:

Create Docker Image: Build a Docker image for your .NET Core application.
Define Kubernetes Configuration Files: Create YAML files for your deployment and service specifications.
Deploy Using kubectl: Use kubectl commands to deploy your application to the Kubernetes cluster.
Example YAML for Deployment and Service:

apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-dotnet-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-dotnet-app
  template:
    metadata:
      labels:
        app: my-dotnet-app
    spec:
      containers:
      - name: my-dotnet-app
        image: my-dotnet-app:latest
        ports:
        - containerPort: 80

---
apiVersion: v1
kind: Service
metadata:
  name: my-dotnet-app
spec:
  selector:
    app: my-dotnet-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: LoadBalancer
13. How do you handle API versioning in an ASP.NET Core Web API?
API Versioning Implementation:

Install API Versioning Package: Add Microsoft.AspNetCore.Mvc.Versioning NuGet package.
Configure Versioning in Startup: Set up API versioning options in Startup.cs.
Example:

services.AddApiVersioning(options =>
{
    options.ReportApiVersions = true;
    options.AssumeDefaultVersionWhenUnspecified = true;
    options.DefaultApiVersion = new ApiVersion(1, 0);
});

// Define versioned controllers
[ApiVersion("1.0")]
[Route("api/v{version:apiVersion}/products")]
public class ProductsV1Controller : ControllerBase
{
    // Actions for version 1.0
}

[ApiVersion("2.0")]
[Route("api/v{version:apiVersion}/products")]
public class ProductsV2Controller : ControllerBase
{
    // Actions for version 2.0
}
14. How do you integrate OAuth2 and OpenID Connect in a .NET Core application?
OAuth2 and OpenID Connect Integration:

Install Required NuGet Packages: Use Microsoft.AspNetCore.Authentication.JwtBearer and Microsoft.AspNetCore.Authentication.OpenIdConnect.
Configure Authentication in Startup: Set up the authentication middleware to validate incoming tokens.
Example:

services.AddAuthentication(options =>
{
    options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.Authority = "https://your-auth-server";
    options.Audience = "your-api-audience";
});

app.UseAuthentication(); // Enable authentication middleware
15. How do you implement hybrid transactions across microservices in .NET Core?
Hybrid Transactions Handling: Hybrid transactions can be complex and may involve several strategies:

Transaction Coordinator: Implement a transaction coordinator to manage transactions across services.
Saga Pattern: Use the Saga pattern to decompose the process into local transactions that can be compensated.
Event-Driven Architecture: Employ events to trigger processes and maintain state across services.
16. How do you secure microservices using JWT and Identity Server in .NET Core?
Microservices Security:

Use Identity Server: Set up Identity Server for authentication and issuing JWT tokens.
JWT Bearer Authentication: Configure your microservices to validate JWT tokens.
Example Configuration:

services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Authority = "https://your-identity-server";
        options.Audience = "your-api-audience";
    });
17. What is GraphQL, and how do you implement it in .NET Core?
GraphQL Overview: GraphQL is a query language for APIs that allows clients to request only the data they need.

Implementation Steps:

Install GraphQL NuGet Packages: Add GraphQL and GraphQL.Server packages.
Define GraphQL Schema: Create a schema that defines types, queries, and mutations.
Configure GraphQL in Startup: Register GraphQL services in Startup.cs.
Example:

services.AddGraphQLServer()
    .AddQueryType<Query>() // Define your Query class
    .AddMutationType<Mutation>(); // Define your Mutation class
18. How do you scale an ASP.NET Core application using Azure Kubernetes Service (AKS)?
Scaling with AKS:

Deploy to AKS: Use Kubernetes to deploy your ASP.NET Core application.
Horizontal Pod Autoscaler: Implement HPA to automatically scale the number of pods based on CPU usage or custom metrics.
Load Balancing: Use Azure Load Balancer to distribute traffic across instances.
Example HPA Configuration:

apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: my-dotnet-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-dotnet-app
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
19. How do you handle message-driven microservices using RabbitMQ in .NET Core?
Message-Driven Microservices:

Install RabbitMQ Client: Add the RabbitMQ.Client NuGet package.
Configure RabbitMQ Connection: Set up a connection to your RabbitMQ server in your application.
Publish and Consume Messages: Use RabbitMQ to publish messages and create consumers for processing them.
Example Publisher:

using (var connection = factory.CreateConnection())
using (var channel = connection.CreateModel())
{
    channel.QueueDeclare
    (queue: "queue_name", durable: false, exclusive: false, autoDelete: false, arguments: null);
    
    var body = Encoding.UTF8.GetBytes("Hello World");
    channel.BasicPublish(exchange: "", routingKey: "queue_name", basicProperties: null, body: body);
}
20. How do you implement distributed tracing in a .NET Core microservice architecture?
Distributed Tracing: Distributed tracing helps track requests across microservices.

Implementation Steps:

Use OpenTelemetry: Integrate OpenTelemetry SDK to capture traces.
Instrumentation: Instrument your application to create spans and add context to traces.
Export Traces: Send traces to a backend like Jaeger, Zipkin, or Azure Monitor for visualization.
Example Configuration:

services.AddOpenTelemetryTracing(builder =>
{
    builder.AddAspNetCoreInstrumentation()
           .AddHttpClientInstrumentation()
           .SetResourceBuilder(ResourceBuilder.CreateDefault().AddService("YourServiceName"))
           .AddJaegerExporter();
});
21. How do you implement zero-downtime deployments for .NET Core applications in production?
Zero-Downtime Deployment Strategies:

Blue-Green Deployment: Maintain two identical environments (blue and green). Deploy the new version to the inactive environment and switch traffic when ready.
Rolling Deployment: Gradually replace instances of the old version with the new version, ensuring that some instances of the old version are always running.
Canary Release: Release the new version to a small subset of users before rolling it out to the entire user base. Monitor performance and rollback if issues arise.
Load Balancer Configuration: Use a load balancer to manage traffic to both versions during the deployment process.
Example Steps:

Use a CI/CD pipeline to automate deployments.
Use Docker for containerization to ensure consistent environments.
Utilize Kubernetes for managing rolling updates and scaling.
22. How do you work with Azure Functions in a .NET Core application?
Working with Azure Functions:

Create a Function App: Use the Azure portal or Azure CLI to create a new Function App.
Choose Trigger Type: Select triggers like HTTP, Timer, or Queue.
Write Function Code: Implement the logic in the function's code file.
Example HTTP Trigger Function:

[FunctionName("HttpTriggerFunction")]
public static async Task<IActionResult> Run(
    [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
    ILogger log)
{
    log.LogInformation("C# HTTP trigger function processed a request.");
    return new OkObjectResult("Hello, Azure Functions!");
}
Deploy and Test: Deploy the function using Azure DevOps or directly from Visual Studio.
23. How do you handle large file uploads and downloads in a .NET Core Web API?
Handling Large Files:

Configure Kestrel Server: Increase limits for request body size in Startup.cs.
Use Streamed File Uploads: Accept file streams to minimize memory usage.
Example Configuration:

services.Configure<KestrelServerOptions>(options =>
{
    options.Limits.MaxRequestBodySize = 10 * 1024 * 1024; // 10 MB
});
File Upload Example:

[HttpPost("upload")]
public async Task<IActionResult> Upload(IFormFile file)
{
    if (file.Length > 0)
    {
        var path = Path.Combine("uploads", file.FileName);
        using (var stream = new FileStream(path, FileMode.Create))
        {
            await file.CopyToAsync(stream);
        }
        return Ok();
    }
    return BadRequest();
}
‍File Download Example:

[HttpGet("download/{fileName}")]
public IActionResult Download(string fileName)
{
    var path = Path.Combine("uploads", fileName);
    var fileStream = new FileStream(path, FileMode.Open);
    return File(fileStream, "application/octet-stream", fileName);
}
24. What are the different strategies for scaling out microservices in .NET Core?
Scaling Strategies:

Horizontal Scaling: Add more instances of microservices to handle increased load.
Load Balancing: Distribute incoming requests evenly across instances using load balancers.
Service Mesh: Use a service mesh like Istio to manage service-to-service communication and traffic routing.
Auto-scaling: Implement auto-scaling policies based on CPU usage, memory, or custom metrics in Kubernetes.
25. How do you optimize SQL queries using Dapper in .NET Core?
Optimizing SQL Queries with Dapper:

Use Parameterized Queries: Prevent SQL injection and improve performance.
Select Only Necessary Fields: Fetch only required columns instead of using SELECT *.
Use Asynchronous Methods: Utilize Dapper's async methods for database calls.
Example Query:

using (var connection = new SqlConnection(connectionString))
{
    var sql = "SELECT Id, Name FROM Products WHERE CategoryId = @CategoryId";
    var products = await connection.QueryAsync<Product>(sql, new { CategoryId = 1 });
}
26. How do you handle concurrency conflicts in a multi-user Entity Framework Core application?
Concurrency Handling:

Optimistic Concurrency: Use a concurrency token (e.g., timestamp) in your model.
Catch DbUpdateConcurrencyException: Handle exceptions when saving changes to resolve conflicts.
Example Model Configuration:

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    
    [Timestamp]
    public byte[] RowVersion { get; set; } // Concurrency token
}
Handling Concurrency Exception:

try
{
    await _context.SaveChangesAsync();
}
catch (DbUpdateConcurrencyException ex)
{
    // Handle conflict (e.g., notify user, reload entity, etc.)
}
27. How do you implement a global exception handler for microservices in .NET Core?
Global Exception Handling:

Middleware: Create custom middleware to handle exceptions globally.
Logging: Log exceptions for monitoring and debugging.
Example Middleware:

public class ExceptionHandlingMiddleware
{
    private readonly RequestDelegate _next;

    public ExceptionHandlingMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task Invoke(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            await HandleExceptionAsync(context, ex);
        }
    }

    private Task HandleExceptionAsync(HttpContext context, Exception ex)
    {
        context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
        return context.Response.WriteAsync("An unexpected error occurred.");
    }
}
Register Middleware in Startup:

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseMiddleware<ExceptionHandlingMiddleware>();
    // Other middleware registrations...
}
28. How do you implement authentication using Active Directory and Azure AD in .NET Core?
Authentication Steps:

Register Application: Register your app in the Azure portal to use Azure AD.
Install NuGet Packages: Add Microsoft.AspNetCore.Authentication.AzureAD.UI for Azure AD authentication.
Configure Authentication in Startup: Set up authentication options in Startup.cs.
Example Configuration:

services.AddAuthentication(AzureADDefaults.AuthenticationScheme)
        .AddAzureAD(options => Configuration.Bind("AzureAd", options));

app.UseAuthentication(); // Enable authentication middleware
29. How do you secure a .NET Core application with HTTPS and certificates?
Securing with HTTPS:

Use Kestrel: Configure Kestrel to use HTTPS with a certificate.
Redirect HTTP to HTTPS: Force HTTPS by redirecting all HTTP traffic.
Example Kestrel Configuration:

public void ConfigureServices(IServiceCollection services)
{
    services.AddHttpsRedirection(options =>
    {
        options.HttpsPort = 443; // Redirect to this port
    });
}

public void Configure(IApplicationBuilder app)
{
    app.UseHttpsRedirection();
    // Other middleware...
}
30. How do you integrate ElasticSearch with .NET Core for full-text search capabilities?
Integrating ElasticSearch:

Install ElasticSearch Client: Use Elasticsearch.Net and NEST packages for .NET Core.
Configure ElasticSearch Connection: Set up connection details in Startup.cs.
Example Configuration:

services.AddSingleton<IElasticClient>
(new ElasticClient(new ConnectionSettings(new Uri("http://localhost:9200"))));
Example Search Query:

var searchResponse = await elasticClient.SearchAsync<Product>(s => s
    .Index("products")
    .Query(q => q
        .Match(m => m
            .Field(f => f.Name)
            .Query("search term")
        )
    )
);
31. How do you implement API Gateway in a microservices architecture with .NET Core?
API Gateway Overview: An API Gateway acts as a single entry point for microservices, handling requests, routing, and aggregation.

Implementation Steps:

Use Ocelot: A popular .NET Core library for building API gateways.
Configure Ocelot: Set up routes and services in ocelot.json.
Example ocelot.json:

{
  "Routes": [
    {
      "DownstreamPathTemplate": "/api/products",
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5001
        }
      ],
      "UpstreamPathTemplate": "/products",
      "UpstreamHttpMethod": [ "GET" ]
    }
  ],
  "GlobalConfiguration": {
    "BaseUrl": "http://localhost:5000"
  }
}
Startup Configuration:

public void ConfigureServices(IServiceCollection services)
{
    services.AddOcelot(); // Add Ocelot services
}

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseRouting();
    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers(); // Map controllers
    });

    app.UseOcelot().Wait(); // Use Ocelot middleware
}
32. What is Orleans, and how do you use it in .NET Core for distributed systems?
Overview of Orleans: Orleans is a framework for building distributed applications, leveraging virtual actors for scalability and fault tolerance.

Implementation Steps:

Install Orleans Packages: Add Microsoft.Orleans.Server and related packages.
Configure Orleans in Startup: Set up Orleans host and configure grain services.
Example Configuration:

services.AddOrleansClient(clientBuilder =>
{
    clientBuilder.UseLocalhostClustering();
});
Example Grain Interface:

public interface IMyGrain : IGrainWithStringKey
{
    Task<string> GetGreeting(string name);
}
Implement Grain:

public class MyGrain : Grain, IMyGrain
{
    public Task<string> GetGreeting(string name)
    {
        return Task.FromResult($"Hello, {name}!");
    }
}
33. How do you implement JWT refresh tokens securely in a .NET Core Web API?
JWT Refresh Tokens:

Generate Refresh Tokens: Issue a refresh token alongside the access token upon authentication.
Store Refresh Tokens: Store them securely (e.g., in a database or a secure store).
Example Token Generation:

var refreshToken = GenerateRefreshToken();
await SaveRefreshTokenToDatabase(user.Id, refreshToken);
Token Refresh Endpoint:

[HttpPost("refresh-token")]
public async Task<IActionResult> RefreshToken(string token)
{
    var principal = ValidateToken(token);
    if (principal == null) return Unauthorized();
    
    var newToken = GenerateAccessToken(principal);
    return Ok(new { AccessToken = newToken });
}
34. How do you optimize memory management and garbage collection in .NET Core for high-performance applications?
Memory Management Optimization:

Use Structs Over Classes: Use value types (structs) for small data structures to reduce heap allocations.
Minimize Allocations: Use object pooling to reuse instances of expensive objects.
Avoid Large Object Heap: Break large objects into smaller ones if possible to avoid fragmentation.
Profiling Tools: Utilize tools like the .NET Memory Profiler or Visual Studio's Diagnostic Tools to analyze memory usage.

35. How do you handle multitenancy in an ASP.NET Core application?
Multitenancy Approaches:

Database-per-Tenant: Each tenant has its own database, offering complete isolation.
Shared Database with Tenant ID: Use a single database and add a Tenant ID column to tables to filter data.
Hybrid Approach: Use a combination of the above methods based on tenant needs.
Example Shared Database Model:

public class Tenant
{
    public int Id { get; set; }
    public string Name { get; set; }
}

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int TenantId { get; set; } // Multitenancy key
}
36. How do you configure load balancing for .NET Core applications running on Kubernetes?
Load Balancing in Kubernetes:

Use Kubernetes Services: Create a service of type LoadBalancer or ClusterIP.
Ingress Controller: Use an Ingress controller to manage external access to services.
Example Service Configuration:

apiVersion: v1
kind: Service
metadata:
  name: my-dotnet-app
spec:
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 5000
  selector:
    app: my-dotnet-app
37. How do you monitor performance and health in a production .NET Core application?
Monitoring Techniques:

Application Insights: Use Azure Application Insights for telemetry, performance metrics, and logging.
Health Checks: Implement health checks using the Microsoft.AspNetCore.Diagnostics.HealthChecks package.
Example Health Check Configuration:

public void ConfigureServices(IServiceCollection services)
{
    services.AddHealthChecks();
}

public void Configure(IApplicationBuilder app)
{
    app.UseHealthChecks("/health");
}
38. How do you implement WebSockets for real-time communication in ASP.NET Core?
Implementing WebSockets:

Add WebSocket Middleware: Configure WebSocket support in Startup.cs.
Create WebSocket Handler: Write logic for handling WebSocket connections.
Example Configuration:

public void Configure(IApplicationBuilder app)
{
    app.UseWebSockets();
    app.Use(async (context, next) =>
    {
        if (context.WebSockets.IsWebSocketRequest)
        {
            using var webSocket = await context.WebSockets.AcceptWebSocketAsync();
            await HandleWebSocketAsync(webSocket);
        }
        else
        {
            await next();
        }
    });
}
WebSocket Handler Example:

private async Task HandleWebSocketAsync(WebSocket webSocket)
{
    var buffer = new byte[1024 * 4];
    WebSocketReceiveResult result;

    do
    {
        result = await webSocket.ReceiveAsync
        (new ArraySegment<byte>(buffer), CancellationToken.None);
        // Handle received messages...
    } while (!result.CloseStatus.HasValue);

    await webSocket.CloseAsync
    (result.CloseStatus.Value, result.CloseStatusDescription, CancellationToken.None);
}
39. How do you integrate message queues like Azure Service Bus in a .NET Core application?
Integrating Azure Service Bus:

Install NuGet Package: Add Microsoft.Azure.ServiceBus.
Configure Service Bus Client: Set up connection strings and queues.
Example Configuration:

var connectionString = "YourConnectionString";
var queueClient = new QueueClient(connectionString, "YourQueueName");
Sending Messages Example:

var message = new Message
(Encoding.UTF8.GetBytes("Hello, Azure Service Bus!"));
await queueClient.SendAsync(message);
Receiving Messages Example:

var messageHandlerOptions = new MessageHandlerOptions
(ExceptionReceivedHandler)
{
    MaxConcurrentCalls = 1,
    AutoComplete = false
};

queueClient.RegisterMessageHandler
(ProcessMessagesAsync, messageHandlerOptions);
40. How do you architect a microservice-based solution using .NET Core for cloud-native applications?
Architecting Microservices:

Identify Microservices: Break down the application into smaller services based on business capabilities.
Design APIs: Define RESTful APIs or use gRPC for communication between services.
Database Strategy: Choose appropriate database strategies (e.g., polyglot persistence).
Infrastructure: Use Docker containers and orchestrate with Kubernetes for deployment.
Monitoring and Logging: Implement centralized logging and monitoring tools for observability.
Example Architecture Diagram: Create an architecture diagram that shows microservices, API gateways, databases, and message queues.

Top 50 .NET Interview Questions and Answers: An Overview

.NET is an ever-evolving framework developed by Microsoft. This powerful open-source development platform has been driving the software industry for years. It supports services, websites, desktop applications, and many more on Windows. In this .NET tutorial, we have tried our best to provide you with some of the top .NET Interview Questions and Answers. We have segregated the questions into .NET interview questions for freshers, intermediate .NET Interview Questions, and .NET Interview Questions for experienced to make it easy to go through the questions.

Basic .NET Interview Questions for Freshers
1. Describe the components of . NET.
 components of .NET.

.NET consists of the following components:

Common Language Runtime(CLR): It is an execution engine that runs the code and provides services that make the development process easier. The programs written for the .NET Framework are executed by the CLR regardless of programming language.
Framework Class Library(FCL): It has pre-defined methods and properties to implement common and complex functions. It will also provide types for dates, strings, numbers, etc. This class library includes APIs for database connection, file reading and writing, drawing, etc.
Base Class Library(BCL): (BCL) has a huge collection of libraries features and functions that help implement various programming languages such as C#, F#, Visual C++, etc., in the .NET Framework.
Common Type System(CTS): It specifies a standard that will mention which type of data and value can be defined and managed in memory during runtime.
Common Language Specification (CLS): CLS will support inter-operability or cross-language integration, which means it provides a common platform for interacting and sharing information.
2. Differentiate managed from unmanaged code
Managed Code	Unmanaged Code
It is managed by CLR.	It is not managed by CLR.
.NET framework is a must for execution.	Does not require a .NET framework for the execution.
Memory management is done through garbage collection.	The runtime environment takes care of memory management.
3. How do you apply themes to ASP.NET applications?
Yes. By modifying the following code in the web.config file, we can apply themes to ASP.NET applications:


<configuration>
   <system.web>
       <pages theme="windows"/>
   </system.web>
</configuration>
4. What is BCL?
What is BCL
BCL is a base class library of classes, interfaces, and value types
It is the foundation of .NET framework applications, components, and controls
Encapsulates a huge number of common functions and makes them easily available for the developers
It provides functionality like threading, input/output, security, diagnostics, resources, globalization, etc.
Also serves the purpose of interaction between the user and the runtime
It also provides namespaces that are used very frequently. for eg: system, system.Activities, etc.
5. Explain the concept of Just-In-Time (JIT) compilation in .NET.
The JIT compiler translates the MSIL code of an assembly to native code and uses the CPU architecture of the target machine to execute a .NET application.
It also stores the resulting native code to be accessible for subsequent calls.
If a code executing on a target machine calls a non-native method, the JIT compiler converts the MSIL of that method into native code.
The JIT compiler also enforces type safety in the runtime environment of the .NET Framework.
It checks for the values that are passed to the parameters of any method.
6. What is an assembly?
An assembly is a file that is automatically generated by the compiler which consists of a collection of types and resources that are built to work together and form a logical unit of functionality. In other words, assembly is a compiled code and logical unit of code. Assemblies are implemented in the form of executable (.exe) or dynamic link library (.dll) files.

7. Describe MVC.
MVC stands for Model View Controller. It is an architecture to build .NET applications. The three main logical components of MVC are the model, the view, and the controller.

Describe MVC

Model: They hold data and its related logic. It handles the object storage and retrieval from the databases for an application. For example: A Controller object will retrieve the employee information from the database.
It manipulates employee data and sends it back to the database or uses it to render the same data.

View: View handles the UI part of an application. They get the information from the models for their display. For example, any employee view will include many components like text boxes, dropdowns, etc.
Controller: They handle the user interactions, figure out the responses for the user input, and also render the final output. For instance, the Employee controller will handle all the interactions and inputs from the Employee View and update the database using the Employee Model.
8. What is a delegate in .NET?
A delegate in .NET is similar to a function pointer in C or C++. Using a delegate allows the programmer to encapsulate a reference to a method inside a delegate object. The delegate object can then be passed to code which can call the referenced method, without having to know at compile time which method will be invoked. In addition, we could use delegates to create custom events within a class.


public delegate void ScholarHatDelegate();

class ScholarHatClass
{
    // custom event
    public event ScholarHatDelegate ScholarHatEvent;
}

ScholarHatClass ScholarHatObj = new ScholarHatClass()
ScholarHatObj.ScholarHatEvent += new ScholarHatDelegate();
9. What is MIME in .NET?
MIME stands for Multipurpose Internet Mail Extensions. It is the extension of the e-mail protocol which lets users use the protocol to exchange files over emails easily.

Servers insert the MIME header at the beginning of the web transmission to denote that it is an MIME transaction. Then the clients use this header to select an appropriate ‘player’ for the type of data that the header indicates. Some of these players are built into the web browser.

10. What are the types of JIT?
 types of JIT
Pre - JIT
Here, complete source code is converted into native code in a single cycle (i.e. compiles the entire code into native code in one stretch)
This is done at the time of application deployment.
In .Net it is called "Ngen.exe"
Econo - JIT
In Econo-JIT compilation, the compiler compiles only those methods that are called at run time.
After the execution of this method, the compiled methods are removed from memory.
Normal - JIT
In Normal-JIT compilation, the compiler compiles only those methods that are called at run time.
After executing this method, compiled methods are stored in a memory cache.
No further calls to compiled methods will execute the methods from the memory cache.
11. What is a garbage collector?
A garbage collector frees the unused code objects in the memory. The memory heap is partitioned into 3 generations:

Generation 0: It holds short-lived objects.
Generation 1: It stores medium-lived objects.
Generation 2: This is for long-lived objects.
Collection of garbage refers to checking for objects in the generations of the managed heap that are no longer being used by the application. It also performs the necessary operations to reclaim their memory. The garbage collector must perform a collection to free some memory space.

During the garbage collection process:

The list of live objects is recognized.
References are updated for the compacted objects.
The memory space occupied by dead objects is recollected. The remaining objects are moved to an older segment.
System.GC.Collect() method is used to perform garbage collection in .NET.

12. What is boxing and unboxing in .NET?
Boxing is the process of converting a value type into a reference type directly. It is implicit.

Unboxing is the process where the reference type is converted back into a value type. It is explicit.

Example

int x = 15;      // a value type
object o = j;     // boxing
int y = (int)o;   // unboxing
13. What is Caching?
Caching means storing data temporarily in the memory so that the application can access the data from the cache instead of looking for its original location. This increases the performance of the application and its speed. System.Runtime.Caching namespace is used for Caching information in .Net.

The following are the three different types of Caching:


Page Caching
Data Caching
Fragment Caching
14. Why C# is important in .NET Development?
C# is the primary language of .NET C#, as a language, can do a lot more. C# benefits from the rich standard library provided by the .NET framework, which includes a wide range of built-in classes and APIs for common programming tasks such as file I/O, networking, data manipulation, cryptography, and XML processing.

15. What is the appSettings section in the web.config file?
We can use the appSettings block in the web.config file, if we want to set the user-defined values for the whole application.


<em>
   <configuration>
       <appSettings>
           <add key= "ConnectionString" value="server=local; pwd=password; database=default"  />
       </appSettings>
   </configuration>
</em>
    
16. What are the types of memories supported in the .NET framework?
Two types of memories are present in .NET. They are:

Stack: Stack is a stored-value type that keeps track of each executing thread and its location. It is used for static memory allocation.
Heap: Heap is a stored reference type that keeps track of more precise objects or data. It is used for dynamic memory allocation.
17. What is manifest in .NET Framework?
Manifest is used to store assembly metadata. It contains all the metadata which are necessary for the following things:

Version of assembly
Security identity
Scope of the assembly
To resolve references to resources and classes
18. Why do we use Response.Output.Write()?
Response.Output.Write() is used to get the formatted output.

19. What is the difference between string and String in .NET?
The Char data type represents a character in .NET. In .NET, the text is stored as a sequential read-only collection of Char data types. There is no null-terminating character at the end of a C# string; therefore a C# string can contain any number of embedded null characters ('\0').

The System.String data type represents a string in .NET. A string class in C# is an object of type System.String. The String class in C# represents a string.

20. Explain the different types of cookies available in ASP.NET.
The following are the two types of cookies in ASP.NET. They are:

Session Cookie: It resides on the client machine for a single session and is valid until the user logs out.
Persistent Cookie: It resides on the user's machine for a period specified for its expiry. It may be an hour, a day, a month, or never.
Intermediate .NET Interview Questions
1. State the differences between .NET Core and Mono
 .NET Core Vs Mono
.NET Core	Mono
.Net Core is the subset of implementation for the .NET framework by Microsoft itself.	Mono is the complete implementation of the .Net Framework for Linux, Android, and iOS by Xamarin.
.NET Core only permits you to build web applications and console applications.	Mono permits you to build different application types available in .NET Framework, including mobile applications, GUI-enabled desktop apps, etc.
.NET Core does not have the built-in capability to be compiled into WebAssembly-compatible packages.	Mono has the built-in capability to be compiled into WebAssembly-compatible packages.
.NET Core is never intended for gaming. You can only develop a text-based adventure or relatively basic browser-based game using .NET Core.	Mono is intended for the development of Games. Games can be developed using the Unity gaming engine that supports Mono.
2. Explain the different parts of an Assembly.
different parts of an Assembly.

The different parts of an assembly are:

Manifest: An assembly manifest consists of complete metadata required to specify version requirements and security identity of an assembly, and also the metadata required for defining the assembly scope and resolving references to classes and resources.
The assembly manifest will be stored in either a standalone PE(Portable Executable) file that holds only assembly manifest information, or in a PE file (a .exe or .dll) with MSIL(Microsoft intermediate language) code.

Type Metadata: Metadata will be automatically generated by the Compilers from the source files and the compiler will embed this metadata within target output files like .exe, .dll, or a .netmodule(in the case of multi-module assembly).
MSIL: Microsoft Intermediate Language(MSIL) is a code that implements the types. It includes instructions to load, store, initialize, and call the methods on objects. Along with this, it also includes instructions for control flow, direct memory access, arithmetic and logical operations, exception handling, etc. This is generated by the compiler using one or more source code files.
Resources: Resources can be a list of related files such as .bmp or .jpg files. These resources are static, which means they do not change during run time. Resources are not executable items.
3. Explain the page life cycle and order of events.
When an ASP.NET page runs, the page goes through a life cycle in which it performs a series of processing steps. These include initialization, instantiating controls, restoring and maintaining state, running event handler code, and rendering.

 page life cycle of ASP.Net

The following are the various stages or events of the ASP.Net page life cycle.

PreInit
Init
InitComplete
OnPreLoad
Load
Control PostBack Event(s)
LoadComplete
OnPreRender
OnSaveStateComplete
Render Method
UnLoad
4. What is the difference between IEnumerable and ICollection?
IEnumerable interface has only a single method - GetEnumerator() and it must return an instance of an object of a class that implements the IEnumerator interface.
ICollection inherits IEnumerable apart from it contains some more methods and IsSynchronized and SyncRoot properties help to make the collection thread-safe. ICollection supports count property too.
5. What are the requirements needed for connection pooling?
There are three main requirements needed for connection pooling:

The presence of an identical connection string for both entities
The existence of multiple processes with the same connection parameters
The presence of similar security protocols and settings
6. What is the role of the Startup class in .NET Core?
The Startup class is a fundamental component of the .NET Core web application architecture. It is responsible for configuring the application and its dependencies.

When the application starts, the Startup class is executed, and it performs the following tasks:

Sets up the environment: The Startup class sets up the hosting environment for the application, such as development, staging, or production. It also loads the configuration settings for the application.
Configures services: The Startup class is responsible for configuring the services that the application needs to function correctly.
7. Write a program to find a number of characters in a string.

using System;
namespace LogicalProgram
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.Write("Enter the string : ");
            string message = Console.ReadLine();

            //Remove the empty spaces from the message
            message = message.Replace(" ", string.Empty);
            
            while (message.Length > 0)
            {
                Console.Write(message[0] + " : ");
                int count = 0;
                for (int j = 0; j < message.Length; j++)
                {
                    if (message[0] == message[j])
                    {
                        count++;
                    }
                }
                Console.WriteLine(count);
                message = message.Replace(message[0].ToString(), string.Empty);
            }

            Console.ReadKey();
        }
    }
}
    
Run Code >>
Output
Enter the string : ScholarHat
S : 1
c : 1
h : 1
o : 1
l : 1
a : 2
r : 1
H : 1
t : 1
8. What are some of the security controls present in ASP.NET?
There are five security controls present in ASP.NET:

<asp: PasswordRecovery>: Used to send an email to a user upon performing a password reset operation
<asp: Login>: Gives the provisions of login controls with ID and password fields for users to login via credentials
<asp: LoginName>: Used to display the name of the user who has logged into the system
<asp: LoginStatus>: Used to denote the authentication flag of the user who has logged in
<asp: LoginView>: Used to provide a variety of views based on themes upon user login
9. What is CoreCLR?
CoreCLR is the run-time execution engine provided by the .NET Core. It consists of a JIT compiler, garbage collector, low-level classes, and primitive data types. .NET Core is a modular implementation of .NET, and can be used as the base stack for large scenario types, ranging from console utilities to web applications in the cloud.


CoreCLR

10. Differentiate .NET Core vs .NET framework.
Features	.NET Core	.NET framework
Compatibility	It works based on the principle of “build once, run anywhere”. It is cross-platform, so it is compatible with different operating systems such as Linux, Windows, and Mac OS.	This framework is compatible with the Windows operating system only. Even though, it was developed for supporting software and applications on all operating systems.
Installation	Since it is cross-platform, it is packaged and installed independently of the OS.	It is installed in the form of a single package for Windows OS.
Application Models	It does not support developing the desktop application and it focuses mainly on the Windows mobile, web, and Windows store.	It is used for developing both desktop and web applications, along with this it also supports Windows Forms and WPF applications.
Performance and Scalability	It provides high performance and scalability.	It is less effective compared to .Net Core in terms of performance as well as scalability of applications.
Support for Micro-Services and REST Services	It supports developing and implementing the micro-services and the user is required to create a REST API for its implementation.	It does not support the microservices’ development and implementation, but it supports REST API services.
Packaging and Shipping	It is shipped as a collection of Nugget packages.	All the libraries that belong to the .Net Framework are packaged and shipped all at once.
Android Development	It is compatible with open-source mobile app platforms like Xamarin, via .NET Standard Library. Developers can make use of tools of Xamarin for configuring the mobile application for particular mobile devices like Android, iOS, and Windows phones.	It does not support the development of mobile applications.
CLI Tools	For all supported platforms, it provides lightweight editors along with command-line tools.	.NET is heavy for CLI(Command Line Interface) and developers usually prefer to work on the lightweight CLI.
Deployment Model	The updated version of the .NET Core gets initiated on one machine at a time, which means it gets updated in new folders/directories in the existing application without affecting it. Thus, we can say that .NET Core has a very good flexible deployment model.	When the updated version is released, it is deployed only on the Internet Information Server at first.
11. What is an inversion of control (IoC)? How is it achieved in .NET?
Inversion of Control (IoC) is a design principle that promotes loose coupling and modularity by inverting the traditional flow of control in software systems. Instead of objects creating and managing their dependencies, IoC delegates the responsibility of creating and managing objects to a container or framework. In .NET, IoC is commonly achieved through frameworks like Dependency Injection (DI) containers, where dependencies are injected into objects by the container, enabling flexible configuration and easier testing.

12. Is ASP.NET different from ASP? If yes, explain how.
Yes, ASP.NET is different from ASP. The following are the main differences:

Microsoft develops ASP.NET to create dynamic web applications while ASP (Active Server Pages) is Microsoft's server-side technology used to create web pages.
ASP.NET is compiled while ASP is interpreted.
ASP uses the technology named ADO while ASP.NET uses ADO.NET.
ASP.NET is completely object-oriented while ASP is partially object-oriented.
13. Write a code to send an email from an ASP.NET application

mail message = new mail();
message.From = "abc@gmail.com";
message.To = "xyz@gmail.com";
message.Subject = "Hello";
message.Body = "ScholarHat";
 
SmtpMail.SmtpServer = "localhost";
SmtpMail.Send(message);
    
14. What are the differences between custom and user control?
Custom Control	User Control
Derives from control	Derives from UserControl
Dynamic Layout	Static Layout
Defines a single-control	Defines a set of con
It has full toolbox support	Cannot be added to the toolbox
Loosely coupled control	Tightly coupled control
15. What are tuples in .Net?
A tuple is a fixed-size collection of elements of either the same or different data types. The user must have to specify the size of a tuple at the time of declaration just like arrays.

Advanced .NET Interview Questions for Experienced
1. What are EXE and DLL?
EXE and DLL are assembly executable modules.

EXE: It is an executable file that runs the application for which it is designed. When we build an application, an exe file is generated. Therefore the assemblies are loaded directly when we run an exe. But an exe file cannot be shared with other applications.
DLL: It stands for dynamic link library that consists of code that needs to be hidden. The code is encapsulated in this library, an application can have many DLLs and can also be shared with other applications.
2. What is GAC?
GAC stands for Global Assembly Cache. Whenever CLR gets installed on the machine, GAC comes as a part of it. GAC specifically stores those assemblies which will be shared by many applications. A Developer tool called Gacutil.exe is used to add any file to GAC.

3. What is the purpose of Generics in .NET?
Generics in .NET provide a powerful way to create classes, structures, interfaces, methods, and delegates that work with any data type. They allow you to define type-safe data structures and algorithms without committing to a specific data type at compile time. Generics are commonly used to create type-safe collections for both reference and value types.

The .NET framework provides an extensive set of interfaces and classes in the System.Collections.Generic namespace for implementing generic collections.


using System;

// We use < > to specify Parameter type
public class GFG<T> {
	
	// private data members
	private T data;
	
	// using properties
	public T value
	{
		
		// using accessors
		get
		{
			return this.data;
		}
		set
		{
			this.data = value;
		}
	}
}

// Driver class
class Test {
	
	// Main method
	static void Main(string[] args)
	{
		
		// instance of string type
		GFG<string> name = new GFG<string>();
		name.value = "GeeksforGeeks";
		
		// instance of float type
		GFG<float> version = new GFG<float>();
		version.value = 5.0F;
		
		// display GeeksforGeeks
		Console.WriteLine(name.value); 
		
		// display 5
		Console.WriteLine(version.value); 
	}
}
    
Run Code >>
Output
ScholarHat
5  
4. Explain Thread.Sleep in .NET
The Thread.Sleep() method blocks the current thread for the specified number of milliseconds. In other words, we can say that it suspends the current thread for a specified time.

One thread cannot call Thread.Sleep on another thread. Thread.Sleep is a static method that always causes the current thread to sleep.

Calling Thread.Sleep with a value of Timeout.Infinite causes a thread to sleep until it is interrupted by another thread that calls the Thread.Interrupt method on the sleeping thread, or until it is terminated by a call to its Thread.Abort method. The following example illustrates both methods of interrupting a sleeping thread.


using System;
using System.Threading;

public class Example
{
   public static void Main()
   {
      // Interrupt a sleeping thread.
      var sleepingThread = new Thread(Example.SleepIndefinitely);
      sleepingThread.Name = "Sleeping";
      sleepingThread.Start();
      Thread.Sleep(2000);
      sleepingThread.Interrupt();

      Thread.Sleep(1000);

      sleepingThread = new Thread(Example.SleepIndefinitely);
      sleepingThread.Name = "Sleeping2";
      sleepingThread.Start();
      Thread.Sleep(2000);
      sleepingThread.Abort();
   }

   private static void SleepIndefinitely()
   {
      Console.WriteLine("Thread '{0}' about to sleep indefinitely.",
                        Thread.CurrentThread.Name);
      try {
         Thread.Sleep(Timeout.Infinite);
      }
      catch (ThreadInterruptedException) {
         Console.WriteLine("Thread '{0}' awoken.",
                           Thread.CurrentThread.Name);
      }
      catch (ThreadAbortException) {
         Console.WriteLine("Thread '{0}' aborted.",
                           Thread.CurrentThread.Name);
      }
      finally
      {
         Console.WriteLine("Thread '{0}' executing finally block.",
                           Thread.CurrentThread.Name);
      }
      Console.WriteLine("Thread '{0} finishing normal execution.",
                        Thread.CurrentThread.Name);
      Console.WriteLine();
   }
}
    
Run Code >>
Output
Thread 'Sleeping' about to sleep indefinitely.
Thread 'Sleeping' awoken.
Thread 'Sleeping' executing finally block.
Thread 'Sleeping finishing normal execution.

Thread 'Sleeping2' about to sleep indefinitely.
Thread 'Sleeping2' aborted.
Thread 'Sleeping2' executing finally block.
5. What is the difference between Function and Stored procedure?
Stored Procedure:

A Stored Procedure is always used to perform a specific task.
It can return zero, one or more values.
It can have both input and output parameters.
Exception handling can be done using a try-catch block.
A function can be called from a Procedure.
Functions:

Functions must return a single value.
It can only have the input parameter.
Exception handling cannot be done using a try-catch block.
A Stored procedure cannot be called from a function.
6. What is Blazor?
Blazor is a new .NET web framework for creating client-side applications using C#/Razor and HTML that runs in the browser with WebAssembly. It can simplify the process of creating a single page application (SPA) and at the same time enables full-stack web development using .NET.

Using .NET for developing Client-side applications has multiple advantages like:

.NET offers a range of API and tools across all platforms that are stable and easy to use.
modern languages such as C# and F# offer a lot of features that make programming easier and interesting for developers.
The availability of one of the best IDEs in the form of Visual Studio provides a great .NET development experience across multiple platforms such as Windows, Linux, and macOS.
.NET provides features such as speed, performance, security, scalability, and reliability in web development that make full-stack development easier.
Read more: What's New in Blazor with .NET 8: A Guide to Blazor 8 New Features

7. What is LINQ?
It is an acronym for Language integrated query which was introduced with Visual Studio 2008. LINQ is a set of features that extend query capabilities to the .NET framework language syntax that allows data manipulation irrespective of the data source. LINQ bridges the gap between the world of objects and the world of data.

8. Differentiate between ExecuteScalar and ExecuteNonQuery
ExecuteScalar	ExecuteNonQuery
Returns the output value	Does not return any value
Used for fetching a single value	Used to execute insert and update statements
Does not return the number of affected rows	Returns the number of affected rows
9. What is an HTTP Handler?
Every request into an ASP.NET application is handled by a specialized component called HTTP handler. It is the most important component for handling ASP.NET application requests.


It uses different handlers to serve different files. The handler for the web page creates the page and control objects, runs your code, and then renders the final HTML.

Following are the default HTTP handlers for ASP.NET:

Page Handler(.aspx): Handles web pages
User Control Handler(.ascx): It handles web user control pages
Web Service Handler(.asmx): Handles web service pages
Trace Handler(trace.axd): It handles trace functionality
10. What is cross-page posting?
Whenever we click on a submit button on a webpage, the data is stored on the same page. But if the data is stored on a different page and linked to the current one, then it is known as a cross-page posting. Cross-page posting is achieved by the POSTBACKURL property.

To get the values that are posted on the page to which the page has been posted, the FindControl method can be used.

11. What is a reflection in .NET? Give its practical applications.
Reflection in .NET allows for introspection of types, methods, properties, and other members at runtime. It provides the ability to examine and manipulate metadata, dynamically invoke methods, and create instances of types. This is done through the System.Reflection namespace.


Type type = typeof(string);
Console.WriteLine("FullName:" + type.FullName);
Console.WriteLine("Namespace:" + type.Namespace);
Console.WriteLine("Is Public:"+ type.IsPublic);
In the above code, we are using reflection to get information about the string type such as its full name, namespace, and whether it's public.

Dynamic Loading: Reflection enables you to load assemblies, types, and resources dynamically at runtime.
Object Creation and Invocation: Reflection allows you to create instances of types dynamically and invoke their methods, properties, and events at runtime.
Introspection and Metadata Inspection: Reflection provides APIs to inspect the metadata of types, such as fields, properties, methods, attributes, and interfaces. This information can be used for various purposes, including code generation, documentation generation, serialization, and data binding.
Serialization and Deserialization: Reflection is used extensively in serialization frameworks like JSON.NET and XML serialization to dynamically inspect and serialize/deserialize object graphs without requiring explicit type information.
Unit Testing and Mocking: Reflection enables frameworks like NUnit and Moq to dynamically discover and execute unit tests and create mock objects based on test attributes and method signatures at runtime.
Aspect-Oriented Programming (AOP): Reflection is used in AOP frameworks like PostSharp and Castle Windsor to apply cross-cutting concerns such as logging, caching, and exception handling dynamically to methods and classes at runtime.
12. How is the status of a DataReader checked in .NET?
The status of a DataReader can be checked easily by using a property called ‘IsClosed.’ It will tell you if the DataReader is closed or opened.

If it is closed, a true value is returned, and if the reader is open, it returns a false value.

13. Explain passport authentication.
During the passport authentication, it first checks the passport authentication cookie, if the cookie is not available the application redirects to the passport sign-on page. The passport service then authenticates the details of the user on the sign-on page and if they are valid, stores them on the client's machine and then redirects the user to the requested page.

14. What is the difference between an abstract class and an interface?
Abstract Class	Interface
Used to declare properties, events, methods, and fields as well.	Fields cannot be declared using interfaces.
Provides the partial implementation of functionalities that must be implemented by inheriting classes.	Used to declare the behavior of an implementing class.
Different kinds of access modifiers like private, public, protected, etc. are supported.	Only a public access modifier is supported.
It can contain static members.	It does not contain static members.
Multiple inheritances cannot be achieved.	Multiple inheritances are achieved.
15. How does managed code execute in the .NET framework?
Four main steps are included in the execution of the managed code. They are:

Choosing a compiler that can execute the code written by a user
Conversion of the code into Intermediate Language (IL) using a compiler
IL gets pushed to CLR, which converts it into native code using JIT
Native code is now executed using the .NET runtime

 .NET Interview Questions
1. What is the .NET Framework, and how does it work?
Question Explanation:
Understanding the .NET Framework is foundational for any .NET developer. The framework provides the necessary runtime and libraries for building a wide range of applications, including desktop, web, and mobile. This .NET Interview question assesses a candidate’s basic knowledge of the platform.

Expected Answer:
The .NET Framework is a software development platform developed by Microsoft. It provides a large class library called the Framework Class Library (FCL) and a runtime environment called the Common Language Runtime (CLR). The CLR manages the execution of applications, including memory management, type safety, exception handling, and security.

The .NET Framework supports multiple programming languages (such as C#, VB.NET, and F#), allowing developers to choose a language based on the application’s requirements. Code written in .NET languages is compiled into an Intermediate Language (IL), which is then converted into machine code by the Just-In-Time (JIT) compiler at runtime.

The .NET Framework includes libraries for building web applications (ASP.NET), desktop applications (Windows Forms, WPF), and even communication services (WCF). It provides an integrated environment that handles much of the complexity behind cross-platform communication and resource management.

Evaluating Responses:
Look for a clear explanation of the two main components—CLR and FCL. The candidate should demonstrate a basic understanding of how the .NET Framework provides the runtime and libraries necessary for application development. An ideal answer would also mention the support for multiple languages and the JIT compilation process.

2. Explain the difference between .NET Core and the .NET Framework.
Question Explanation:
This .NET Interview question is critical for assessing whether the candidate understands the evolution of the .NET platform and the advantages of .NET Core, particularly in cross-platform development and performance improvements.

Expected Answer:
The .NET Framework is the original, Windows-only version of .NET, designed for building and running applications on the Windows operating system. It is a mature and feature-rich platform but is limited to Windows environments and has a monolithic architecture.

.NET Core, on the other hand, is a cross-platform, open-source framework that was introduced as a more modern, lightweight, and flexible alternative. It can run on Windows, macOS, and Linux, making it ideal for building applications that need to be deployed across multiple operating systems.

.NET Core also offers better performance optimizations, a modular architecture (allowing developers to include only the necessary libraries), and is designed to work well with cloud-native applications. As of .NET 5, Microsoft has unified the two frameworks into one under the name “.NET” (sometimes referred to as .NET 5 and above), with .NET Core being the foundation for this new platform.

Evaluating Responses:
The candidate should clearly differentiate between the Windows-only limitation of the .NET Framework and the cross-platform capabilities of .NET Core. They should mention key improvements in performance, modularity, and flexibility, and reference the unification of the frameworks starting with .NET 5. Ideally, they would mention scenarios where .NET Core is preferable.

3. What is the Common Language Runtime (CLR) in .NET, and why is it important?
Question Explanation:
The CLR is the execution engine of .NET applications, responsible for many key aspects of runtime behavior. This .NET Interview question helps gauge the candidate’s knowledge of how .NET manages code execution, memory, and other system resources.

Expected Answer:
The Common Language Runtime (CLR) is the virtual machine component of the .NET Framework and .NET Core that manages the execution of .NET programs. It handles several critical functions, including memory management (via garbage collection), exception handling, security (such as code access security), and the execution of the intermediate language (IL) code.

The CLR provides a layer of abstraction between the program and the underlying hardware, ensuring that .NET applications can run on any platform where the CLR is implemented. This allows developers to write code in multiple programming languages (C#, VB.NET, F#) that is ultimately compiled into a common IL format. The CLR then converts the IL code into machine code at runtime using a Just-In-Time (JIT) compiler.

The CLR’s garbage collection process automatically manages memory allocation and deallocation, reducing the risk of memory leaks and improving application stability.

Evaluating Responses:
A strong answer will describe the CLR as the heart of the .NET runtime environment, emphasizing its role in managing memory, handling exceptions, and providing security. The candidate should mention that the CLR enables language interoperability and the execution of IL code via the JIT compiler. Look for a clear understanding of how the CLR abstracts the hardware.

4. What are assemblies in .NET, and how are they used?
Question Explanation:
Assemblies are the building blocks of .NET applications, and understanding their structure and purpose is crucial for application deployment, versioning, and modularization. This .NET Interview question tests a candidate’s knowledge of how .NET applications are packaged and executed.

Expected Answer:
In .NET, an assembly is a compiled code library used for deployment, versioning, and security. Assemblies are either executable (.exe) or library (.dll) files that contain Intermediate Language (IL) code, metadata about the types, and resources used in the application.

There are two types of assemblies:

Private assemblies are used by a single application and are stored in the application’s directory.
Shared assemblies are intended for use by multiple applications and are stored in the Global Assembly Cache (GAC).
Assemblies also include a manifest that provides information such as the assembly’s version, culture, and public key token (for strong-named assemblies). This manifest is crucial for managing dependencies and versioning, ensuring that the correct version of an assembly is loaded at runtime.

Assemblies allow developers to modularize code, making it easier to maintain and update. Additionally, the assembly’s metadata supports reflection, enabling .NET to inspect types at runtime.

Evaluating Responses:
The candidate should describe assemblies as the fundamental units of deployment and version control in .NET. Look for an explanation of the differences between private and shared assemblies and an understanding of the role of the assembly manifest. The candidate should also highlight the importance of assemblies for modularizing code and managing dependencies.

5. Can you explain the concept of garbage collection in .NET?
Question Explanation:
Garbage collection (GC) is a crucial feature of .NET for automatic memory management. Understanding how it works can help candidates write efficient, memory-safe applications. This .NET Interview question assesses the candidate’s understanding of memory allocation, deallocation, and the inner workings of garbage collection.

Expected Answer:
In .NET, garbage collection (GC) is the process by which the runtime automatically manages the allocation and release of memory. When an object is no longer referenced by the application, the GC reclaims the memory it occupied, reducing the risk of memory leaks and eliminating the need for manual memory management (such as free() or delete in other languages).

The .NET garbage collector works in a generational model. There are three generations:

Generation 0: Contains short-lived objects, such as temporary variables. GC runs frequently here.
Generation 1: Used for objects that survive Generation 0 collections but are not long-lived.
Generation 2: Used for long-lived objects, like static fields or objects that remain in memory for an application’s lifetime.
The GC operates in a non-deterministic manner, meaning it decides when to run based on the system’s memory pressure. It operates through a process called mark and sweep, where it first marks all objects that are still in use and then sweeps (reclaims) the memory used by unreferenced objects.

Garbage collection is also optimized for performance, with techniques like compacting memory to reduce fragmentation and concurrent garbage collection that minimizes application pause times.

Evaluating Responses:
The candidate should explain the role of GC in automatic memory management and describe the generational model (Generations 0, 1, and 2). Look for a mention of how garbage collection operates (e.g., mark-and-sweep), the non-deterministic nature of GC, and how it helps avoid memory leaks and fragmentation. Bonus points for an understanding of GC performance optimizations.

6. What are generics in .NET, and why would you use them?
Question Explanation:
Generics enable code reuse and type safety by allowing you to write type-agnostic methods, classes, and interfaces. This .NET Interview question checks whether the candidate understands the advantages of generics and how to apply them in real-world scenarios.

Expected Answer:
Generics in .NET allow developers to define classes, methods, and interfaces with placeholders for data types. Instead of writing multiple versions of the same code for different types, generics allow the creation of type-agnostic code that can work with any specified data type while ensuring type safety at compile time.

For example, a generic List class, List<T>, can store any type of object (e.g., integers, strings, or custom objects), and you don’t have to define separate versions for each type:

List<int> intList = new List<int>();
List<string> stringList = new List<string>();
Generics provide several benefits:

Type safety: Errors related to type mismatches are caught at compile time, which reduces runtime errors.
Code reuse: Generic methods and classes can be reused with different types without the need for duplication.
Performance: Unlike System.Object boxing and unboxing, generics avoid unnecessary type casting, improving performance.
Generics are used in various .NET framework classes, such as List<T>, Dictionary<TKey, TValue>, and Func<T, TResult>. They also play a crucial role in the LINQ framework.

Evaluating Responses:
Look for an understanding of how generics allow for reusable, type-safe code. The candidate should mention type safety, performance improvements (compared to object-based collections), and code reuse. Bonus points if they give examples of generic classes like List<T> or Dictionary<TKey, TValue>. They should also show practical knowledge of how generics reduce the need for casting.

7. How does dependency injection work in .NET, and why is it useful?
Question Explanation:
Dependency Injection (DI) is a key design pattern in modern .NET development, used for decoupling components and improving testability and maintainability. This .NET Interview question assesses the candidate’s understanding of DI and its benefits.

Expected Answer:
Dependency Injection (DI) in .NET is a design pattern used to achieve Inversion of Control (IoC) by injecting dependencies into a class, rather than having the class instantiate them itself. This helps in decoupling components, making code easier to maintain, test, and extend.

With DI, objects receive their dependencies through:

Constructor injection: Dependencies are passed in via the constructor.
Property injection: Dependencies are set through public properties.
Method injection: Dependencies are passed as method parameters.
In .NET Core and later versions, a built-in Dependency Injection container is provided out-of-the-box. You register dependencies in the Startup.cs file or Program.cs (in .NET 6 and beyond) using services such as:

services.AddScoped<IMyService, MyService>();
The DI container manages the lifecycle of the services (e.g., singleton, scoped, transient), ensuring that dependencies are automatically provided to the consuming classes when needed.

DI improves the testability of code because dependencies can easily be replaced with mocks or stubs during unit testing. It also enhances modularity, as classes don’t need to be concerned with creating their own dependencies, reducing tight coupling.

Evaluating Responses:
The candidate should demonstrate a clear understanding of DI’s role in decoupling dependencies and promoting IoC. They should explain constructor, property, and method injection, and mention that DI is built into .NET Core. The candidate should highlight the benefits, including improved testability, modularity, and maintainability. Code examples for registering services in the DI container are a plus.

8. Explain the difference between task-based asynchronous programming and thread-based programming in .NET.
Question Explanation:
This .NET Interview question checks whether the candidate understands modern concurrency patterns in .NET and when to use task-based asynchronous programming over traditional thread-based approaches. It helps assess knowledge of performance optimization and scalability.

Expected Answer:
In .NET, task-based asynchronous programming (introduced with async and await in .NET 4.5) is a high-level abstraction for managing asynchronous operations. It simplifies writing asynchronous code by allowing you to work with tasks rather than manually creating and managing threads. Tasks represent operations that can run asynchronously and return a value in the future (Task<T>) or just complete (Task).

Thread-based programming, on the other hand, requires manual creation and management of threads using classes like Thread or ThreadPool. While threads allow for concurrency, manually handling them can lead to complex code, difficulties in managing shared resources, and performance bottlenecks, especially when scaling.

In task-based programming:

The async keyword is used to mark methods as asynchronous.
The await keyword pauses the execution of the method until the awaited task completes without blocking the thread.
It uses the Task class to represent the asynchronous operation.
Task-based programming provides better scalability because the runtime manages threads efficiently behind the scenes. The Task object is non-blocking, allowing the system to continue executing other code while waiting for I/O-bound or long-running tasks to complete.

Thread-based programming, while useful in CPU-bound scenarios, can be overkill for I/O-bound tasks where task-based async patterns are more efficient.

Evaluating Responses:
Look for an understanding of the difference between Task and Thread objects, and when each is appropriate. The candidate should explain the async and await keywords and how task-based async programming improves scalability by efficiently managing threads. Bonus points if they describe scenarios where thread-based programming is still necessary, such as for CPU-bound tasks. They should also touch on how Task provides better abstraction and simplifies error handling.

9. How does the Model-View-Controller (MVC) pattern work in ASP.NET?
Question Explanation:
The Model-View-Controller (MVC) pattern is a popular architectural design used in web development. This .NET Interview question evaluates the candidate’s understanding of how the MVC pattern separates concerns in ASP.NET applications and enhances maintainability and testability.

Expected Answer:
The Model-View-Controller (MVC) pattern is a software design pattern that divides an application into three interconnected components:

Model: Represents the data and the business logic of the application. It directly manages the data and responds to requests for information or updates (e.g., through a database).
View: Represents the user interface. The view displays the model’s data to the user, and it can be updated when the model changes. In ASP.NET, views are typically implemented using Razor templates.
Controller: Manages user input and interactions. It handles requests from the user, processes them (often by interacting with the model), and returns the appropriate view.
In ASP.NET MVC, a typical request flows as follows:

The user interacts with the UI by submitting a request (e.g., clicking a button or entering a URL).
The controller receives the request, processes it, and interacts with the model to fetch or manipulate data.
The controller then passes the data to the view, which formats it and renders the final response back to the user.
Here’s a basic example of a controller method in ASP.NET MVC:

public class HomeController : Controller
{
    public IActionResult Index()
    {
        var model = new ProductModel(); // Interacts with the model
        return View(model);  // Passes the model to the view
    }
}
ASP.NET MVC promotes separation of concerns, making applications easier to maintain, test, and scale. The decoupling of the components also improves the testability of individual units (e.g., controllers can be unit-tested in isolation from the views or models).

Evaluating Responses:
Look for an explanation of the separation of concerns between models, views, and controllers. The candidate should describe how the MVC pattern improves maintainability and testability, especially in web applications. Bonus points if they mention the flow of a request in ASP.NET MVC and provide an example of a controller action. The answer should highlight the benefits of this architecture, such as ease of testing and modularity.

10. What are delegates in .NET, and how are they used?
Question Explanation:
Delegates are a key concept in .NET used for defining callback methods and events. This .NET Interview question tests the candidate’s understanding of delegates and their practical use cases, such as event handling and anonymous methods.

Expected Answer:
A delegate in .NET is a type that defines a method signature and can hold a reference to any method with a matching signature. In other words, a delegate is a type-safe function pointer. Delegates are primarily used to pass methods as arguments to other methods, enabling callback functionality.

Here’s an example of how to declare and use a delegate:

// Declaring a delegate
public delegate void Notify(string message);

// Method that matches the delegate signature
public void ShowMessage(string message)
{
    Console.WriteLine(message);
}

// Using the delegate
Notify notifyDelegate = ShowMessage;
notifyDelegate("Hello, World!");  // Outputs: Hello, World!
Delegates are commonly used for:

Event handling: Delegates form the basis of the event system in .NET. When an event is raised, the associated delegate invokes the subscribed methods.
public event EventHandler OnClick;
Anonymous methods and Lambda expressions: Delegates can be used with anonymous methods and lambda expressions to simplify code.
Notify notifyDelegate = message => Console.WriteLine(message);
notifyDelegate("Hello with Lambda!");  // Outputs: Hello with Lambda!
There are three types of delegates in .NET:

Single-cast delegates: Point to a single method.
Multicast delegates: Can point to multiple methods and invoke them sequentially.
Generic delegates: These include Func, Action, and Predicate delegates that are predefined for commonly used signatures.
Evaluating Responses:
The candidate should explain that delegates are type-safe function pointers and discuss their primary use cases (e.g., callbacks, event handling, anonymous methods). Look for a code example and mention of the different types of delegates (single-cast, multicast, generic). A strong answer will mention how delegates are used in event handling and anonymous methods.

11. Explain how exception handling works in .NET.
Question Explanation:
Exception handling is crucial for writing robust, fault-tolerant applications. This .NET Interview question assesses the candidate’s knowledge of .NET’s exception handling mechanisms, including the try, catch, finally, and throw keywords.

Expected Answer:
In .NET, exceptions are used to signal errors or unexpected behavior during program execution. Exception handling is done using the try, catch, finally, and throw keywords, allowing developers to gracefully handle errors and prevent application crashes.

try block: Contains code that might throw an exception.
catch block: Catches and handles specific exceptions. Multiple catch blocks can be used to handle different types of exceptions.
finally block: Always executes, whether an exception occurs or not. It’s typically used for cleaning up resources, like closing files or database connections.
throw statement: Re-throws an exception, either from a catch block or by explicitly throwing a new exception.
Here’s an example of basic exception handling:

try
{
    int result = 10 / 0;  // This will throw a DivideByZeroException
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("Cannot divide by zero.");
}
finally
{
    Console.WriteLine("Execution completed.");
}
In addition to these core concepts, .NET has a base class called System.Exception from which all exceptions inherit. Common exception types include:

ArgumentException
NullReferenceException
InvalidOperationException
Developers can also define custom exceptions by inheriting from the Exception class, allowing for more specific error handling scenarios.

Evaluating Responses:
The candidate should explain the roles of try, catch, finally, and throw in .NET’s exception handling model. Look for examples of how exceptions are handled and information on common exception types (e.g., ArgumentException, DivideByZeroException). A good answer should mention the base Exception class and custom exceptions. Bonus points if they include when to re-throw exceptions or handle them at a higher level.

12. What are LINQ and Lambda expressions, and how do they improve code readability in .NET?
Question Explanation:
Language-Integrated Query (LINQ) and Lambda expressions are powerful features in .NET that simplify data manipulation and querying. This .NET Interview question evaluates the candidate’s understanding of how LINQ and Lambdas improve code expressiveness and readability.

Expected Answer:
LINQ (Language-Integrated Query) is a feature in .NET that provides a consistent way to query various data sources (e.g., collections, databases, XML) using SQL-like syntax directly in C#. LINQ allows for filtering, ordering, grouping, and transforming data in a clean and readable manner.

Here’s a simple example of using LINQ with a collection:

List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };
var evenNumbers = numbers.Where(n => n % 2 == 0).ToList();
Lambda expressions are anonymous functions that are commonly used in LINQ queries to define inline expressions. For example, in the Where clause above, n => n % 2 == 0 is a lambda expression that checks if a number is even.

Lambda expressions improve code readability by providing a concise way to write small functions without needing to define separate methods. They often replace more verbose anonymous methods and provide a cleaner, functional programming approach in C#.

For example, the following query filters a list of products and orders them by price:

var filteredProducts = products
    .Where(p => p.Price > 50)
    .OrderBy(p => p.Price)
    .ToList();
LINQ is highly readable, reduces boilerplate code, and makes it easier to work with collections and databases. It improves productivity by allowing developers to write queries in a more declarative style, focusing on what needs to be done rather than how to do it.

Evaluating Responses:
The candidate should clearly explain the role of LINQ in querying data and how it works with collections and other data sources. They should mention lambda expressions and how they simplify code readability. Look for examples that illustrate filtering and ordering data, and highlight how LINQ provides a more declarative and expressive way to work with data in C#. Bonus points for mentioning different types of LINQ queries (e.g., LINQ to Objects, LINQ to SQL).

13. How would you handle state management in an ASP.NET application?
Question Explanation:
State management is crucial in web applications, as HTTP is a stateless protocol. This .NET Interview question tests a candidate’s understanding of how to manage user data across requests in ASP.NET, including the use of client-side and server-side state management techniques.

Expected Answer:
In ASP.NET, state management is essential because HTTP does not retain information about the state of each request. There are several techniques to manage state, and they are categorized into client-side and server-side state management.

Client-side State Management:

Cookies: Small pieces of data stored on the client’s browser. Cookies can persist across sessions but are limited in size and should not store sensitive information.
Response.Cookies["UserName"].Value = "JohnDoe";
Response.Cookies["UserName"].Expires = DateTime.Now.AddDays(1);
Query Strings: Data passed in the URL, often used to transfer small amounts of information between pages.
Response.Redirect("NextPage.aspx?UserID=123");
Local and Session Storage (in modern browsers): Useful for storing data on the client-side with different lifetimes (session storage for a single session, local storage for persistence).
Hidden Fields: Data stored in a form and sent back to the server during postbacks. This is useful for maintaining information without relying on the URL or cookies.
<input type="hidden" name="UserId" value="123" />
Server-side State Management:

Session State: Stores data per user session on the server, available across multiple pages. Sessions are typically backed by in-memory storage or external providers like Redis for distributed systems.
Session["UserName"] = "JohnDoe";
Application State: Stores data that is shared across all users of the application. It’s suitable for data that does not change often (e.g., application-wide settings).
Application["TotalUsers"] = 100;
ViewState (specific to WebForms): Preserves page-specific state between postbacks by storing the data in a hidden field on the page. This approach can add to the page’s payload, so it should be used judiciously.
ViewState["UserName"] = "JohnDoe";
In modern ASP.NET Core, Session and Cookies are more commonly used for state management, while TempData and ViewData also assist in transferring data between actions. Managing state correctly is crucial to ensure scalability, performance, and security in web applications.

Evaluating Responses:
Look for a clear understanding of both client-side and server-side state management techniques. The candidate should mention cookies, query strings, and local storage on the client-side, and session and application state on the server-side. They should also discuss when and why to use each method, focusing on performance, scalability, and security. Bonus points if they explain session management in ASP.NET Core and discuss state persistence across load-balanced servers.

14. What is Entity Framework, and how is it used for database management in .NET applications?
Question Explanation:
Entity Framework (EF) is the most commonly used Object-Relational Mapping (ORM) tool in .NET. This .NET Interview question evaluates a candidate’s understanding of EF and its role in simplifying database operations within .NET applications.

Expected Answer:
Entity Framework (EF) is an ORM framework for .NET that allows developers to interact with databases using strongly-typed C# objects, eliminating the need to write most SQL queries manually. EF maps database tables to .NET classes, with each row corresponding to an object instance and each column corresponding to a class property.

There are two main approaches in EF:

Code-First: Developers define the database schema through C# classes, and EF generates the corresponding database tables. Migrations are used to evolve the database schema over time.
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}
The DbContext class in EF acts as the bridge between the database and the domain classes:

public class AppDbContext : DbContext
{
    public DbSet<Product> Products { get; set; }
}
Database-First: EF generates C# classes based on an existing database schema. This is useful when working with legacy databases.
EF simplifies common database operations, such as querying and updating data:

Querying data:
var products = dbContext.Products.Where(p => p.Price > 50).ToList();
Inserting data:
dbContext.Products.Add(new Product { Name = "Laptop", Price = 1000 });
dbContext.SaveChanges();
Updating data:
var product = dbContext.Products.First(p => p.Id == 1);
product.Price = 900;
dbContext.SaveChanges();
EF is highly flexible, offering support for complex relationships (e.g., one-to-many, many-to-many) and handling lazy, eager, and explicit loading of related data.

Evaluating Responses:
The candidate should explain that EF is an ORM that maps database tables to C# classes and makes it easier to interact with databases. Look for an explanation of code-first and database-first approaches, as well as examples of querying, inserting, and updating data using DbContext. They should highlight how EF eliminates much of the manual SQL required in database interactions, and discuss how it supports different loading strategies and relationships. Bonus points for mentioning performance considerations (e.g., lazy loading, eager loading).

15. How do you ensure performance optimization in .NET applications?
Question Explanation:
Optimizing performance is a key concern for any developer working on .NET applications. This .NET Interview question tests the candidate’s knowledge of performance bottlenecks and how to mitigate them in a .NET environment.

Expected Answer:
Performance optimization in .NET applications requires attention to several key areas, including memory management, efficient data access, and overall application architecture. Some common strategies include:

Memory Management:
Avoid memory leaks by ensuring objects that are no longer needed are properly disposed of, especially when working with unmanaged resources (use IDisposable and the using statement).
Monitor and optimize garbage collection by reducing the number of long-lived objects, which can prevent excessive GC overhead.
Efficient Data Access:
Minimize database queries and reduce over-fetching by using projections in Entity Framework, like selecting only the columns needed:
var users = dbContext.Users.Select(u => new { u.Name, u.Email }).ToList();
Use asynchronous database access (e.g., async/await with EF) to avoid blocking threads:
var result = await dbContext.Products.ToListAsync();
Caching:
Implement caching strategies using MemoryCache, Redis, or Output Caching to store frequently accessed data and reduce expensive database calls.
var cacheKey = "ProductCache";
var products = memoryCache.GetOrCreate(cacheKey, entry => {
    entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5);
    return dbContext.Products.ToList();
});
Asynchronous Programming:
Use asynchronous programming (async/await) to improve the responsiveness of I/O-bound operations, ensuring that CPU cycles are not wasted while waiting for external resources like databases or web services.
Optimizing .NET Code:
Optimize LINQ queries to avoid excessive or inefficient operations (e.g., avoid ToList() in loops).
Use StringBuilder for string concatenation in performance-critical sections instead of + for better memory management.
Avoid boxing/unboxing by using generics instead of working with object.
Profiling and Monitoring:
Use profiling tools like dotTrace, PerfView, or the Visual Studio Profiler to identify bottlenecks in the application.
Monitor application performance in production using tools like Application Insights or ELMAH to catch performance issues in real-time.
Evaluating Responses:
Look for an understanding of various optimization techniques, including memory management, database optimization (e.g., reducing queries, projections), and efficient use of caching. The candidate should mention asynchronous programming as a way to handle I/O-bound operations effectively. Bonus points for discussing profiling and monitoring tools to detect bottlenecks in both development and production environments.

.NET Interview Questions Conclusion
These .NET Interview questions are designed to thoroughly assess a candidate’s knowledge of the .NET framework, focusing on both theoretical understanding and practical application. Using this set of questions, you can identify .NET engineers with the right skill set to develop high-quality software solutions tailored to your organization’s needs.

Beginner .NET Interview Questions
#1. What is .NET, and how does it work?
.NET is a cross-platform framework developed by Microsoft for building web, desktop, mobile, and cloud applications. It supports multiple programming languages, including C#, F#, and VB.NET, and provides a managed runtime environment for executing applications.

Instead of compiling code directly into machine instructions, .NET applications first compile into Common Intermediate Language (CIL). The Common Language Runtime (CLR) then translates CIL into machine code at runtime, allowing cross-platform execution.

Key components of .NET include:

CLR (Common Language Runtime) – Executes .NET applications and manages memory, security, and performance

Base Class Library (BCL) – A collection of reusable libraries for file handling, collections, and more

JIT (Just-In-Time) Compiler – Converts CIL into optimized machine code at runtime

Why do interviewers ask this?

Interviewers want to see if you understand the architecture of .NET, how it differs from traditional compiled languages, and how the CLR enables cross-platform execution.

#2. What is the CLR, and why is it important?
The Common Language Runtime (CLR) is the execution environment for .NET applications. It provides automatic memory management, security, and performance optimizations, making applications more reliable and efficient.

How it works:

Code written in C# or another .NET language compiles into Common Intermediate Language (CIL)

The Just-In-Time (JIT) compiler translates CIL into machine code at runtime

The Garbage Collector (GC) automatically manages memory by reclaiming unused objects

The CLR enforces security policies and prevents unauthorized memory access

Why do interviewers ask this?

Since the CLR is the core of the .NET runtime, interviewers want to see if you understand how .NET applications execute and how features like JIT compilation and garbage collection improve performance.

#3. What are the differences between .NET Framework, .NET Core, and .NET 5+?
.NET has evolved from a Windows-only framework to a modern, cross-platform ecosystem. Each version has different capabilities and use cases.

Key differences:

.NET Framework – Windows-only, supports WinForms, WPF, and older ASP.NET Web Forms. Still used in enterprise applications but no longer receives major updates

.NET Core – The first cross-platform version, optimized for cloud and high-performance applications. Supports Docker, Kubernetes, and microservices

.NET 5+ – Replaces .NET Core, unifying desktop, mobile, cloud, and AI under a single framework. The latest long-term support (LTS) version is .NET 8 (2023) and the latest stable short-term support release (STS) is .NET 9 (2024).

Why do interviewers ask this?

Understanding these versions helps developers choose the right .NET stack for different projects and shows awareness of how .NET has evolved from a Windows-only to a modern cross-platform framework.

#4. What is CIL (Common Intermediate Language)?
When you compile C# code, it doesn’t turn into machine code directly. Instead, it compiles into Common Intermediate Language (CIL), which is then executed by the CLR.

CIL enables:

Cross-platform compatibility – Code written in any .NET language can run on different operating systems via the CLR

Language interoperability – Since all .NET languages compile to CIL, C#, F#, and VB.NET can interact seamlessly

Why do interviewers ask this?

Understanding CIL shows that you grasp how .NET code executes and why .NET applications are cross-platform and language-agnostic.

#5. What is the difference between managed and unmanaged code?
In .NET, code can be managed or unmanaged, depending on whether it runs inside the Common Language Runtime (CLR).

The difference comes down to how memory is managed and how safely the code executes.

Managed code
When you write C# code, it runs inside the CLR, which takes care of memory management, security, and exception handling for you. You don’t have to worry about allocating and freeing memory manually, and the CLR ensures your application doesn’t access memory it shouldn’t.

This makes managed code safer and more stable.

For example

If you create an object in C#:

Person p = new Person();

The CLR will automatically free up memory when
`p`
is no longer needed, thanks to the garbage collector. This prevents memory leaks and other issues that often plague low-level languages.

Unmanaged code
Unmanaged code runs outside the CLR, meaning it doesn’t get these safety features. Instead, the developer is responsible for managing memory manually.

This can make it more efficient in some cases, but it also means there’s a greater risk of memory leaks, security vulnerabilities, and crashes if something goes wrong.

Languages like C and C++ generate unmanaged code, and even in .NET, you might encounter it when working with:

System APIs that require direct access to hardware or OS-level functions

Performance-critical applications where manual memory management is more efficient

Legacy codebases that were originally written in C or C++

This means that to work with unmanaged code in .NET, you’ll often use:

P/Invoke (Platform Invocation Services) – Allows C# to call native C/C++ functions

COM Interop – Enables communication between .NET and older Windows applications

Why does this matter?

Most of the time, as a C# developer, you’ll be working with managed code - and that’s a good thing. It saves time, prevents memory issues, and keeps applications secure.

However, understanding unmanaged code is useful when you need to integrate with older systems, optimize performance, or interact with low-level system components

Why do interviewers ask this?

Interviewers want to see if you:

Understand how the CLR manages memory and execution

Know the risks and benefits of using unmanaged code

Are familiar with P/Invoke and COM Interop, even if you don’t use them daily

#6. What is garbage collection in .NET, and how does it work?
Managing memory efficiently is one of the biggest challenges in programming.

In languages like C++, developers must manually allocate and free memory, which can lead to memory leaks, security issues, and crashes if done incorrectly. .NET solves this problem with garbage collection (GC), which automatically frees memory used by objects that are no longer needed.

This makes applications more reliable and easier to manage, but it also means developers need to understand how garbage collection works to avoid performance issues.

How garbage collection works
The Common Language Runtime (CLR) includes a Garbage Collector (GC) that runs automatically when needed. It follows a three-step process:

Marking – The GC scans memory to identify which objects are still in use

Sweeping – It removes objects that are no longer needed, freeing up memory

Compacting – It reorganizes memory to prevent fragmentation and improve efficiency

This process happens without developer intervention, which reduces the chances of memory leaks but also means developers don’t have direct control over when garbage collection occurs.

Does garbage collection affect performance?
Yes, while garbage collection helps prevent memory issues, it can temporarily pause execution when it runs. If too many objects are created and discarded frequently, GC cycles can slow down application performance.

To optimize memory usage and reduce the impact of GC:

Avoid unnecessary object creation—Reusing objects can reduce memory allocations

Use structs instead of classes for lightweight data types, since structs are stored on the stack instead of the heap

Minimize large object allocations, as large objects trigger special GC behavior

In performance-critical applications, .NET provides tools like
`GC.Collect()`
,
`Span<T>`
, and
`Memory<T>`
to fine-tune memory management, but these should only be used when absolutely necessary.

Why do interviewers ask this?

Memory management is crucial for scalability and performance. Interviewers ask this question to see if you:

Understand how .NET prevents memory leaks

Know how garbage collection can impact application performance

Can write efficient code that minimizes unnecessary memory allocations

#7. What are value types and reference types in C#?
In C#, data is stored in memory as either value types or reference types, which affects performance and behavior when passing variables.

Value types
Store their actual data directly in memory

When assigned to a new variable, a copy of the value is made

Modifying one variable does not affect the original

Common value types include:

Primitive types like 
`int`
, 
`float`
, 
`char`
, and
`bool`

Structs (
`struct`
) – Custom value types for lightweight objects

Enums (
`enum`
) – Used for defining named constants

For example

int a = 10;
int b = a; // A copy of 'a' is stored in 'b'

b = 20;
Console.WriteLine(a); // Output: 10 (a remains unchanged)

Reference types
Store a reference (memory address) to the actual data instead of storing the value directly

When assigned to a new variable, both variables point to the same memory location, meaning changes to one object affect the other

Common reference types include:

Classes (
`class`
) – Used for complex objects

Arrays (
`int[]`
,
`string[]`
, etc.) – Collections of values

Delegates and Interfaces – Also stored as references

For example

class Person
{
    public string Name;
}

Person p1 = new Person();
p1.Name = "Alice";

Person p2 = p1; // Both 'p1' and 'p2' reference the same object in memory

p2.Name = "Bob";
Console.WriteLine(p1.Name); // Output: Bob (p1 is affected)

Why do interviewers ask this?

Choosing value types vs. reference types affects performance, memory usage, and how data behaves when passed around in code.

Interviewers ask this question to see if you understand how C# manages memory and how to avoid unintended side effects when modifying objects.

#8. What is the difference between an interface and an abstract class?
In C#, both interfaces and abstract classes are used to define reusable code structures, but they serve different purposes. Understanding their differences is key to designing flexible, maintainable applications.

Interface
Defines a contract that a class must follow

Only contains method signatures (no implementations)

A class can implement multiple interfaces

For example

interface IAnimal
{
    void MakeSound(); // No implementation
}

class Dog : IAnimal
{
    public void MakeSound()
    {
        Console.WriteLine("Bark!");
    }
}

Here,
`Dog`
implements
`IAnimal`
, ensuring it provides a
`MakeSound()`
method.

Abstract class
Can have both abstract methods (without implementation) and concrete methods (with implementation)

Allows related classes to share code while enforcing some common behavior

A class can inherit only one abstract class

For example

abstract class Animal
{
    public abstract void MakeSound(); // Must be implemented by subclasses

    public void Sleep()
    {
        Console.WriteLine("Sleeping...");
    }
}

class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Bark!");
    }
}

Here,
`Dog`
inherits from
`Animal`
, implementing
`MakeSound()`
while inheriting
`Sleep()`
.

Key differences
Method

Interface

Abstract Class

Method implementation

No method implementations (except default methods in C# 8+)

Can have both abstract and concrete methods

Multiple inheritance

A class can implement multiple interfaces

A class can inherit only one abstract class

Fields and properties

Cannot contain fields or constructors

Can have fields, properties, and constructors

Use case

Defines a contract that multiple classes can follow

Provides a base class with shared behavior

When to use what?
Use an interface when enforcing a contract across multiple unrelated classes (e.g.,
`IComparable`
,
`IDisposable`
)

Use an abstract class when defining shared behavior for related classes (e.g.,
`Animal`
,
`Vehicle`
)

Why do interviewers ask this?

Interviewers want to see if you understand object-oriented programming principles and how to design reusable, maintainable code. Knowing when to use an interface or an abstract class demonstrates fundamental architectural decision-making skills.

#9. What is a delegate in C#, and how is it used?
A delegate in C# is a type that represents a reference to a method. It allows methods to be passed as arguments, making it a key feature for event handling, callbacks, and functional programming.

Think of it as a function pointer, but type-safe and object-oriented.

How delegates work
A delegate acts as a wrapper around a method, allowing you to store and invoke it dynamically. Instead of calling a method directly, you assign it to a delegate and call the delegate instead.

For example

using System;

delegate void MessageDelegate(string message); // Declaring a delegate

class Program
{
    static void PrintMessage(string msg) // Method that matches the delegate signature
    {
        Console.WriteLine(msg);
    }

    static void Main()
    {
        MessageDelegate del = PrintMessage; // Assign method to delegate
        del("Hello, delegates!"); // Invoke the delegate
    }
}

Output:

Hello, delegates!

Here,
`MessageDelegate`
is a delegate type that points to the
`PrintMessage`
method. When
`del("Hello, delegates!")`
is called, it internally calls
`PrintMessage`
.

Multicast delegates (calling multiple methods)
Delegates can also store multiple method references, meaning you can assign more than one method to the same delegate.

void Method1(string msg) => Console.WriteLine("Method1: " + msg);
void Method2(string msg) => Console.WriteLine("Method2: " + msg);

MessageDelegate del = Method1;
del += Method2; // Adding another method

del("Hello!");

Output:

Method1: Hello!
Method2: Hello!

Here, the delegate calls both methods in sequence.

Func, Action, and Predicate Delegates
C# also provides built-in generic delegates to make working with delegates easier:

 
`Func<T>`
– Returns a value. Example: 
`Func<int, int, int> add = (x, y) => x + y`

 
`Action<T>`
– Takes parameters but returns void. Example: 
`Action<string> print = Console.WriteLine`

 
`Predicate<T>`
– Returns a 
`bool`
. Example: 
`Predicate<int> isEven = x => x % 2 == 0`

Why do interviewers ask this?

Delegates are crucial in event-driven programming (e.g., UI event handling) and functional programming (e.g., passing behavior as parameters). 

Interviewers want to see if you understand how method references work in C# and how they improve code flexibility.

#10. What is the difference between
Modern applications often need to perform long-running operations like API calls, database queries, or file I/O. If these tasks block execution, the application can freeze, making it unresponsive. 

This is where
`async`
and
`await`
come in - they allow tasks to run in the background without blocking the main thread, keeping applications smooth and responsive.

What does
The 
`async`
keyword tells C# that a method will contain asynchronous operations. However, marking a method 
`async`
alone doesn’t make it run asynchronously — it simply allows the method to use 
`await`
inside it.

For example

public async Task<string> GetDataAsync()
{
    await Task.Delay(2000); // Simulating a delay (e.g., waiting for a web request)
    return "Data received";
}

This method returns a
`Task<string>`
, meaning it will complete in the future rather than immediately returning a value.

What does
The 
`await`
keyword is where the real magic happens. It pauses execution of the method until the awaited task completes — but without blocking the thread.

For example 

public async Task ShowData()
{
    string data = await GetDataAsync(); // Waits for the method to complete
    Console.WriteLine(data);
}

Without await, the method would continue executing immediately, likely leading to unintended behavior (such as trying to use data that hasn’t been retrieved yet).

Key differences between
`async`
marks a method as asynchronous but does not make it run in the background

`await`
pauses execution until the awaited task completes, keeping the application responsive

Why does this matter?

Imagine writing an application that fetches weather data from an API. If the request takes three seconds and the application freezes during that time, the user might think it’s broken.

But by using
`async`
and
`await`
, you can fetch the data without blocking the UI thread, making for a much better experience.

Why do interviewers ask this?

Interviewers want to see if you:

Understand how
`async`
and
`await`
work together

Know how to use them to prevent blocking operations

Can write responsive and efficient C# applications

Intermediate .NET Interview Questions
#11. What is dependency injection in .NET, and why is it used?
In a real-world application, classes often need to use other classes.

For example

An
`OrderService`
class might need a
`PaymentService`
to process payments. The question is: who should be responsible for creating that dependency?

If
`OrderService`
creates an instance of
`PaymentService`
inside its own code, it becomes tightly coupled—meaning it's harder to replace, test, or modify in the future. This is where dependency injection (DI) comes in.

Dependency injection is a design pattern that provides dependencies from the outside, rather than letting a class create them itself.

This makes the system:

More flexible – You can swap out implementations without modifying the class

Easier to test – You can replace dependencies with mock versions in unit tests

Loosely coupled – Classes depend on interfaces rather than concrete implementations

For example

Without dependency injection (tightly coupled)

public class OrderService
{
    private PaymentService _paymentService = new PaymentService(); // Hardcoded dependency

    public void ProcessOrder()
    {
        _paymentService.ProcessPayment();
    }
}

Here,
`OrderService`
directly creates
`PaymentService`
, meaning if we ever want to change the way payments are processed, we’d have to modify
`OrderService`
. This tight coupling makes the application harder to maintain and test.

For example

With dependency injection (loosely coupled)

public class OrderService
{
    private readonly IPaymentService _paymentService;

    public OrderService(IPaymentService paymentService) // Injecting dependency
    {
        _paymentService = paymentService;
    }

    public void ProcessOrder()
    {
        _paymentService.ProcessPayment();
    }
}

Now,
`OrderService`
doesn’t create
`PaymentService`
itself - it receives it in the constructor from the outside. This makes it easy to switch to a different payment provider without modifying
`OrderService`
.

This is especially useful in large applications where dependencies might change over time. Instead of manually updating every class that creates instances of a dependency, DI allows dependencies to be configured in one place.

How does ASP.NET Core handle DI?
ASP.NET Core has built-in dependency injection, so you don’t have to manage dependencies manually. You simply register services in
`Program.cs`
:

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddScoped<IPaymentService, PaymentService>(); // Registering dependency
var app = builder.Build();

Now, whenever
`IPaymentService`
is needed, .NET automatically provides an instance of
`PaymentService`
.

Why do interviewers ask this?

Interviewers want to see if you:

Understand why DI improves maintainability and testability

Know how to implement DI using constructor injection

Are familiar with how ASP.NET Core handles dependency injection

Because most modern .NET applications rely on DI, knowing how to use it is a must-have skill for C# developers.

#12. What are generics in C#?
In C#, we often write code that works with different data types. Without generics, we’d need to create separate methods or classes for each data type, leading to code duplication and maintenance issues.

Generics solve this by allowing us to write reusable, type-safe code that works with any data type.

Why use generics?
Code reusability – One generic method/class can handle multiple data types

Type safety – Prevents runtime errors by enforcing type checks at compile time

Performance – Avoids boxing/unboxing, reducing memory overhead

How do generics work?
Instead of writing multiple versions of the same method for different types:

public void Print(int value) { Console.WriteLine(value); }
public void Print(string value) { Console.WriteLine(value); }

We can define a single generic method:

public void Print<T>(T value) { Console.WriteLine(value); }

This works with any type, making the code more flexible and maintainable.

Generics in collections
Generics are widely used in collections like
`List<T>`
:

List<int> numbers = new List<int>(); // Type-safe
numbers.Add(5);  // Only allows ints

Without generics, older collections like
`ArrayList`
allowed mixed types, which could lead to runtime errors and slower program execution.

Why do interviewers ask this?

Generics are a core feature of C#. Interviewers want to see if you understand:

How generics improve code reuse

How they prevent runtime errors through type safety

How to use them in real-world scenarios (e.g., collections, methods, and interfaces)

Knowing when and how to use generics makes you a better C# developer, especially when working with frameworks like ASP.NET Core, LINQ, and Entity Framework.

#13. What is LINQ, and how does it work?
LINQ (Language Integrated Query) is a C# feature that simplifies data queries across different sources like collections, databases, and XML. Instead of writing loops and conditions manually, LINQ allows you to filter, sort, and transform data using a more readable, functional, SQL-like syntax.

Without LINQ, querying data often involves writing complex loops and conditions. 

For example

Filtering even numbers from a list manually might look like this:

List<int> numbers = new() { 1, 2, 3, 4, 5 };
List<int> evenNumbers = new();

foreach (var number in numbers)
{
    if (number % 2 == 0)
        evenNumbers.Add(number);
}

With LINQ, the same logic is simpler and more expressive:

var evenNumbers = numbers.Where(n => n % 2 == 0).ToList();

Instead of iterating manually (imperative programming), LINQ applies the condition (functional programming) to the collection and returns the filtered results.

How does LINQ work?
LINQ provides a consistent query language across multiple data sources:

LINQ to Objects – Queries in-memory collections like
`List<T>`
and
`Array`
.

LINQ to Entities – Queries databases using Entity Framework.

LINQ to XML – Reads and manipulates XML documents.

It also supports common operations like filtering (
`Where`
), projection (
`Select`
), sorting (
`OrderBy`
), and grouping (
`GroupBy`
).

Deferred Execution vs. Immediate Execution
One key LINQ feature is deferred execution. Queries are not executed immediately but only when the data is actually needed.

var query = numbers.Where(n => n > 2); // No filtering happens yet
var result = query.ToList(); // Now the filtering runs

This allows LINQ to optimize execution, especially when working with databases, reducing unnecessary processing.

Why do interviewers ask this?

Interviewers ask about LINQ to see if you understand how to query data efficiently and optimize performance. They want to know if you can avoid common pitfalls like excessive database queries and recognize when to use deferred execution for better efficiency.

#14. What is the difference between
In C#,
`IEnumerable<T>`
,
`IQueryable<T>`
, and
`List<T>`
are used to work with collections, but they behave differently in terms of execution, performance, and memory usage. 

Choosing the right one can mean the difference between an optimized query and a performance bottleneck.

What is
`IEnumerable<T>`
is best for iterating over in-memory collections. It does not modify how data is retrieved - it simply provides a way to loop through it one item at a time.

For example

If you use
`IEnumerable<T>`
with Entity Framework, filtering happens after data is loaded into memory:

IEnumerable<int> nums = dbContext.Numbers.Where(n => n > 10); // Filters after loading data

This means the entire dataset is loaded first, and only then does filtering occur - making it inefficient for large datasets.

What is
`IQueryable<T>`
is used when querying databases because it allows filtering, sorting, and aggregation before data is loaded.

With
`IQueryable<T>`
, the filtering happens directly in the database:

IQueryable<int> numsQuery = dbContext.Numbers.Where(n => n > 10); // Filters at the database level

Since the filtering is done at the database level, only the necessary data is retrieved, making it far more efficient for large datasets.

What is
A
`List<T>`
is a concrete collection that stores all its data in memory. Unlike
`IEnumerable<T>`
, it allows fast indexing and modification.

For example

List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };
Console.WriteLine(numbers[2]); // Fast access to index 2

However, since
`List<T>`
loads all data at once, it’s best suited for small datasets where you need quick access to elements.

When should you use each?
Use
`IEnumerable<T>`
for in-memory collections where performance isn’t a concern

Use
`IQueryable<T>`
for database queries, ensuring filtering and sorting happen before data is retrieved

Use
`List<T>`
when you need fast indexing and modification, but keep in mind that it loads everything into memory

Why do interviewers ask this?

Interviewers ask this question to see if you understand how LINQ queries execute and how to choose the right type for performance optimization. They want to know if you recognize when in-memory operations are inefficient and how
`IQueryable<T>`
can improve database performance.

#15. What are extension methods in C#?
Sometimes, you need to add functionality to an existing type but don’t have access to modify its source code.

In C#, extension methods allow you to add new methods to existing types without changing their original definition. They behave like instance methods but are actually static methods defined in a separate static class.

An extension method must be declared in a static class, and the first parameter must use the
`this`
keyword followed by the type being extended. This allows the method to appear as if it belongs to that type.

For example

Adding a
`ToTitleCase()`
method to strings

public static class StringExtensions
{
    public static string ToTitleCase(this string input)
    {
        return System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(input);
    }
}

// Usage:
string name = "hello world";
Console.WriteLine(name.ToTitleCase()); // Output: Hello World

Here,
`ToTitleCase()`
extends the functionality of the
`string`
class without modifying it directly.

Extension methods are widely used in LINQ, where methods like
`Where()`
,
`Select()`
, and
`OrderBy()`
extend
`IEnumerable<T>`
. They are also frequently used in ASP.NET Core for configuring middleware, services, and dependency injection.

They are useful when you want to enhance built-in .NET types or existing classes without modifying their source code. Instead of creating utility methods that require explicit method calls, extension methods provide a cleaner and more natural way to extend functionality.

Why do interviewers ask this?

Interviewers ask about extension methods to see if you understand how they work, why they are useful, and when they should be used. They also want to know if you recognize how LINQ and ASP.NET Core rely on them internally to provide fluent, readable syntax.

#16. What is reflection in C#?
Reflection in C# allows a program to inspect and manipulate types, methods, and properties at runtime. It’s the .NET variant of meta programming. It’s useful when you need to work with objects dynamically without knowing their exact types at compile time.

Common use cases of reflection
Metadata inspection – Getting information about assemblies, types, and members

Dynamic method invocation – Calling methods without hardcoding their names

Creating objects at runtime – Instantiating types dynamically

Serialization frameworks – Used in JSON and XML serialization

Dependency injection and testing frameworks – Used for automatic object creation

For example

Retrieving metadata about a type:

Type type = typeof(string);
Console.WriteLine(type.FullName); // Outputs: System.String

For example

Dynamically invoking a method using reflection:

MethodInfo method = typeof(Console).GetMethod("WriteLine", new[] { typeof(string) });
method.Invoke(null, new object[] { "Hello, Reflection!" });

This finds the
`WriteLine(string)`
method in the
`Console`
class and invokes it dynamically.

Performance considerations
Reflection is slower than direct method calls because:

It bypasses compile-time optimizations

It uses late binding, which incurs additional overhead

Reflection should be used carefully to avoid performance issues, especially in high-frequency operations.

Reflection is not available in ahead-of-time (AOT) compiled .NET applications.

Why do interviewers ask this?

Interviewers want to see if you:

Understand how C# interacts with metadata dynamically

Know when to use reflection (e.g., for frameworks and testing) and when to avoid it due to performance concerns

Can apply reflection effectively without overusing it in performance-critical code

#17. What is boxing and unboxing in C#?
Boxing and unboxing are operations that convert value types into reference types and vice versa. While useful, they come with performance costs, so understanding them is important for writing efficient C# code.

Boxing happens when a value type, such as an
`int`
or
`double`
, is converted into an object and stored on the heap. This allows value types to be used in places where an object is required, such as collections that store objects rather than primitives.

For example

int num = 10;
object boxed = num; // Boxing (value → object)

Here,
`num`
is copied from the stack to the heap, and
`boxed`
now holds a reference to that value.

Unboxing is the reverse process - it extracts a value type from an object, converting it back to its original type. This requires explicit casting and retrieves the value from the heap back into a value type variable.

For example

int unboxed = (int)boxed; // Unboxing (object → value)

If the object does not actually contain the expected type, an
`InvalidCastException`
will be thrown.

Boxing and unboxing introduce performance overhead because boxing moves data from the stack to the heap, increasing memory usage, while unboxing requires explicit casting, which adds extra processing time.

Frequent boxing can also lead to excessive garbage collection, slowing down performance.

To avoid unnecessary boxing and unboxing, generic collections should be used instead of non-generic collections like
`ArrayList`
, which store items as objects and require boxing. Keeping value types in their native form whenever possible also reduces unnecessary allocations.

Why do interviewers ask this?

Interviewers ask about boxing and unboxing to see if you understand how C# manages memory and performance. They want to know if you recognize the impact of excessive boxing and unboxing and how to use generics to prevent unnecessary conversions.

#18. What is middleware in ASP.NET Core?
In ASP.NET Core, middleware is a set of components that process HTTP requests and responses as they pass through the application. Every request that enters an ASP.NET Core application goes through a middleware pipeline before reaching the final destination, such as a controller or an endpoint.

Middleware components can perform tasks like logging, authentication, authorization, exception handling, and request modification. Each component has the option to either process the request or pass it along to the next middleware in the pipeline.

How does middleware work?
Middleware is executed in the order it is registered in the
`Program.cs`
file. Each middleware can perform its task and then decide whether to pass the request further or terminate it early.

For example

Logging middleware might record request details before passing control to the next middleware:

app.Use(async (context, next) =>
{
    Console.WriteLine($"Request: {context.Request.Path}");
    await next(); // Passes control to the next middleware
});

Here,
`await next()`
ensures that the request continues to the next middleware in the pipeline.

How is middleware configured in ASP.NET Core?
Middleware is registered in
`Program.cs`
using built-in or custom components.

Some common middleware includes:

`UseRouting()`
for handling route mapping

`UseAuthentication()`
for user authentication

`UseAuthorization()`
for access control

`UseExceptionHandler()`
for centralized error handling

For example

This pipeline ensures proper routing and authentication before requests reach the controller:

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();
app.Run();

The order of middleware matters because each component can modify the request or response before passing it further. Placing middleware incorrectly can lead to unexpected behavior.

Why do interviewers ask this?

Interviewers ask about middleware to see if you understand how the request pipeline works in ASP.NET Core. They want to know if you can properly configure middleware for authentication, logging, error handling, and request processing in an ASP.NET Core web application.

#19. What is the difference between
In C#, both
`Finalize`
and
`Dispose`
are used for cleaning up unmanaged resources like file handles, database connections, or network sockets. However, they work differently in terms of when and how they release resources.

`Dispose`
is part of the
`IDisposable`
interface and allows manual resource cleanup. It should be called explicitly when you are done using an object.

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();
app.Run();

By calling
`Dispose()`
, developers ensure that resources are freed as soon as they are no longer needed, rather than waiting for garbage collection.

`Finalize`
, on the other hand, is called implicitly by the garbage collector before an object is destroyed. It is defined using a destructor:

class ResourceHandler
{
    ~ResourceHandler()
    {
        Console.WriteLine("Finalizer called by GC.");
    }
}
Because
`Finalize`
runs automatically, it should only be used as a backup cleanup method in case
`Dispose`
was not called. However, finalizers introduce performance overhead because the garbage collector must process them before reclaiming memory.

Objects that use
`Dispose`
should also call
`GC.SuppressFinalize(this)`
to prevent the garbage collector from running
`Finalize`
unnecessarily.

Why do interviewers ask this?

Interviewers ask about
`Finalize`
and
`Dispose`
to see if you understand how C# manages unmanaged resources. They want to know if you recognize the importance of calling
`Dispose()`
for deterministic cleanup and how to avoid unnecessary finalization overhead in garbage collection.

#20. What are async streams, and how do they work?
Async streams in C# allow asynchronous iteration over data sequences, making it easier to handle large datasets, real-time data processing, and streaming responses without blocking execution. They are useful when working with data that arrives gradually, such as reading from a database, consuming an API, or processing files.

Normally, an
`IEnumerable<T>`
collection loads all elements at once before iteration begins. With async streams, an
`IAsyncEnumerable<T>`
allows data to be fetched piece by piece, preventing memory overload and keeping the application responsive.

How do async streams work?
An async stream is defined using
`IAsyncEnumerable<T>`
and the
`yield return`
statement inside an
`async`
method.

async IAsyncEnumerable<int> GenerateNumbers()
{
    for (int i = 1; i <= 5; i++)
    {
        await Task.Delay(1000); // Simulating delay
        yield return i;
    }
}

Instead of returning all values at once, this method yields each value asynchronously as it becomes available.

To consume an async stream, use
`await foreach`
, which waits for each value without blocking execution.

await foreach (var number in GenerateNumbers())
{
    Console.WriteLine(number);
}

This ensures that the application remains responsive while waiting for new data.

Why use async streams?
Async streams are beneficial when working with large datasets or slow data sources, such as:

Streaming data from an API without waiting for the full response

Reading large files line by line without loading them entirely into memory

Fetching paginated database records asynchronously to improve performance

Why do interviewers ask this?

Interviewers ask about async streams to see if you understand how to process large datasets efficiently. They want to know if you can implement
`IAsyncEnumerable<T>`
, use
`await foreach`
, and recognize when async streams improve performance compared to traditional collections.

Advanced .NET Interview Questions
#21. What are microservices, and how does .NET support them?
Microservices are an architectural approach where an application is built as a collection of small, independent services that communicate over a network. Each microservice is designed to handle a specific function, such as user authentication, order processing, or payment handling.

This allows for better scalability, maintainability, and flexibility compared to traditional monolithic applications.

In a monolithic application, all components are tightly coupled and deployed as a single unit. With microservices, each service can be developed, deployed, and scaled independently, reducing the risk of system - wide failures at the cost of a more complex deployment.

How does .NET support microservices?
.NET provides several tools and frameworks for building microservices, making it easier to develop and manage distributed systems.

ASP.NET Core simplifies the creation of lightweight, high-performance web APIs that serve as microservices

Docker allows each microservice to run in its own container, ensuring isolation and consistency across different environments

Kubernetes helps orchestrate and manage containerized microservices, handling scaling, deployment, and networking

gRPC provides efficient, high-performance communication between microservices using a binary protocol instead of traditional REST APIs

Message brokers such as RabbitMQ, Azure Service Bus, and Kafka enable event-driven communication between microservices, improving scalability and resilience

For example

A microservice built using ASP.NET Core exposes RESTful APIs:
[ApiController]
[Route("api/products")]
public class ProductsController : ControllerBase
{
    [HttpGet]
    public IEnumerable<string> Get() => new string[] { "Product1", "Product2" };
}

Each microservice can be independently deployed and scaled based on demand.

Microservices allow faster development cycles, fault isolation, and independent scaling of different components. However, they also introduce challenges such as managing distributed systems, handling inter-service communication, and ensuring security.

Why do interviewers ask this?

Interviewers ask about microservices to see if you understand their benefits and challenges. They want to know if you can design microservices correctly, implement API-based communication, and use tools like ASP.NET Core, Docker, and Kubernetes to manage them.

#22. What are design patterns in .NET?
Design patterns are reusable solutions to common software design problems. Instead of reinventing solutions for recurring issues, developers use established design patterns to create more structured, maintainable, and scalable applications. 

These patterns help improve code organization, reduce complexity, and make it easier to modify or extend functionality.

Design patterns in .NET follow standard object-oriented principles and are divided into three main categories:

Creational Patterns – Handling object creation efficiently
Singleton ensures only one instance of a class exists throughout an application.

Factory Method provides a way to create objects without specifying their concrete type.

Builder constructs complex objects step by step, improving code readability.

For example 

Here we can see the Singleton pattern:

public class Singleton
{
    private static readonly Singleton _instance = new Singleton();
    private Singleton() { }
    public static Singleton Instance => _instance;
}

This ensures that only one instance of
`Singleton`
can exist.

Structural Patterns – Organizing relationships between objects
Adapter allows incompatible interfaces to work together

Decorator adds behavior dynamically to an object without modifying its structure

Facade provides a simplified interface to a more complex system

For example

Here we can see the Adapter pattern:

public interface ITarget
{
    void Request();
}

public class Adaptee
{
    public void SpecificRequest() => Console.WriteLine("Called SpecificRequest");
}

public class Adapter : ITarget
{
    private readonly Adaptee _adaptee;
    public Adapter(Adaptee adaptee) { _adaptee = adaptee; }
    public void Request() => _adaptee.SpecificRequest();
}

Here,
`Adapter`
bridges the gap between
`Adaptee`
and
`ITarget`
, allowing incompatible interfaces to communicate.

Behavioral Patterns – Managing object interactions
Observer enables one-to-many dependency, where changes in one object update dependent objects (publish/subscribe)

Strategy allows selecting an algorithm dynamically at runtime

Command encapsulates requests as objects, allowing deferred execution

For example 

Here you can see the Strategy pattern:

public interface IStrategy
{
    void Execute();
}

public class ConcreteStrategyA : IStrategy
{
    public void Execute() => Console.WriteLine("Executing Strategy A");
}

public class Context
{
    private IStrategy _strategy;
    public Context(IStrategy strategy) { _strategy = strategy; }
    public void ExecuteStrategy() => _strategy.Execute();
}

Here, the strategy can be swapped dynamically, improving flexibility.

Why do interviewers ask this?

Interviewers ask about design patterns to see if you can write maintainable, scalable code using established best practices. They want to know if you understand when and how to use patterns like Singleton, Factory, Adapter, and Strategy to improve code structure and flexibility.

#23. What is the difference between
What is a
A
`Thread`
is like an independent worker - it runs its own execution flow separate from the main program.

If you need fine-grained control over execution, such as manual thread management, synchronization, or priority adjustments, using
`Thread`
directly might be necessary.

Here’s how you create and start a thread in C#:

Thread thread = new Thread(() => Console.WriteLine("Running in a thread"));
thread.Start();

While this works, manually creating and managing multiple threads can be inefficient. Each thread consumes system resources, and handling synchronization manually can lead to race conditions or deadlocks if not carefully managed.

What is a
A
`Task`
is a more flexible and efficient way to handle concurrency in C#. 

Unlike
`Thread`
, a
`Task`
automatically uses the thread pool, reducing overhead when dealing with multiple operations. It integrates seamlessly with
`async`
and
`await`
, making it the preferred choice for short-lived, scalable asynchronous operations.

For example

When creating a
`Task`
:

Task.Run(() => Console.WriteLine("Running in a task"));

Here, the Task Parallel Library assigns the operation to an available thread pool thread, rather than creating a new thread manually.

When should you use each?
Use
`Threads`
when you need long-running, dedicated background operations that require direct control

Use
`Tasks`
when dealing with asynchronous operations, such as I/O-bound workloads (file operations, database queries, web requests)

Why do interviewers ask this?

Interviewers ask about the difference between
`Task`
and
`Thread`
to see if you understand how C# handles concurrency and parallelism. 

They want to know if you can choose the right approach for performance and scalability - using
`Task`
for asynchronous operations and avoiding unnecessary manual thread management.

#24. How do you optimize performance in a .NET application?
Performance optimization in .NET ensures that applications run efficiently by reducing resource consumption, improving execution speed, and maintaining scalability. 

Optimizing performance involves managing memory effectively, reducing database overhead, and leveraging asynchronous programming.

Optimize memory usage
Excessive object creation can trigger frequent garbage collection, slowing down an application.

To minimize this:

Use
`struct`
instead of
`class`
for small, frequently used data types, as structs are stored on the stack rather than the heap

Reduce unnecessary allocations and object instantiations

Use
`Span<T>`
and
`Memory<T>`
for handling large data sets efficiently without additional allocations

Use asynchronous programming
Blocking operations can degrade performance, especially in web applications. Using
`async`
and
`await`
allows tasks like database queries and API calls to run in the background without blocking the main thread.

For example

An asynchronous database query:

public async Task<User> GetUserAsync(int id)
{
    return await dbContext.Users.FindAsync(id);
}

This keeps the application responsive while waiting for the query to complete.

Optimize database queries
Database interactions are often a performance bottleneck.

To improve efficiency:

Use
`AsNoTracking()`
in Entity Framework for read-only queries to avoid unnecessary change tracking

Fetch only required columns instead of retrieving entire objects

Use indexes to speed up query execution

For example 

Here you can see an optimized query:

var names = dbContext.Users.Select(u => u.Name).ToList();

This retrieves only the
`Name`
field instead of loading full user objects.

Implement caching
Caching reduces redundant database queries and improves response times. Using
`MemoryCache`
or
`HybridCache`
(newly introduced in .NET 9) for in-memory caching or Redis for distributed caching can speed up frequently accessed operations.

var cache = new MemoryCache(new MemoryCacheOptions());
cache.Set("key", expensiveDatabaseQueryResult, TimeSpan.FromMinutes(10));

This stores the result for 10 minutes, preventing repeated database queries.

Minimize LINQ Overhead
LINQ is powerful but can introduce performance overhead. When working with small in-memory collections, using
`foreach`
instead of LINQ can reduce unnecessary processing.
foreach (var user in users)
{
    Console.WriteLine(user.Name);
}

This avoids the additional overhead of
`Where()`
and
`Select()`
when filtering small collections.

Why do interviewers ask this?

Interviewers ask about performance optimization to see if you can identify bottlenecks and apply the right techniques to improve execution speed. 

They want to know if you understand how to optimize memory usage, database interactions, and asynchronous processing to build scalable, high-performance .NET applications.

#25. What is the role of
Handling large amounts of data efficiently is crucial for high-performance applications. In .NET,
`Span<T>`
and
`Memory<T>`
are designed to work with contiguous memory blocks while avoiding unnecessary allocations and reducing garbage collection overhead.

What is
`Span<T>`
is a stack-allocated type that represents a contiguous block of memory. It is lightweight and does not allocate memory on the heap, making it ideal for high-performance scenarios like processing arrays, buffers, and slices of data.

Unlike traditional arrays or lists,
`Span<T>`
can reference a portion of an existing array without copying data, making operations more efficient.

For example

Here we can see
`Span<T>`
slicing an array:

int[] numbers = { 1, 2, 3, 4, 5 };
Span<int> span = numbers.AsSpan(1, 3); // References {2, 3, 4}

Here,
`span`
does not create a new array but instead references a portion of
`numbers`
, reducing memory usage.

Since
`Span<T>`
lives on the stack, it cannot be used in asynchronous methods, because stack memory is not preserved across
`await`
calls. For async operations,
`Memory<T>`
is used instead.

What is
`Memory<T>`
provides similar functionality to
`Span<T>`
but supports heap allocation and can be used in asynchronous methods. It enables memory-efficient data manipulation while allowing the referenced memory to be stored on the heap rather than the stack.

For example

Memory<int> memory = new int[] { 1, 2, 3, 4, 5 };
Memory<int> slice = memory.Slice(1, 3); // References {2, 3, 4}

This behaves similarly to
`Span<T>`
but can be stored for later use and passed across async boundaries.

When should you use
Use
`Span<T>`
for synchronous operations that require low memory overhead and fast access

Use
`Memory<T>`
when working with asynchronous code where data needs to persist beyond a single method scope

Why do interviewers ask this?

Interviewers ask about
`Span<T>`
and
`Memory<T>`
to see if you understand modern memory management techniques in .NET. 

They want to know if you can optimize performance by reducing allocations and improving efficiency when working with large datasets or performance-critical applications.

#26. How does authentication and authorization work in .NET?
In .NET, authentication and authorization are used to control user access to different parts of an application. Authentication verifies a user's identity, while authorization determines what the user is allowed to do.

Authentication: Verifying the user’s identity
Authentication is the process of determining who the user is. .NET supports multiple authentication methods, including JWT (JSON Web Tokens), OAuth, OpenID Connect, and cookie-based authentication.

For example

Imagine we’re configuring JWT authentication in
`Program.cs`
:

services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Authority = "https://your-identity-provider.com";
        options.Audience = "your-api";
    });

Here, the application validates JWT tokens issued by an external identity provider before allowing access to protected resources.

Authorization: Controlling access
Once a user is authenticated, authorization determines what they can do. .NET provides role-based authorization (RBAC) and policy-based authorization to restrict access based on user roles or custom conditions.

For example

For role-based authorization, you can restrict access to specific roles using the
`[Authorize]`
attribute:

[Authorize(Roles = "Admin")]
public IActionResult SecureEndpoint() => Ok("Only admins can access this.");

This ensures that only users with the Admin role can access the
`SecureEndpoint`
method.

For example

For more granular control, policy-based authorization allows defining custom authorization rules:

services.AddAuthorization(options =>
{
    options.AddPolicy("MustBeOver18", policy =>
        policy.RequireClaim("Age", "18+"));
});

This policy requires users to have an
`Age`
claim of
`18+`
to access certain resources.

How Authentication and Authorization work together
A user logs in, and the authentication system verifies their identity

If valid, the system issues an authentication token (e.g., JWT)

The user attempts to access a protected resource

The authorization system checks if they have permission based on roles or policies

If either authentication or authorization fails, access is denied.

Why do interviewers ask this?

Interviewers ask about authentication and authorization to see if you understand how to secure applications in .NET. They want to know if you can implement authentication providers like JWT and configure authorization rules to protect sensitive resources.

#27. What are value tasks in C#?
In C#,
`ValueTask<T>`
is an alternative to
`Task<T>`
designed to reduce memory allocations and improve performance in high-throughput asynchronous applications. 

It is particularly useful when a result may already be available and does not require creating a new task object.

How does
A
`Task<T>`
always creates an object on the heap, even if the operation completes synchronously. In contrast,
`ValueTask<T>`
can avoid unnecessary allocations when the result is immediately available.

For example 

When using
`Task<T>`
:

public async Task<int> GetValueAsync()
{
    return await Task.FromResult(42); // Always allocates memory
}

This creates a new
`Task<int>`
even though the result is already known.

For example

Now, using
`ValueTask<T>`
:

public ValueTask<int> GetValueAsync()
{
    return new ValueTask<int>(42); // No extra allocation
}

This avoids heap allocation when the value is already available.

However, if the method needs to perform an actual asynchronous operation, it can still return a
`ValueTask<T>`
that awaits a
`Task<T>`
.

When should you use
Use
`ValueTask<T>`
when a result is often available immediately, reducing the need for heap allocations

Use
`Task<T>`
for long-running async operations that always require background execution

`ValueTask<T>`
is useful in performance-critical applications, such as database caching or low-latency services, but it should not be overused. Unlike
`Task<T>`
, a
`ValueTask<T>`
should not be awaited multiple times, as it does not guarantee the same behavior on repeated awaits.

Why do interviewers ask this?

Interviewers ask about
`ValueTask<T>`
to see if you understand how to optimize asynchronous programming in C#. They want to know if you can use it correctly to improve performance while avoiding unnecessary memory allocations.

#28. How does
In C#,
`async/await`
is more than just syntactic sugar - it transforms asynchronous methods into state machines that handle execution flow automatically. 

While it makes asynchronous code easier to read and write, the compiler generates additional logic behind the scenes to track method progress and resume execution when awaited tasks complete.

How does the compiler transform
When you define an
`async`
method, the compiler does not execute it immediately.

Instead, it:

Generates a state machine that keeps track of execution progress

Splits the method into multiple parts, pausing execution at
`await`

Registers a continuation that tells the method where to resume when the awaited task completes

For example

Consider this simple
`async`
method:

public async Task<int> FetchDataAsync()
{
    await Task.Delay(1000);
    return 42;
}

At compile time, C# transforms this into something similar to:

public Task<int> FetchDataAsync()
{
    var stateMachine = new FetchDataStateMachine();
    stateMachine.MoveNext(); // Starts execution
    return stateMachine.Task;
}

The state machine runs the method step by step, pausing at
`await Task.Delay(1000)`
, returning control to the caller, and resuming execution when the task completes.

Does
No,
`async/await`
does not create new threads by itself. Instead, it schedules tasks asynchronously and resumes execution when ready.

If needed,
`Task.Run()`
can be used to run tasks on background threads, but async methods themselves do not automatically spawn new threads.

What happens when you use
When execution reaches an
`await`
statement, the following happens:

Execution pauses and returns control to the caller

The remaining method logic is saved as a continuation

When the awaited task completes, the continuation is scheduled to run

For example

In UI applications, if the
`SynchronizationContext`
is present (like in ASP.NET or WPF), the method resumes execution on the original context (e.g., the UI thread). Otherwise, it runs on a thread pool thread.

Common pitfalls and performance concerns
While
`async/await`
simplifies asynchronous programming, improper usage can lead to performance issues:

Blocking calls (
`.Result`
,
`.Wait()`
) – These force async methods to run synchronously, potentially causing deadlocks

Excessive task creation – Unnecessarily wrapping synchronous code in
`Task.Run()`
can cause extra thread switching

Ignoring
`ConfigureAwait(false)`
– In libraries, failing to use
`ConfigureAwait(false)`
can cause unnecessary thread context switches, slowing execution

Why do interviewers ask this?

Interviewers ask about how
`async/await`
works under the hood to see if you understand how C# manages asynchronous execution.

They also want to know if you can explain state machines, continuations, and why
`async/await`
does not create new threads but instead schedules tasks efficiently.

#29. What are some best practices for working with Entity Framework Core?
Entity Framework Core (EF Core) is a powerful object-relational mapper (ORM) that simplifies database access in .NET applications. 

However, inefficient use can lead to performance bottlenecks, security risks, and maintainability issues. Following best practices ensures that applications run efficiently and scale well.

Use
By default, EF Core tracks changes to entities, which adds overhead. For read-only queries,
`AsNoTracking()`
improves performance by disabling change tracking.

var users = dbContext.Users.AsNoTracking().ToList();

This is especially useful for reporting or data retrieval scenarios where tracking changes is unnecessary.

Optimize Queries with Projection
Fetching only required fields instead of entire entities reduces data transfer and improves performance.

var names = dbContext.Users.Select(u => u.Name).ToList();

Instead of retrieving full user objects, this query loads only the
`Name`
field, reducing memory usage.

Avoid Lazy Loading in Performance-Sensitive Applications
Lazy loading automatically fetches related entities when accessed, but it can lead to the N+1 query problem, causing multiple small queries instead of a single optimized one.

Use eager loading (
`Include()`
) or explicit loading when needed.

var users = dbContext.Users.Include(u => u.Orders).ToList();

This fetches users and their related orders in one query rather than multiple.

Use Transactions for Multiple Operations
When modifying multiple records, transactions ensure data consistency and prevent partial updates.

using var transaction = dbContext.Database.BeginTransaction();
try
{
    dbContext.Users.Add(new User { Name = "John" });
    dbContext.SaveChanges();
    transaction.Commit();
}
catch
{
    transaction.Rollback();
}

Transactions help maintain data integrity in cases where multiple database operations depend on each other.

Leverage Connection Pooling and Indexing
Using a connection pool reduces the overhead of repeatedly opening and closing database connections. Proper indexing improves query performance by speeding up lookups.

services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(connectionString, sqlOptions =>
        sqlOptions.EnableRetryOnFailure()));

Here,
`EnableRetryOnFailure()`
helps manage transient failures in cloud-based databases.

Why do interviewers ask this?

Interviewers ask about EF Core best practices to see if you understand common pitfalls and how to optimize database queries. They want to know if you can balance performance, security, and maintainability when working with relational databases.

CTO-Approved Technical .NET Interview Questions
Tech expertise is the foundation of a programmer’s competence. We’ll start with the .NET Core interview questions designed to determine a candidate’s understanding of essential .NET concepts, frameworks, and best practices. These are tailored to .NET Core interview questions for senior developers who have extensive experience and are expected to demonstrate deep technical knowledge and leadership capabilities.

Q1. What is dependency injection in .NET, and why is it useful?
Key points:

Promotes loose coupling between components
Improves code maintainability and testability
Supported by Microsoft’s built-in DI container and third-party tools
Enables easier swapping of implementations
Preferable answer: “The given concept in .NET is a fundamental design principle that promotes loose coupling between components in an application. It allows dependencies to be injected from outside, enhancing flexibility and maintainability. 

Using dependency injection frameworks like Microsoft’s built-in DI container or third-party libraries enables us to manage and swap dependencies easily, making our code more testable and scalable.”

Q2. What’s the difference between ASP.NET MVC and ASP.NET Web Forms? When should you use each?
Key points:

MVC: Clean separation of concerns, better suited for testable and complex apps
Web Forms: Drag-and-drop model, good for rapid, small-scale development
MVC is preferred for maintainability and modern architectures
Preferable answer: “ASP.NET MVC and ASP.NET Web Forms are both web frameworks. MVC follows the Model-View-Controller pattern, providing better separation of concerns and more control over the application’s behavior. In contrast, Web Forms use server-side controls and a more event-driven approach. 

I prefer ASP.NET MVC for complex applications where maintainability and testability are crucial. ASP.NET Web Forms might be suitable for the rapid development of simple, data-entry-focused applications.”

Q3. What is middleware in ASP.NET Core?
Key points:

Middleware operates globally on a request/response pipeline
Middleware adds behavior (e.g., logging, auth) across the whole app
Preferable answer: “Middleware in ASP.NET Core acts as a pipeline between the application and the server. It intercepts incoming requests, performs specific actions, and then passes the request to the next middleware. 

This modular approach allows us to add functionalities like authentication, logging, and error handling in a pluggable and reusable manner, enhancing application flexibility and maintainability.”

Q4. What is the difference between Middleware and ActionFilters?
Key points:

Middleware supports global request/response processing
ActionFilters are specific to MVC controller actions
Middleware handles cross-cutting concerns like logging, auth
ActionFilters enable fine-grained request control
Preferable answer: “The primary distinction between Middleware and ActionFilter lies in their scope and usage. Middleware operates globally on the request and response pipeline, applying to all incoming requests. 

ActionFilter is specific to ASP.NET MVC and allows us to filter and modify action method behavior for particular controllers or actions, enabling more granular control over request processing.”

Q5. What is LINQ in .NET, and how does Fluent API relate?
Key points:

LINQ provides a unified syntax for querying data (collections, DBs, XML)
Fluent API enables chaining for readable, expressive queries
Enhances code clarity and maintainability
Preferable answer: “LINQ (Language-Integrated Query) in .NET revolutionizes data querying and manipulation by providing a unified syntax to query collections, databases, XML, and more. It enables us to write expressive and readable code for data operations, significantly improving productivity and code quality. 

As for the Fluent API, it’s a powerful design pattern that allows us to chain method calls together to create more fluent and expressive code. In LINQ, Fluent API is suitable for building clean and concise complex queries, enhancing code readability and maintainability.”

Q6. How does the garbage collector work in .NET?
Key points:

Automatically manages memory in the managed heap
Frees memory of unused objects
Prevents leaks and crashes
Boosts app stability and performance
Preferable answer: “The garbage collector in .NET is essential for automatic memory management. It tracks and identifies unused objects in the managed heap and releases their memory, freeing resources for new allocations.

Its role is to prevent memory leaks and efficiently manage memory allocation and deallocation, ensuring optimal performance and stability of .NET applications.”

Q7. What is asynchronous programming in .NET and why is it important?
Key points:

Uses async/await for non-blocking execution
Improves responsiveness in I/O-heavy apps
Enhances scalability in web scenarios
Preferable answer: “Asynchronous programming in .NET allows tasks to execute independently, enhancing application performance and responsiveness. Using async and await keywords allows offloading time-consuming operations, such as file I/O or network calls, to run concurrently without blocking the main thread. 

That improves the application’s perceived speed, responsiveness, and scalability, especially in modern web applications handling multiple requests simultaneously.”

Q8. What’s the difference between await AsyncMethod() and AsyncMethod().Result?
Key points:

await: non-blocking, async-safe
.Result: blocks thread, may cause deadlocks
Use await for better responsiveness
Preferable answer: “The critical difference between “await AsyncMethod()” and “AsyncMethod().Result” lies in how they handle asynchronous operations. “await AsyncMethod()” is used for asynchronous programming, allowing the method to pause execution until the awaited task completes. 

On the other hand, “AsyncMethod().Result” blocks the main thread, waiting for the task’s completion, which can lead to potential deadlocks in specific scenarios. Using “await” with asynchronous methods is essential to maintain the application’s responsiveness.”

Q9. What types of caching are available in .NET?
Key points:

In-memory: fast, local to instance
Distributed: shared across app instances
Output caching: stores full HTML responses
Preferable answer: “In-memory caching stores data in the application’s memory, providing fast access to frequently used data within the same application instance. 

Distributed caching stores data in a shared cache accessible across multiple application instances, enhancing performance and reducing redundant data retrieval. 

Output caching caches rendered HTML content for a specific duration, reducing server load and improving page load times for subsequent requests.”

Q10. What are SOLID principles in .NET development?
Key points:

SRP: single responsibility
OCP: open/closed principle
LSP: derived classes replace base
ISP: small, focused interfaces
DIP: rely on abstractions
Preferable answer: “SOLID principles are fundamental guidelines in object-oriented design that promote maintainable and flexible code:

Single Responsibility encourages classes to have a single purpose, making them easier to maintain and test. 
The Open-Closed principle suggests that classes should be open for extension but closed for modification, enabling new functionalities without altering existing code. 
Liskov Substitution ensures that derived classes can be used interchangeably with their base classes without affecting the program’s correctness. 
Interface Segregation advocates for small, focused interfaces to prevent clients from implementing unnecessary methods. 
Dependency Inversion promotes loose coupling by depending on abstractions rather than concrete implementations. 
Applying these principles in .NET development leads to modular, scalable, and maintainable codebases, facilitating future enhancements and reducing code churn.”


Q11. What are the benefits of using Blazor in web development? 
Key points:

Build frontends with C# instead of JS
WebAssembly runs .NET in the browser
Unified client-server logic
Preferable answer: “Blazor enables full-stack web development using C#, eliminating the need for JavaScript in many scenarios. Its WebAssembly support allows running .NET code directly in the browser, enabling better performance for interactive web applications. 

I recommend Blazor for projects that benefit from shared logic across client and server or when leveraging a team’s existing C# expertise is critical.”

Q12. How does .NET MAUI simplify cross-platform development? 
Key points:

Single codebase for Android, iOS, Windows, and macOS
Unified APIs for UI and native features
Reduces maintenance overhead
Preferable answer: “.NET MAUI (Multi-platform App UI) simplifies cross-platform development by providing a single codebase for building native apps for Android, iOS, macOS, and Windows. It includes unified APIs for creating user interfaces and accessing platform-specific features. 

This eliminates the need for maintaining separate codebases, reducing development and maintenance efforts while ensuring a consistent user experience across platforms.”

Q13. How can ML.NET be used in a .NET application?
Key points:

Adds machine learning to .NET apps
Supports tasks like classification, regression
Model Builder helps train models without deep ML knowledge
Preferable answer: “ML.NET allows developers to implement machine learning models directly in .NET applications without requiring extensive knowledge of data science. It supports scenarios such as classification, regression, and recommendation systems. 

By using tools like Model Builder, even non-experts can train and integrate models quickly. It’s particularly useful for tasks like sentiment analysis, sales forecasting, or anomaly detection within .NET projects.”

Q14. How do you integrate Azure Cognitive Services into a .NET app?
Key points:

Register and retrieve API credentials
Use SDKs or REST APIs for integration
Add error handling, logging, and scalability features
Preferable answer: “Integrating Azure Cognitive Services into a .NET application involves registering for the desired AI service (e.g., Computer Vision or Language Understanding), obtaining the API keys, and using the provided SDKs or REST APIs to call the services. 

I would also implement proper error handling, logging, and rate-limiting mechanisms to ensure robustness and scalability. Comprehensive testing would confirm the integration’s reliability and performance under various conditions.”

Q15. How do you optimize a .NET app that includes AI features?
Key points:

Use caching for repeated predictions
Offload to cloud-based services
Leverage async and batching
Preferable answer: “AI-driven features can introduce performance bottlenecks due to resource-intensive computations. To optimize a .NET application, I would leverage caching for repeated predictions and use asynchronous processing. 

Offload heavy computations to cloud-based services like Azure Machine Learning. Profiling tools would help identify bottlenecks, and I’d implement techniques like batching requests to improve overall efficiency.”

Expert Case-Scenario .NET Developer Interview Questions
Once you’ve checked the software engineer’s tech knowledge, we suggest evaluating their problem-solving skills. A leading senior .NET developer must be adaptable and resilient, approach troubleshooting rationally, and propose effective solutions quickly. The following hypothetical interview questions for a senior developer will help determine whether the candidate is ready for the role.

Q16. How do you troubleshoot a performance bottleneck in a .NET application?
Key points:

Use profiling tools to locate slow code
Identify whether the issue is in architecture, code, or database
Apply targeted fixes while respecting constraints
Beetroot’s Tech Lead, Andriy S’omak, told us that he’d expect the candidate to answer the following:

“The first thing to do here is to find the bottleneck. So, we need to locate the performance issue. Now, let’s say we’ve done it. The next thing we need to do is determine why the problem arises. It can emerge due to multiple reasons: an architectural issue, poorly written code, or an incorrect data collection process when using the database, which is a common mistake among junior developers.

Once we’ve determined the nature of the problem, we try to fix it while considering the limitations we have to navigate. Numerous tools exist to work with these problems, such as profilers used for application analysis and optimization. Also, developers can identify areas of code that may be causing performance issues by measuring the execution time of various methods.”

Q17. How do you ensure smooth integration of a third-party API in .NET (and handle any potential issues)?
Key points:

Review API documentation and endpoints
Build an abstraction layer to reduce coupling
Handle errors and edge cases with logging and fallback logic
Preferable answer: “First, I would study the API documentation to understand its functionalities and endpoints. Afterward, I would develop a robust abstraction layer or wrapper around the API to shield the application from changes in the API’s implementation. 

Enforcing proper error handling and exception-logging mechanisms would be crucial for detecting and resolving issues promptly. 

Additionally, I would conduct comprehensive testing with different scenarios, including edge cases, and monitor API performance to ensure a smooth integration. Lastly, I would connect with the API provider and collaborate for resolution in case any issues arise.”

Q18. How would you approach troubleshooting and fixing a critical bug in a production .NET application with minimal user disruption?
Key points:

Gather all context from logs and user feedback
Isolate the issue in a hotfix branch
Test thoroughly and deploy during off-peak hours
Preferable answer: “My first step would be gathering all the bug-related information from error logs, crash reports, and user feedback. I would instantly create a hotfix branch to work on the issue separately from the main development branch. 

I would manage thorough testing to find the root cause of the issues, implement the fix with minimal code changes, and test the solution to prevent regressions. 

Afterward, I would deploy the hotfix to production during a low-traffic window to minimize user disruption and establish constant monitoring to ensure quick responses to potential issues.”

Q19. How do you lead and mentor junior developers on a complex .NET project?
Key points:

Break the project into manageable tasks
Assign based on strengths and development goals
Promote collaboration, code reviews, and continuous feedback
Preferable answer: “Firstly, I would define project objectives and break the plan down the tasks into smaller, more manageable units. Then, I would delegate the charges based on the individual developers’ strengths, level of expertise, and goals. 

As a leader, I believe creating a collaborative environment within the team is vital. Therefore, I would encourage open discussions and feedback and guide junior developers. Since my job involves ensuring my team maintains high coding standards, I would conduct regular check-ins to monitor progress, address issues and challenges, and offer support when needed.

Lastly, I would foster a culture of celebrating achievements and acknowledging individual contributions so that each team member feels valued and motivated to deliver excellent results.”

tailored tech training for teams - Beetroot Academy
Leadership & Team Fit: What to Ask a .NET Team Lead?
A senior .NET Developer isn’t just a skilled problem-solver but also a professional who takes on the role of a leader, a mentor, and a guardian of the company’s fundamental values. On top of delivering top results, they must nurture an environment of continuous growth and innovation. Therefore, we completed this list of interview questions for a lead developer with points that will help you evaluate the candidate’s leadership abilities and compatibility with your organization’s culture.

Q20. Describe a time you led a complex .NET project to success.
Key points:

Managed constraints like time or budget
Delegated tasks by expertise
Maintained transparent communication and support
Preferable answer: “In a previous role, I led a complex .NET project involving the development of a real-time data processing system. Our team had to deal with tight deadlines and a limited budget. As a senior developer, I was encouraged to take ownership of the project. 

Initially, I created a comprehensive project strategy and assigned tasks based on my teammates’ expertise. For me, being part of the team and growing together is essential. This approach helped me ensure everyone’s role on the project aligned with their personal goals.

Several unexpected technical difficulties threatened the project’s timeline during the development phase. However, we maintained a routine of daily stand-up meetings and regular brainstorming sessions to find suitable solutions. As a senior team member, I guided middle and junior developers whenever they needed my assistance. 

Sticking to transparent communication, open feedback, and strong collaboration helped us overcome obstacles and meet the stakeholders’ expectations.”

Q21. How do you handle any team conflicts during a .NET project? 
Key points:

Encourage open discussion
Validate differing viewpoints
Align on project goals and make decisions transparently
Preferable answer: “When working on one of the previous .NET projects, I faced resistance from team members who disagreed on the technology stack, which slowed our progress. As a team leader, I initiated an open and constructive dialogue about the concerns, providing everyone with a platform to voice their opinions. 

I listened to my teammates’ perspectives and acknowledged the merits of different approaches. Afterward, we conducted an in-depth analysis of the proposed solutions and their alignment with project goals. 

As a result, we reached a consensus on the best approach based on a combination of technical benefits and project requirements.”

Q22. Can you give an example of improving .NET development practices in a team?
Key points:

Introduced code review workflows
Promoted use of SOLID principles and design patterns
Facilitated internal knowledge-sharing sessions
Preferable answer: “With my previous team, I noticed that our .NET developers were experiencing challenges with code consistency and deployment efficiency. To fix this, I introduced a code review process using pull requests. By leveraging tools like GitHub and GitLab, we could review code changes systematically, providing feedback and catching potential issues early in the development cycle.

To improve code quality, I supported using design patterns and SOLID principles in our projects. I also organized internal workshops to share how the developers could apply these principles to real-world scenarios. These steps helped optimize team productivity and code quality and fostered collaboration and knowledge sharing.”

Q23. How do you promote continuous learning in a .NET team?
Key points:

Lead by example with learning initiatives
Organize internal workshops and tech talks
Encourage side projects and upskilling time
Preferable answer: “The team can only fully embrace the culture of knowledge-sharing and constant learning with the leaders doing it with them. That is why, in my previous role, I engaged in workshops, tech talks, and other educational events with the team. During these meetings, we discussed various .NET topics like best practices, new tools, emerging trends, industry challenges, etc.

I also engaged in a mentorship program, pairing junior developers with more experienced team members to facilitate knowledge transfer and skill development. Other lead developers and I also encouraged our teammates to dedicate a few hours a week to personal projects where they could experiment with new technologies and test new innovative approaches in .NET development.

In the future, I plan to try out the skill development incentivization approach, offer certification opportunities for team members, and provide resources for attending conferences, workshops, and online courses.”

Q24. How do you foster collaboration within a team with diverse skill levels? 
Key points:

Encourage pair programming and open discussions
Create structured yet informal knowledge-sharing spaces
Build a feedback-rich, inclusive culture
Preferable answer: “Fostering collaboration begins with clear communication and alignment on team goals. Pair programming and code reviews are practical ways for team members to learn from one another, boosting junior developers’ confidence while recognizing seniors’ expertise. 

Knowledge-sharing sessions should be structured yet rather informal — think of them as technical roundtables where team members can present insights, discuss challenges, and learn from each other’s experiences. The goal is to create a judgment-free zone that sparks genuine knowledge exchange. 

In my experience, the most successful approach is to recognize and leverage individual strengths and establish a culture where constructive feedback is the norm. Every team member feels their contributions are valued.

Balance is the key: guide without micromanaging, challenge without intimidation, and maintain a focus on team growth. When developers feel supported and see clear pathways for professional development, team performance naturally improves.”

Q25. Describe a cultural improvement you implemented in a dev team.
Key points:

Introduced structured feedback sessions
Created a safe space for discussion
Improved team cohesion and communication
Preferable answer: “During one project, I noticed limited feedback sharing, which affected team transparency and progress. To address this, I introduced bi-weekly feedback sessions focused on open discussions about challenges and collaboration, ensuring a structured and safe environment for sharing.

Initially, there was some hesitation, but I emphasized the purpose of the sessions as a constructive way to improve team dynamics, not to assign blame. The sessions had guidelines to structure the conversation, occasionally supplemented with anonymous surveys. 

Over time, these sessions became a trusted platform for team members to share their perspectives, celebrate successes, and address challenges collectively, boosting team morale. As a result, communication improved significantly, and the team worked more cohesively toward project goals.”


FAQ: What to Know When Hiring a Senior .NET Developer
What is the difference between a Middle .NET Developer and a Senior .NET Developer?

A Middle .NET Developer is typically focused on task execution and requires guidance for complex scenarios, whereas a Senior .NET Developer demonstrates a deeper understanding of architecture, independently solves complex problems, and contributes to team leadership. A senior developer is also expected to mentor juniors and actively shape project strategies, ensuring long-term success.

What frameworks should a Senior .NET Developer know?

A Senior .NET Developer should be proficient in frameworks such as ASP.NET Core, Entity Framework Core, Blazor, and .NET MAUI. Knowledge of testing frameworks like xUnit and integration with tools like SignalR for real-time capabilities is also crucial. Familiarity with DevOps tools and cloud services (e.g., Azure) enhances their versatility.

What are the key skills to prioritize when hiring a Senior .NET Developer?

Key skills include strong coding expertise in C# and .NET Core, architectural design proficiency, and hands-on experience with modern development methodologies like CI/CD. Effective communication, problem-solving, and leadership abilities, coupled with a proactive learning attitude, are equally important.

What questions should be asked to determine the cultural fit for a Senior Developer role?

Questions like, “How do you approach resolving conflicts within your team?” or “Can you describe a situation where you helped improve team dynamics?” can reveal alignment with company culture. Additionally, asking about their values and work philosophy ensures a deeper understanding of their compatibility with the organization.

How do you evaluate a Senior .NET Developer’s ability to mentor junior developers?

We assess mentorship skills by asking for specific examples where they supported a junior team member’s growth, looking for evidence of clear communication, structured learning plans, and the ability to provide constructive feedback. Successful mentors inspire confidence and foster an environment of continuous improvement within the team.

Basic .NET interview questions and answers
1.
What is the .NET Framework?

Hide Answer
The .NET Framework is a comprehensive software development platform developed by Microsoft. It includes a runtime environment called the Common Language Runtime (CLR) and a rich set of class libraries. It supports multiple programming languages such as C#, VB.NET, and F#, and offers features like memory management, security, and exception handling.

The .NET Framework is primarily used to create applications for Windows, but with the introduction of .NET Core and .NET 5, it can also be used to develop cross-platform applications as well.

2.
What is the Common Language Runtime (CLR)?

Hide Answer
The Common Language Runtime (CLR) is the execution environment provided by the .NET Framework. It manages the execution of .NET applications, providing services like memory management, code verification, security, garbage collection, and exception handling.

One of the key features of the CLR is the Just-In-Time (JIT) compiler. When a .NET application is executed, the CLR uses the JIT compiler to convert the Intermediate Language (IL) code—a low-level, platform-agnostic programming language—into native machine code specific to the system the application is running on. This process happens at runtime, hence the term "Just-In-Time". This allows .NET applications to be platform-independent until they are executed, providing a significant advantage in terms of portability and performance.

3.
Explain the difference between value types and reference types in .NET.

Hide Answer
In .NET, data types are divided into two categories: value types and reference types. The primary difference between them lies in how they store their data and how they are handled in memory.

Value types directly contain their data and are stored on the stack. They include primitive types such as int, bool, float, double, char, decimal, enum, and struct. When a value type is assigned to a new variable, a copy of the value is made. Therefore, changes made to one variable do not affect the other.

Image 12-07-23 at 1.08 PM.webp

Reference types, on the other hand, store a reference to the actual data, which is stored on the heap. They include types such as class, interface, delegate, string, and array. When a reference type is assigned to a new variable, the reference is copied, not the actual data. Therefore, changes made to one variable will affect the other, as they both point to the same data.

Image 12-07-23 at 1.08 PM (1).webp

Understanding the difference between value types and reference types is crucial for efficient memory management and performance optimization in .NET applications.

4.
What is the purpose of the System.IO namespace in .NET?

Hide Answer
The System.IO namespace in .NET is a fundamental part of the framework that provides classes and methods for handling input/output (I/O) operations. These operations include reading from and writing to files, data streams, and communication with devices like hard drives and network connections.

The System.IO namespace includes a variety of classes that allow developers to interact with the file system and handle data streams efficiently. Some of the key classes include:

File: Provides static methods for creating, copying, deleting, moving, and opening files.

Directory: Provides static methods for creating, moving, and enumerating through directories and subdirectories.

FileStream: Provides a stream for a file, supporting both synchronous and asynchronous read and write operations.

StreamReader and StreamWriter: These classes are for reading from and writing to character streams.

BinaryReader and BinaryWriter: These classes are for reading from and writing to binary streams.

5.
How does the concept of attributes facilitate metadata in .NET?

Hide Answer
Attributes in .NET are powerful constructs that allow developers to add metadata—additional descriptive information—to various elements in the code, such as classes, methods, properties, and more. This metadata can be accessed at runtime using reflection, allowing for dynamic and flexible programming.

Attributes have square brackets [] and are placed above the code elements they're related to. They can be utilised to control behaviour, provide additional information, or introduce extra functionality.

Image 12-07-23 at 1.11 PM.webp

In the example above, the [Serializable] attribute is used to indicate that the MyExampleClass class can be serialized, a capability often crucial for storage or network transmission.

In addition to using predefined attributes such as serialization, compilation, marshalling, etc., .NET allows creating custom attributes to meet specific needs. This makes attributes a versatile and integral part of .NET, promoting declarative programming and code readability.

6.
Explain the role of the ConfigurationManager class in .NET configuration management.

Hide Answer
In .NET, the ConfigurationManager class is a vital part of the System.Configuration namespace and plays a crucial role in managing configuration settings. It is commonly used to read application settings, connection strings, or other configurations from the App.config (for Windows Applications) or the Web.config (for Web Applications) files.

These configuration files store key-value pairs in XML format. By using the ConfigurationManager, developers can easily access this data without having to directly parse the XML file. The data is cached, so subsequent requests for the same value are highly efficient.

Here's a simple example of how ConfigurationManager could be used to read an application setting:

Image 12-07-23 at 1.13 PM.webp

In this example, "MyConnectionString" would be a key in the App.config or Web.config file.

However, it's important to note that the ConfigurationManager class only supports read operations for standard application settings. If you need to write or update configuration settings, you'll need to use the Configuration class instead. Furthermore, ConfigurationManager is not available in .NET Core and .NET 5+ projects and is replaced by the Configuration model provided by the Microsoft.Extensions.Configuration namespace.

7.
What is the difference between an exe and a dll file in .NET?

Hide Answer
An exe (executable) file contains an application's entry point and is intended to be executed directly. It represents a standalone program.

Image 12-07-23 at 1.15 PM.webp

On the other hand, a dll (dynamic-link library) file contains reusable code that can be referenced and used by multiple applications. It allows for code sharing and modular development.

Image 12-07-23 at 1.15 PM (1).webp

At runtime, the Common Language Runtime (CLR) loads and executes the exe's code and loads the corresponding dll into memory as needed when a call to a dll's functionality is made.

8.
What is the purpose of the System.Reflection namespace in .NET?

Hide Answer
The System.Reflection namespace provides classes and methods to inspect and manipulate metadata, types, and assemblies at runtime. It enables developers to dynamically load assemblies, create instances, invoke methods, and perform other reflection-related operations.

It's frequently used in scenarios where types are unknown at compile time, for e.g. in building plugin architectures, performing serialization/deserialization, implementing late binding, or performing type analysis and metadata visualization.

Here is a simple example of using Reflection to get information about a type:

Image 12-07-23 at 1.18 PM.webp

However, it's important to note that with great power comes great responsibility; due to its ability to uncover private data and call private methods, Reflection should be used judiciously and carefully to avoid compromising security or integrity.

9.
Explain the concept of serialization and deserialization in .NET.

Hide Answer
Serialization is the process of converting an object into a stream of bytes to store or transmit it. Deserialization is the reverse process of reconstructing the object from the serialized bytes.

These mechanisms allow objects to be persisted, transferred over a network, or shared between different parts of an application.

10.
What are the different types of exceptions in .NET and how are they handled?

Hide Answer
There are various types of exceptions in .NET, all of which derive from the base System.Exception class. Some commonly used exceptions include System.ApplicationException, System.NullReferenceException, System.IndexOutOfRangeException, System.DivideByZeroException, and more.

In .NET, exceptions are handled using try-catch-finally blocks:

try: The try block contains the code segment that may throw an exception.

catch: The catch block is used to capture and handle exceptions if they occur. You can have multiple catch blocks for a single try block to handle different exception types separately.

finally: The finally block is optional and contains the code segment that should be executed irrespective of an error occurring. This generally contains cleanup code.

Here's an example showing how to handle exceptions:

Image 12-07-23 at 1.19 PM.webp

11.
What are assemblies in .NET?

Hide Answer
Assemblies are the building blocks of .NET applications. They are self-contained units that contain compiled code (executable or library), metadata, and resources.

Each assembly contains a block of data called a 'manifest'. The manifest contains metadata about the assembly, such as:

Assembly name and version.
Security information.
Information about the types and resources in the assembly.
The list of referenced assemblies.
There are two types of assemblies in .NET:

Static or Process Assemblies: These are .exe or .dll files that are stored on disk and load directly into the memory when needed. Most assemblies are static.

Dynamic Assemblies: These assemblies are not saved to disk before execution. They are run directly from memory and are typically used for temporary tasks in the application.

Assemblies can be either private (used within a single application) or shared (used by multiple applications). They enable code reuse, versioning, and deployment.

12.
What is the Global Assembly Cache (GAC)?

Hide Answer
The Global Assembly Cache (GAC) is a central repository in the .NET Framework where shared assemblies are stored. It provides a way to store and share assemblies globally on a computer so that multiple applications can use them.

Assemblies must have a strong name—essentially a version number and a public key—to be stored in the GAC. This ensures the uniqueness of each assembly in the cache.

The GAC ensures versioning and allows different applications to reference the same assembly without maintaining multiple copies. Also, starting with .NET Core, the concept of the GAC has been removed to allow side-by-side installations of .NET versions and to minimize system-wide impact.

13.
What is the role of globalization and localization in .NET?

Hide Answer
Globalization refers to designing and developing applications that can adapt to different cultures, languages, and regions. Localization is the process of customizing an application to a specific culture or locale.

In .NET, globalization and localization are supported through features like resource files, satellite assemblies, and the CultureInfo class, allowing applications to display localized content and handle cultural differences.

14.
What is the Common Type System (CTS)?

Hide Answer
The Common Type System (CTS) is a set of rules and guidelines defined by the .NET Framework that ensure interoperability between different programming languages targeting the runtime.

It defines a common set of types, their behavior, and their representation in memory. The CTS allows objects to be used across different .NET languages without compatibility issues.

The CTS broadly classifies types into two categories:

Value Types: These include numeric data types, Boolean, char, date, time, etc. Value types directly store data and each variable has its own copy of the data.

Reference Types: These include class, interface, array, delegate, etc. Reference types store a reference to the location of the object in memory.

15.
Explain the concept of garbage collection in .NET.

Hide Answer
Garbage collection is an automatic memory management feature in the .NET Framework. It relieves developers from manual memory allocation and deallocation.

The garbage collector tracks objects in memory and periodically frees up memory occupied by objects that are no longer referenced. It ensures efficient memory usage and helps prevent memory leaks and access violations.

The garbage collector uses a generational approach to manage memory more efficiently. It categorizes objects into three generations:

Generation 0: This is the youngest generation that consists of short-lived objects, such as temporary variables.

Generation 1: This generation is used as a buffer between short-lived objects and long-lived objects.

Generation 2: This generation comprises long-lived objects. Collection occurs less frequently in this generation compared to the other generations.

It's important to note that while the garbage collector helps in managing memory, developers still need to ensure that they're writing optimized code and managing non-memory resources like file handles or database connections efficiently.

16.
What are the different data access technologies available in .NET?

Hide Answer
.NET Framework provides a variety of data access technologies for interacting with data sources such as databases and XML files. Here are some key ones:

ADO. NET

ADO.NET is a set of classes that provides data access services for .NET Framework applications. It lets applications interact with relational databases like SQL Server, Oracle, and MySQL using a connection-oriented model. ADO.NET supports various features, including connection management, query execution, data retrieval, and transaction handling.

Entity Framework (EF)

Entity Framework is an open-source Object-Relational Mapping (ORM) framework for .NET applications provided by Microsoft. It enables developers to work with data as objects and properties. EF allows for database manipulations (like CRUD operations) using .NET objects, and automatically transforms these operations to SQL queries. Entity Framework Core (EF Core) is a lightweight, extensible, and cross-platform version of EF.

LINQ to SQL

LINQ to SQL is a component of .NET Framework that specifically provides a LINQ-based solution for querying and manipulating SQL Server databases as strongly typed .NET objects. It's a simple ORM that maps SQL Server database tables to .NET classes, allowing developers to manipulate data directly in .NET.

17.
What is the difference between an interface and an abstract class in .NET?

Hide Answer
An interface defines a contract of methods, properties, and events that a class must implement. It allows multiple inheritance and provides a way to achieve polymorphism. It's important to note that interface members are implicitly public, and they can't contain any access modifiers.

Image 12-07-23 at 1.26 PM.webp

In this example, any class that implements IAnimal is obliged to provide an implementation of MakeSound.

An abstract class is a class that cannot be instantiated and serves as a base for other classes. It can contain abstract and non-abstract members. Unlike interfaces, abstract classes can provide default implementations and are useful when there is a common behavior shared among derived classes.

Image 12-07-23 at 1.26 PM (1).webp

In this example, classes that inherit Animal will have to provide an implementation of MakeSound. However, they will inherit the Eat method as it is.

18.
What is the role of the Common Intermediate Language (CIL) in the .NET Framework?

Hide Answer
The Common Intermediate Language (CIL), formerly known as Microsoft Intermediate Language (MSIL), plays a crucial role in the .NET Framework. When you compile your .NET source code, it is not directly converted into machine code. Instead, it is first translated into CIL, an intermediate language that is platform-agnostic. This means it can run on any operating system that supports .NET, making your .NET applications cross-platform.

The CIL code is a low-level, human-readable programming language that is closer to machine language than high-level languages like C# or VB.NET. During runtime, the .NET Framework's Common Language Runtime (CLR) takes this CIL code and compiles it into machine code using Just-In-Time (JIT) compilation.

19.
Define the concept of Just-In-Time (JIT) compilation in .NET.

Hide Answer
JIT compilation is a process in which the CLR compiles CIL code into machine code at runtime, just before it is executed. This helps in optimizing performance by translating CIL into instructions that the underlying hardware can execute directly.

20.
What are the different types of collections available in the System.Collections namespace?

Hide Answer
The System.Collections namespace provides various collection types in .NET including ArrayList, HashTable, SortedList, Stack, and Queue. These collections offer different ways to store and access data.

21.
What is the purpose of the System.Diagnostics namespace in .NET?

Hide Answer
The System.Diagnostics namespace provides classes for interacting with system processes, events, performance counters, and debugging functionality in .NET. It allows developers to control and monitor processes, gather performance data, handle exceptions, and perform debugging tasks.

Here are some of the key classes and their purposes:

Process: Allows you to start and stop system processes, and also provides access to process-specific information such as the process ID, priority, and the amount of memory being used.

EventLog: Enables you to read from and write to the event log, which is a vital tool for monitoring system and application events.

PerformanceCounter: Allows you to measure the performance of your application by monitoring system-defined or application-defined performance counters.

Debug and Trace: These classes provide a set of methods and properties that help you debug your code and trace the execution of your application.

Stopwatch: Provides a set of methods and properties that you can use to accurately measure elapsed time.

22.
Explain the concept of delegates and events in .NET.

Hide Answer
Delegates in .NET are reference types that hold references to methods with a specific signature. They allow methods to be treated as entities that can be assigned to variables or passed as arguments to other methods.

Image 12-07-23 at 1.31 PM.webp

Events, on the other hand, are a language construct built on top of delegates. They provide a way for objects to notify other objects when a particular action or state change occurs. The class that sends (or raises) the event is called the publisher and the classes that receive (or handle) the event are called subscribers. Events encapsulate delegates and provide a standard pattern for handling notifications in a decoupled and extensible manner.

Here's a simple example of an event:

Image 12-07-23 at 1.31 PM-2.webp

In this example, the Publisher class has an event ProcessCompleted that is raised when a process is completed. The Subscriber class subscribes to this event and provides a handler that is called when the event is raised. This allows the Subscriber to be notified whenever the Publisher completes a process, without the Publisher needing to know anything about the Subscriber. This is a fundamental part of the event-driven programming paradigm.

23.
What is the role of the System.Threading namespace in .NET multithreading?

Hide Answer
The System.Threading namespace in .NET provides classes and constructs for creating and managing multithreaded applications. It offers types such as Thread, ThreadPool, Mutex, Monitor, and Semaphore, which allow developers to control thread execution, synchronize access to shared resources, and coordinate communication between threads.

24.
What is the purpose of the using statement in C#? How does it relate to resource management?

Hide Answer
The using statement in C# is used for the automatic disposal of unmanaged resources, such as database connections, file streams, or network sockets, that implement the IDisposable interface. It ensures that the Dispose method of the resource is called when the code block within the using statement is exited, even in the presence of exceptions. It simplifies resource management and helps prevent resource leaks by providing a convenient syntax for working with disposable objects.

25.
Explain the concept of boxing and unboxing in .NET.

Hide Answer
Boxing is the process of converting a value type to the corresponding reference type representation on the heap, such as converting an integer to an object. Unboxing, on the other hand, is the reverse process of extracting the value type from the boxed object. Boxing is necessary when a value type needs to be treated as an object, for example, when passing value types to methods that accept object parameters. Unboxing allows retrieving the value from the boxed object to perform value-specific operations.

26.
What are extension methods in C# and how are they used?

Hide Answer
Extension methods in C# allow developers to add new methods to existing types without modifying their source code. They are defined as static methods within a static class, and the first parameter of the extension method specifies the type being extended, preceded by the 'this' keyword. Extension methods enable adding functionality to types without inheritance or modifying the type hierarchy, making it easier to extend third-party or framework classes.

27.
What is the purpose of the System.Net.Sockets namespace in .NET networking?

Hide Answer
The System.Net.Sockets namespace provides classes for network programming, particularly for creating client and server applications that communicate over TCP/IP or UDP protocols. It includes classes like TcpClient, TcpListener, UdpClient, and Socket, which enable developers to establish network connections, send and receive data, and handle network-related operations in .NET.

28.
Explain the concept of inversion of control (IoC). How is it achieved in .NET?

Hide Answer
Inversion of Control (IoC) is a design principle that promotes loose coupling and modularity by inverting the traditional flow of control in software systems. Instead of objects creating and managing their dependencies, IoC delegates the responsibility of creating and managing objects to a container or framework. In .NET, IoC is commonly achieved through frameworks like Dependency Injection (DI) containers, where dependencies are injected into objects by the container, enabling flexible configuration and easier testing.

29.
What is the difference between string and StringBuilder in .NET?

Hide Answer
In .NET, both string and StringBuilder are used to work with strings, but they behave differently.

A string is an immutable object. This means once a string object is created, its value cannot be changed. When you modify a string (for example, by concatenating it with another string), a new string object is created in memory to hold the new value. This can lead to inefficiency if you're performing a large number of string manipulations.

Image 12-07-23 at 1.36 PM.webp

On the other hand, StringBuilder is mutable. When you modify a StringBuilder object, the changes are made to the existing object itself, without creating a new one. This makes StringBuilder more efficient for scenarios where you need to perform extensive manipulations on a string.

Image 12-07-23 at 1.37 PM.webp

30.
Explain the concept of operator overloading in C# and provide an example.

Hide Answer
Operator overloading in C# allows developers to define and customize the behavior of operators for user-defined types. It provides the ability to redefine the behavior of operators such as +, -, *, /, ==, and != to work with custom types. For example, a developer can overload the + operator for a custom Vector class to define vector addition, allowing expressions like vector1 + vector2 to perform the desired addition operation based on the semantics of the Vector class.

Looking for remote developer job at US companies?
Work at Fortune 500 companies and fast-scaling startups from the comfort of your home

Apply Now
Intermediate .NET interview questions and answers
1.
How does the new .NET 5.0 platform unify the .NET Framework, .NET Core, and Xamarin?

Hide Answer
.NET 5.0 is a unified platform that brings together the best features and capabilities of the .NET Framework, .NET Core, and Xamarin. It provides a single framework for building applications across different platforms, including Windows, macOS, and Linux.

This unification simplifies development and enables sharing code and libraries seamlessly.

2.
What are the advantages of using the Managed Extensibility Framework (MEF) in .NET?

Hide Answer
The Managed Extensibility Framework (MEF) in .NET provides a powerful way to compose applications using loose coupling and extensibility. It simplifies the development of modular applications by enabling the automatic discovery and composition of parts (components).

MEF also facilitates the dynamic loading of extensions and promotes reusability and flexibility in application architecture.

3.
Explain the concept of code contracts and how they are used in .NET programming.

Hide Answer
Code contracts in .NET are a set of statements that define preconditions, postconditions, and invariants for methods and classes. They enable developers to specify the expectations and constraints of code elements.

Code contracts can be used to document assumptions, validate inputs/outputs, and improve code reliability by catching potential bugs early.

4.
What are the major features and improvements in ASP.NET Core 5.0 and later versions?

Hide Answer
ASP.NET Core 5.0 and later versions introduced several key features, including improved performance, enhanced gRPC support, a new minimal API approach, better integration with cloud platforms, simplified authentication and authorization, and improved support for HTTP/2 and WebSockets.

These updates enhance developer productivity and enable the creation of high-performance web applications.

5.
What is the role of the BackgroundWorker class in multithreaded programming in .NET?

Hide Answer
The BackgroundWorker class in .NET provides a convenient way to perform time-consuming operations on a separate thread without blocking the user interface (UI). It simplifies multithreaded programming by handling thread management, progress reporting, and cancellation.

The BackgroundWorker class provides the following key features:

DoWork Event: This is where the time-consuming operation is performed. This event handler runs on a separate worker thread.

ProgressChanged Event: This event is used to update the UI about the progress of the background operation. It runs on the main thread, so it's safe to interact with the UI from this event handler.

RunWorkerCompleted Event: This event is triggered when the background operation has finished, either successfully, due to an error, or because it was cancelled. Like ProgressChanged, this event handler runs on the main thread.

Cancellation Support: The BackgroundWorker class provides built-in support for cancellation. The CancelAsync method can be called to request cancellation, and the DoWork event handler can check the CancellationPending property to see if a cancellation has been requested.

Here's a simple example of how to use the BackgroundWorker class:

Image 12-07-23 at 1.42 PM.webp

By using the BackgroundWorker class, you can keep your UI responsive while performing time-consuming operations in the background.

6.
How does the Task Parallel Library (TPL) improve parallel programming in .NET?

Hide Answer
The Task Parallel Library (TPL) in .NET simplifies parallel programming by abstracting low-level threading details. It provides the Task type, which represents an asynchronous operation, and the Parallel class, which offers high-level constructs for parallel execution.

TPL automates task scheduling, load balancing, and synchronization, making it easier to write efficient and scalable parallel code.

7.
Explain the concept of reflection in .NET and its practical applications.

Hide Answer
Reflection in .NET allows for introspection of types, methods, properties, and other members at runtime. It provides the ability to examine and manipulate metadata, dynamically invoke methods, and create instances of types. This is done through the System.Reflection namespace.

Here's a simple example of using reflection to get information about a type:

Image 12-07-23 at 1.45 PM.webp

In this example, we're using reflection to get information about the string type, such as its full name, namespace, and whether it's public.

Reflection is commonly used in scenarios such as dependency injection, serialization, custom attribute processing, and building extensible frameworks. While reflection is a powerful tool, it's also worth noting that it can be slower than using statically-typed code, and can potentially expose sensitive information or methods if used improperly.

8.
What is the role of the System.Net namespace in .NET networking?

Hide Answer
The System.Net namespace in .NET provides classes for network programming, including handling sockets, TCP/IP communication, web requests, and more. It offers a comprehensive set of networking features that enable developers to create client-server applications, interact with web services, and perform network-related tasks efficiently.

9.
What is the purpose of the HttpClient class in .NET?

Hide Answer
The HttpClient class in .NET simplifies making HTTP requests and interacting with web services. It provides a high-level API for sending HTTP requests, handling responses, and working with JSON or XML data. HttpClient is intended to be instantiated once and reused throughout the life of an application, especially in server scenarios. This is because each HttpClient instance has its own connection pool, which can lead to socket exhaustion if many instances are created.

Here's a simple example of using HttpClient to send a GET request:


HttpClient supports various authentication mechanisms, response caching, and advanced features like HTTP/2 and WebSockets.

10.
Explain the concept of LINQ (Language Integrated Query) and its benefits in .NET.

Hide Answer
LINQ (Language Integrated Query) in .NET is a powerful query language that allows developers to perform data querying and manipulation operations directly within their code. It provides a unified, SQL-like syntax for querying various data sources, including relational databases (with LINQ to SQL or Entity Framework), XML documents (with LINQ to XML), and in-memory collections like arrays or lists.

Look at this example of using LINQ to filter and sort a list of integers:

Image 12-07-23 at 1.48 PM.webp

LINQ improves code readability, reduces errors, and enhances productivity by eliminating the need for explicit loops and conditionals.

11.
What is .NET Core and how does it differ from the .NET Framework?

Hide Answer
.NET Core is a cross-platform, open-source framework for building modern applications. It is a modular and lightweight version of the .NET Framework that supports Windows, macOS, and Linux.

.NET Core offers improved performance, a smaller footprint, and better support for containerization compared to the .NET Framework. It also provides a unified development model with ASP.NET Core for building web applications and services.

12.
What are the advantages of using Entity Framework Core over traditional ADO.NET?

Hide Answer
Entity Framework Core (EF Core) is an open-source, extensible, cross-platform, and lightweight version of Entity Framework, which is an Object-Relational Mapping (ORM) framework for .NET.
Some advantages of using Entity Framework Core over traditional ADO.NET include automatic mapping between database tables and .NET objects, improved productivity through higher-level abstractions, support for LINQ for querying data, and cross-database compatibility.

Entity Framework Core also provides features like change tracking, caching, and easy database migrations.

13.
Explain the concept of dependency injection and how it is used in .NET.

Hide Answer
Dependency injection is a design pattern and a technique used to achieve loose coupling between components in an application. It involves injecting dependent objects (dependencies) into a class instead of the class creating or managing them itself.

In .NET, the dependency injection pattern is widely used. Frameworks like ASP.NET Core provide built-in support for dependency injection through the built-in dependency injection (DI) container.

Here's a simple example of how dependency injection is used in an ASP.NET Core controller:

Image 12-07-23 at 1.51 PM.webp

In this example, the ProductsController requires an instance of ILogger to log messages. Instead of creating this instance itself, it declares a constructor parameter of type ILogger. The ASP.NET Core DI container automatically injects an instance of ILogger when it creates the ProductsController.

Dependency injection promotes modularity, testability, and maintainability by allowing easy swapping of dependencies and reducing the complexity of object creation and management.

14.
What are the different types of caching mechanisms available in .NET?

Hide Answer
.NET provides various caching mechanisms to improve application performance and reduce the load on resources. Some commonly used caching options in .NET include in-memory caching (using libraries like MemoryCache or the caching features provided by ASP.NET Core), distributed caching (using tools like Redis or Microsoft Azure Cache for Redis), and client-side caching (using technologies like browser caching or HTTP caching headers).

Each caching mechanism has its own purpose and is used based on the specific caching requirements of the application.

15.
How does ASP.NET MVC differ from ASP.NET Web Forms?

Hide Answer
ASP.NET MVC and ASP.NET Web Forms are two different approaches for building web applications in the .NET Framework.

ASP.NET MVC follows the Model-View-Controller (MVC) architectural pattern which promotes the separation of concerns and provides more control over the HTML markup. It is suitable for building highly customizable and testable web applications.

On the other hand, ASP.NET Web Forms follows a more event-driven and controls-based approach which simplifies rapid application development. It is suitable for building data-centric applications with a visual design surface. Each approach has its own strengths and is chosen based on the specific requirements of the project.

16.
What is the role of Web API in .NET?

Hide Answer
ASP.NET Web API is a framework for building HTTP-based services that can be consumed by various clients including web browsers, mobile devices, and desktop applications. It enables developers to build RESTful APIs using standard HTTP verbs (GET, POST, PUT, DELETE, etc.) and supports content negotiation, which allows clients to request data in different formats (JSON, XML, etc.).

Web API is widely used for building scalable and interoperable services that can be consumed by different platforms and devices.

17.
Explain the concept of asynchronous programming in .NET.

Hide Answer
Asynchronous programming in .NET allows applications to perform non-blocking operations and efficiently utilize system resources. It involves executing code asynchronously without blocking the calling thread, typically using features like async and await.

Asynchronous programming is beneficial for tasks that involve waiting for I/O operations such as accessing databases, making HTTP requests, or reading and writing files. By leveraging asynchronous programming, applications can improve responsiveness and scalability by allowing other tasks to run while waiting for operations to complete.

18.
What are the benefits of using ASP.NET Core for cross-platform development?

Hide Answer
ASP.NET Core is a cross-platform framework that allows developers to build web applications and services that can run on Windows, macOS, and Linux. Some benefits of using ASP.NET Core for cross-platform development include:

Flexibility: ASP.NET Core supports multiple platforms, enabling developers to target a broader range of devices and environments.

Performance: It is designed for high performance and scalability, offering faster response times and efficient resource utilization.

Modular and lightweight: ASP.NET Core is built on a modular architecture, allowing developers to include only the necessary components which results in a smaller deployment footprint.

Cross-platform tooling: ASP.NET Core integrates with popular development tools, including Visual Studio, Visual Studio Code, and command-line interfaces, allowing developers to work seamlessly across different platforms.

Open-source and community-driven: It is open-source and benefits from an active and supportive community, providing frequent updates, bug fixes, and community-driven contributions.

Cloud-readiness: It is designed to seamlessly integrate with cloud platforms and services which makes it easier to deploy and scale applications in cloud environments.

19.
What is the role of the .NET Standard and how does it enable code sharing?

Hide Answer
The .NET Standard is a formal specification that defines a common set of APIs that must be available on all .NET implementations. It serves as a bridge between different .NET platforms such as .NET Framework, .NET Core, and Xamarin.

By targeting the .NET Standard, developers can create libraries that can be used across multiple .NET platforms without the need for platform-specific code. The .NET Standard enables code sharing and simplifies the development process by providing a consistent set of APIs that are available across different platforms.

20.
Explain the concept of NuGet packages and their significance in .NET development.

Hide Answer
NuGet serves as the official .NET package manager, enabling developers to effortlessly discover, incorporate, update, and manage third-party tools and libraries within their projects. A NuGet package is essentially a single .nupkg extension ZIP file that houses compiled code (DLLs), additional files associated with the code, and a manifest detailing information such as the package's version number, authors, dependencies, and a description of the package's functionality.

Incorporating a NuGet package into your project can be accomplished through the NuGet Package Manager in Visual Studio, the dotnet CLI, or by manually inserting a reference in your project file. Once integrated, the functionality of the package becomes accessible within your project.

NuGet packages are stored in NuGet repositories, with the primary repository being the NuGet Gallery at nuget.org. However, packages can also be stored in private feeds or on your local file system.

NuGet packages offer a streamlined method for distributing and sharing reusable code. They play a crucial role in the .NET ecosystem by fostering code reuse, boosting productivity, managing dependencies, and providing developers with access to a broad array of community-contributed functionality and resources.

21.
What are the major features and benefits of Blazor WebAssembly in .NET 6.0?

Hide Answer
Blazor WebAssembly is a framework that allows developers to build client-side web applications using C# and .NET, running directly in the browser. Some of its major features include full-stack development with shared code, offline support, smaller download size, improved performance, and access to the entire ecosystem of .NET libraries. It enables developers to write rich and interactive web applications without requiring JavaScript expertise.

22.
How does the new record type in C# 9.0 improve code readability and immutability?

Hide Answer
The new record type in C# 9.0 provides a concise syntax for creating immutable data structures. A record is essentially a class that has value semantics and provides useful functionality out of the box.

Here's a simple example of a record:

public record Person(string FirstName, string LastName);

It eliminates the need to write boilerplate code for properties, equality checks, and hash code generation. Records are value-based by default, meaning they are compared by value rather than reference, which simplifies equality checks. They also have built-in value-based equality, pattern matching support, and can be deconstructed easily. These features improve code readability and reduce the chance of introducing bugs related to mutability.

23.
Explain the concept of parallel programming in .NET using the Parallel class.

Hide Answer
Parallel programming in .NET involves executing multiple tasks concurrently to take advantage of multi-core processors and improve performance. The Parallel class in .NET provides a high-level abstraction for parallel programming. It simplifies the process of dividing work into smaller tasks and distributing them across multiple threads.

For example:

Image 12-07-23 at 1.59 PM.webp

The Parallel class automatically manages the partitioning of work, load balancing, and synchronization. It also provides features like automatic load balancing, parallel loops, parallel LINQ, and parallel aggregation, making it easier to write efficient parallel code without explicitly managing threads.

24.
What are the different types of authentication and authorization mechanisms available in ASP.NET Core?

Hide Answer
ASP.NET Core supports various authentication and authorization mechanisms, including:

Cookie-based authentication: Uses encrypted cookies to authenticate users.

Token-based authentication: Uses JSON Web Tokens (JWT) or other token formats for authentication.

OpenID Connect: Implements authentication and single sign-on (SSO) using an identity provider (e.g., Azure AD, Google).

OAuth: Enables third-party authorization, allowing users to grant access to their data to external applications.

Windows Authentication: Authenticates users based on their Windows credentials.

These mechanisms provide flexibility and support for different scenarios, enabling secure access control in ASP.NET Core applications.

25.
How does the Entity Framework Core enable database migrations and schema evolution?

Hide Answer
Entity Framework Core (EF Core) simplifies the process of database migrations and schema evolution in .NET applications. It provides a code-first approach where developers define their entity models and relationships in code. EF Core can then automatically generate and execute SQL scripts to create or update the database schema based on the model changes.

For instance, if you have a Blog model like this:

Image 12-07-23 at 8.40 PM.webp

And you want to add a new property Name, you would modify your model like this:

Image 12-07-23 at 8.40 PM (1).webp

After making this change, you can use EF Core's migration commands like Add-Migration AddBlogName and Update-Database to generate and apply the SQL script that adds the Name column to the Blog table in the database.

EF Core tracks the state of the database schema and allows for incremental changes by generating migration scripts that apply only the necessary modifications. This enables smooth and controlled database schema evolution while maintaining data integrity.

26.
What is the purpose of the System.Net.Http namespace in .NET web API development?

Hide Answer
The System.Net.Http namespace provides classes for sending HTTP requests and receiving HTTP responses in web API development. It includes the HttpClient class, which simplifies the process of making HTTP calls to remote APIs. HttpClient supports various HTTP methods (GET, POST, PUT, DELETE, etc.) and provides features like request headers, content negotiation, and authentication. It is widely used for building HTTP clients and consuming RESTful APIs in .NET applications.

27.
Explain the concept of middleware in ASP.NET Core and its role in request processing.

Hide Answer
Middleware in ASP.NET Core is a component that sits between the server and the application and participates in request processing. Each middleware component can inspect, modify, or pass the request to the next middleware in the pipeline. Middleware components are registered in a specific order, and the request flows through them in that order.

For example, in the Startup.Configure method, you might add middleware components like this:

Image 12-07-23 at 8.44 PM.webp

It also allows developers to add cross-cutting concerns like authentication, logging, exception handling, routing, and caching to the request pipeline. Middleware provides a modular and extensible way to handle various aspects of request processing in ASP.NET Core applications.

28.
What are the benefits of using the MemoryCache class for caching in .NET?

Hide Answer
The MemoryCache class in .NET provides an in-memory caching mechanism that can significantly improve the performance of applications by reducing expensive computations or data retrievals. Some benefits of using MemoryCache include:

Fast access: Cached data is stored in memory, allowing for quick retrieval and avoiding costly operations.

Expiration policies: MemoryCache supports various expiration policies, such as absolute expiration or sliding expiration, to control cache lifetime.

Dependency tracking: Cache entries can be linked to other dependencies, such as database tables or files, allowing automatic cache invalidation when dependencies change.

Thread safety: MemoryCache handles concurrent access and synchronization, ensuring thread safety in multi-threaded scenarios. Using MemoryCache helps optimize application performance by caching frequently accessed or computed data, reducing the load on external resources.

29.
How does the Polly library simplify the implementation of resilience and fault handling in .NET applications?

Hide Answer
The Polly library is a resilient and transient-fault-handling framework for .NET applications. It simplifies the implementation of policies for handling faults, retries, timeouts, and circuit breaking. For example, you can define a retry policy with Polly like this:

Image 12-07-23 at 8.58 PM.webp

Polly provides a fluent API to define policies that wrap specific operations, such as HTTP requests or database calls. Policies can be configured to retry on specific exceptions, with exponential backoff or jittered delays. They can also handle timeouts, circuit breakers, and fallback strategies. Polly allows developers to encapsulate and centralize fault-handling logic, making it easier to write robust and resilient applications.

30.
Explain the concept of dependency inversion and how it is implemented in the SOLID principles.

Hide Answer
Dependency inversion is a principle in software design that promotes loose coupling and modularity. It states that high-level modules should not depend on low-level modules directly but instead, both should depend on abstractions. The SOLID principles, particularly the Dependency Inversion Principle (DIP), guide its implementation. DIP suggests that abstractions (interfaces or abstract classes) should define contracts, and concrete implementations should depend on these abstractions rather than other concrete implementations. This allows for easier substitution of implementations, improved testability, and reduced coupling between modules.

For example, consider an ILogger interface and a ConsoleLogger class that implements this interface:

Image 12-07-23 at 8.59 PM.webp

In .NET, dependency inversion is commonly achieved through the use of dependency injection, where dependencies are injected into classes rather than being instantiated within them, enabling inversion of control and decoupling of dependencies.

31.
Explain the concept of aspect-oriented programming (AOP) and its implementation in .NET using frameworks like PostSharp.

Hide Answer
Aspect-oriented programming (AOP) is a programming paradigm that allows modularizing cross-cutting concerns in software systems. Cross-cutting concerns are functionalities that span multiple modules or layers of an application, such as logging, caching, and exception handling. AOP separates these concerns from the core business logic, making the codebase more maintainable and reducing code duplication.

In .NET, frameworks like PostSharp provide support for AOP. PostSharp allows developers to define aspects, which are reusable code constructs that can be applied to target code elements, such as methods or properties.

For example, you can define a logging aspect like this:

Image 12-07-23 at 9.04 PM.webp

And apply it to a method like this:

Image 12-07-23 at 9.04 PM (1).webp

Aspects encapsulate the cross-cutting concerns and can be used to add functionality before, after, or around the target code. During the build process, PostSharp weaves the aspect code into the target code, effectively modifying its behavior without the need for explicit modifications in the source code.

32.
What are the advantages of using the System.ServiceModel namespace for building WCF (Windows Communication Foundation) services in .NET?

Hide Answer
The System.ServiceModel namespace in .NET provides a powerful infrastructure for building WCF services, offering several advantages:

WCF supports multiple protocols and encoding formats, enabling interoperability with various systems, including those based on SOAP, REST, and XML
It allows customization through behaviors, bindings, and contracts. Developers can extend the framework to meet specific requirements and integrate with existing systems seamlessly
WCF provides comprehensive security features, including message-level and transport-level security options. It supports various authentication and authorization mechanisms, ensuring secure communication between services and clients
It has reliable messaging, ensuring the reliable delivery of messages across distributed systems. It also offers transactional support, allowing for the coordination of distributed transactions
It supports various hosting options, including IIS, self-hosting, and Windows services. It provides scalability features like session management, concurrency control, and load balancing, enabling the development of highly scalable services
33.
Explain the concept of parallel LINQ (PLINQ) and how it improves query execution in .NET.

Hide Answer
Parallel LINQ (PLINQ) is an extension of LINQ (Language Integrated Query) in .NET that enables the execution of queries in parallel. PLINQ leverages the power of multi-core processors by automatically partitioning data and processing it concurrently across multiple threads, improving query execution performance.

With PLINQ, developers can use familiar LINQ syntax to express queries, and PLINQ automatically introduces parallelism when executing those queries against collections. PLINQ decomposes the data into smaller partitions and processes them in parallel, taking advantage of available CPU cores.

By using PLINQ, the query execution time can be significantly reduced for CPU-bound operations, such as filtering, sorting, and aggregating large data sets. However, it's essential to consider the characteristics of the data and the underlying hardware to ensure that parallel execution provides a performance benefit. Additionally, developers should be cautious when using PLINQ with non-thread-safe operations or when dealing with I/O-bound operations, as improper usage can lead to performance degradation or concurrency issues.

34.
What is the role of the System.Net.Mail namespace in .NET email communication?

Hide Answer
The System.Net.Mail namespace in .NET provides classes that enable sending email messages using the Simple Mail Transfer Protocol (SMTP). It offers functionality for creating, formatting and sending email messages from within a .NET application. This namespace includes classes such as SmtpClient, MailMessage, and Attachment, which allow developers to configure email settings, compose message bodies, add attachments, and send emails programmatically.

35.
How can you optimize database performance in .NET applications using techniques like indexing and query optimization?

Hide Answer
To optimize database performance in .NET applications:

Use indexing on frequently accessed columns and those used in WHERE, JOIN, and ORDER BY clauses
Optimize SQL queries by minimizing data retrieval, avoiding unnecessary JOIN operations, and retrieving only required columns
Employ stored procedures for frequently executed operations to benefit from pre-compilation and caching
Normalize the database schema to eliminate data redundancy
Efficiently manage database connections by opening them when needed and promptly closing them
Implement caching mechanisms to store frequently accessed data in memory
Consider using profiling and benchmarking tools to identify bottlenecks and guide optimization efforts
Looking for remote developer job at US companies?
Work at Fortune 500 companies and fast-scaling startups from the comfort of your home

Apply Now
Advanced .NET interview questions and answers
1.
What is the role of the Roslyn compiler platform in the .NET ecosystem?

Hide Answer
The Roslyn compiler platform, also known as the .NET Compiler Platform, plays a crucial role in the .NET ecosystem. It provides a set of open-source compilers and code analysis APIs for C# and Visual Basic .NET (VB.NET).

Roslyn enables developers to build custom code analysis tools, perform static code analysis, and create powerful refactoring and code generation tools. This is possible because Roslyn exposes the full structure of .NET code, including syntax trees, symbols, and semantic information, which were previously hidden inside the traditional .NET compilers.

For example, with Roslyn, developers can write a code analyzer that warns about potential coding issues directly in the code editor, even before the code is compiled. This can significantly improve code quality and maintainability.

Moreover, Roslyn is used by several Microsoft products, including Visual Studio, to provide features like IntelliSense, refactoring, and code fixes, demonstrating its importance in the .NET ecosystem.

2.
Explain the concept of the Actor model.

Hide Answer
The Actor model is a computational model designed for concurrent operations, where "actors" are considered the fundamental units of concurrent computation. Upon receiving a message, an actor can make independent decisions, create additional actors, dispatch more messages, and decide how to react to the subsequent message.

Each actor has its own private state and communicates with other actors exclusively through asynchronous message passing, eliminating the need for locks and reducing the complexity of concurrent and distributed systems. This model is especially useful in scenarios where a system needs to handle a large number of independent and isolated tasks that can run in parallel or asynchronously.

In the .NET ecosystem, the Akka.NET framework is a popular implementation of the Actor model. It provides tools and abstractions for building highly concurrent, distributed, and fault-tolerant event-driven applications. This makes it easier to handle complex distributed scenarios, such as coordinating multiple tasks, handling failures, and managing state across a distributed system.

3.
What are the major features and improvements introduced in .NET 6.0?

Hide Answer
.NET 6.0 introduced several significant features, including enhanced performance, improved cross-platform support, hot reload feature, new APIs for IoT and gaming scenarios, support for cloud-native development, and the integration of Blazor WebAssembly as a first-class citizen.

It also brings performance improvements to ASP.NET Core, Entity Framework Core, and other components of the .NET ecosystem.

4.
How does the Source Generators feature in C# 9.0 enhance developer productivity?

Hide Answer
Source Generators in C# 9.0 enables developers to generate source code dynamically during compilation. It allows for code generation based on existing code, metadata, or any other source of information.

It can automate repetitive tasks, reduce boilerplate code, and improve overall developer productivity by simplifying the creation of code that would otherwise be written manually. For instance, developers can use Source Generators to automatically implement interface methods, generate serialization/deserialization methods for data objects, or create proxy implementations for remote procedure calls.

By reducing the amount of manual coding, Source Generators can help to minimize human errors, ensure consistency across large codebases, and speed up the development process.

5.
What are the advantages of using the Memory and Span types in high-performance scenarios?

Hide Answer
Image 12-07-23 at 9.12 PM.webp

6.
Explain the concept of the Worker Service template in .NET and its use in background processing.

Hide Answer
The Worker Service template in .NET is a project template that simplifies the creation of long-running background services or worker processes. It provides a structured framework for building applications that perform background processing, such as scheduled tasks, message queue consumers, or event-driven processing. It handles the hosting and lifecycle management of these background services.

For example, you can create a Worker Service in .NET Core by using the Worker Service project template in Visual Studio or the worker template in the .NET Core CLI:

dotnet new worker -n MyWorkerService

This command creates a new Worker Service project named MyWorkerService. The generated project includes a Worker class that inherits from the BackgroundService class. You can override the ExecuteAsync method to define the background task that the worker service should perform:

Image 12-07-23 at 9.16 PM.webp

In this example, the Worker Service logs a message every second until it's stopped.

7.
What is the purpose of the System.Device.Gpio namespace in .NET IoT development?

Hide Answer
The System.Device.Gpio namespace in .NET provides classes and APIs for interacting with general-purpose input/output (GPIO) pins on devices, particularly in IoT (Internet of Things) scenarios. It allows developers to read from and write to GPIO pins, control external devices, and integrate hardware components into their .NET applications.

For example, you can use the GpioController class to control a GPIO pin on a Raspberry Pi:

Image 12-07-23 at 9.18 PM.webp

In this example, the GpioController class is used to open a GPIO pin, set its mode to output, write values to the pin to turn it on and off, and then close the pin.

8.
How does the new minimal APIs approach in ASP.NET Core 6.0 simplify web application development?

Hide Answer
ASP.NET Core 6.0 introduces a new minimal APIs approach, which simplifies the creation of lightweight and focused web applications. It enables developers to define routes, handle requests, and build web APIs with minimal ceremony and configuration.

For example, here's how you can define a simple HTTP GET endpoint using minimal APIs:

Image 12-07-23 at 9.20 PM.webp

In this example, the MapGet method maps the "/greet" URL to a handler that returns the string "Hello, World!". This is the only code required to create a fully functional web API with ASP.NET Core 6.0.

This approach reduces the amount of boilerplate code and allows for more concise and readable application code. It's particularly useful for microservices, small services, and prototyping, where you want to get up and running quickly with minimal overhead.

9.
What are the major improvements and features introduced in the latest version of Entity Framework Core 6.0?

Hide Answer
Entity Framework Core 6.0 brings several improvements and features including better performance, support for more database providers, enhanced LINQ translation, better query performance diagnostics, a more flexible DbContext API, improved event tracking, and easier migration management. It also introduces many community-driven features and enhancements based on user feedback.

10.
Explain the concept of server-side Blazor and client-side Blazor and their use cases.

Hide Answer
Blazor is a framework for building interactive web applications using C# and .NET. It offers two hosting models: Server-side Blazor and Client-side Blazor (also known as Blazor WebAssembly).

Server-side Blazor runs the application logic on the server. It uses SignalR, a real-time communication framework, to handle the communication between the client and the server. Every user interaction involves a round trip to the server, which updates the UI and sends the changes back to the client. This model is suitable for applications where immediate consistency is critical, and the client has a reliable connection to the server.

Client-side Blazor, on the other hand, runs the application logic directly in the browser using WebAssembly. The entire application is downloaded to the client's browser, and it can run offline once loaded. This model is ideal for scenarios where a rich, interactive user experience is desired, and the application needs to work offline or has low latency requirements.

For example, an internal business application that requires constant server interaction and real-time updates might be a good fit for server-side Blazor. On the other hand, a public-facing web app that needs to provide a fast, interactive user experience and work in low-connectivity environments would be a good candidate for client-side Blazor.

11.
What is the role of the .NET Core runtime (CoreCLR) in cross-platform development?

Hide Answer
The .NET Core runtime, also known as CoreCLR, is the execution engine that runs .NET Core applications. It provides the necessary infrastructure to execute managed code and perform tasks like Just-In-Time (JIT) compilation, garbage collection, and exception handling.

In cross-platform development, CoreCLR plays a crucial role by abstracting platform-specific details and providing a consistent runtime environment across different operating systems. It enables developers to build and run .NET Core applications on Windows, macOS, and Linux.

For example, a developer can write a .NET Core application on a Windows machine, using Visual Studio, and then deploy and run that same application on a Linux server or a macOS machine without needing to change the code. This is possible because CoreCLR provides a common runtime environment that ensures the application behaves consistently across different platforms.

This cross-platform capability of CoreCLR is one of the key features that make .NET Core a popular choice for building modern, cloud-based, and internet-connected applications

12.
Explain the concept of microservices and how they can be implemented in .NET.

Hide Answer
Microservices is an architectural style that structures an application as a collection of small, autonomous, and loosely coupled services. Each service corresponds to a specific business functionality and can be developed, deployed, and scaled independently. This approach promotes modularity, making the system easier to understand, develop, and test. It also enhances scalability since each service can be scaled individually based on demand. Furthermore, it improves fault isolation: if one service fails, the others can continue to function.

In the .NET ecosystem, microservices can be implemented using ASP.NET Core, a cross-platform, high-performance framework for building modern, cloud-based, internet-connected applications. ASP.NET Core provides features like lightweight APIs, support for containerization (which is crucial for microservices), service discovery mechanisms, and options for synchronous (like HTTP/REST) and asynchronous (like message queues or gRPC) communication between services.

For instance, consider an e-commerce application broken down into several microservices such as User Management, Product Catalog, Order Processing, and Payment. Each of these can be an ASP.NET Core Web API project, developed and deployed independently.

Image 12-07-23 at 9.23 PM.webp

In this code snippet, we have a simple UsersController in the User Management microservice. It uses dependency injection to get an instance of IUserService, which would contain the business logic for user-related operations.

For deploying and managing these microservices, .NET integrates well with containerization tools like Docker and orchestration platforms like Kubernetes, which handle service discovery, load balancing, and scaling.

13.
What are the major features and benefits of ASP.NET Core 3.1 and later versions?

Hide Answer
Some major features and benefits of ASP.NET Core 3.1 and later versions include:

Improved performance: ASP.NET Core 3.1 introduced several performance enhancements such as reduced memory allocations, improved JSON serialization, and faster routing.

Endpoint routing: Endpoint routing was introduced as a more flexible and efficient replacement for traditional MVC routing. It provides a unified way to define and handle HTTP endpoints in an application.

Blazor: ASP.NET Core 3.1 introduced server-side Blazor, a framework for building interactive web applications using C# and Razor syntax. It allows developers to write full-stack web applications using .NET.

SignalR: SignalR is a real-time communication library in ASP.NET Core. With version 3.1, SignalR introduced client-to-server streaming, improved client connections, and enhanced client APIs.

Health checks: ASP.NET Core 3.1 added built-in health checks, allowing applications to monitor the health of dependencies and report their status.

Azure SignalR Service Integration: ASP.NET Core 3.1 improved integration with Azure SignalR Service, enabling scalable real-time communication in cloud-based applications.

14.
How does the performance of ASP.NET Core compare to ASP.NET Framework?

Hide Answer
ASP.NET Core is designed to be lightweight and performant, offering several improvements over ASP.NET Framework. Some factors that contribute to the improved performance of ASP.NET Core include:

Startup time: ASP.NET Core has faster startup times compared to ASP.NET Framework, thanks to its modular and optimized design.

Middleware pipeline: ASP.NET Core introduced a more streamlined and flexible middleware pipeline, resulting in reduced processing overhead and improved performance.

Server implementations: It provides lightweight server implementations like Kestrel which are designed for high-performance scenarios and can handle a larger number of concurrent requests compared to traditional IIS-based hosting.

HTTP/2 support: It has built-in support for HTTP/2, enabling more efficient communication between clients and servers and improving performance.

Improved caching: ASP.NET Core offers enhanced caching capabilities, including response caching, distributed caching, and memory caching, which can significantly improve application performance.

15.
What is the role of the HostBuilder in .NET Core application startup?

Hide Answer
The HostBuilder is a fundamental component in .NET Core that simplifies the configuration and initialization of an application. It is responsible for building and configuring the application's host, which is the runtime environment that manages the application's lifetime and services.

The HostBuilder provides a convenient way to define and customize the application's startup process, including configuration loading, dependency injection setup, logging configuration, and more. It enables developers to easily configure and bootstrap the application, making it more modular and extensible.

16.
Explain the concept of Roslyn and its significance in .NET development.

Hide Answer
Roslyn, officially known as the .NET Compiler Platform, is an open-source set of compilers and code analysis APIs for C# and Visual Basic.NET (VB.NET) languages. It was a significant shift in the .NET ecosystem as it exposed the compilation process, which was traditionally a black box, to the developers.

Roslyn provides rich, code analysis APIs that allow developers to perform tasks like parsing the code into syntax trees, semantic analysis, and even generating new code. This opens up possibilities for creating powerful tools for static code analysis, code generation, refactoring, and more.

One of the key benefits of Roslyn is its ability to provide live code analyzers. These are tools that can analyze your code as you type in the IDE (like Visual Studio) and provide live feedback, suggestions, and even automated code fixes. This greatly enhances developer productivity and code quality.

For example, consider a simple Roslyn analyzer that warns when a public method doesn't have a summary comment:

Image 12-07-23 at 9.28 PM.webp

In this code snippet, we have a simple Roslyn analyzer that checks if a public method has a summary comment. If not, it reports a diagnostic warning.

Roslyn has indeed revolutionized .NET development by providing deep insights into the code, enabling developers to write better, more maintainable software

17.
What is the role of Entity Framework Core migrations and how are they used?

Hide Answer
Entity Framework Core migrations provide a mechanism for managing database schema changes over time. Migrations allow developers to define incremental changes to the database schema using code-first migrations or using a migrations-only approach.

Migrations create a history of changes in the form of migration files which can be automatically applied to the database to keep it in sync with the application's model. They enable developers to evolve the database schema while preserving existing data and ensuring consistency across different environments.

For example, if you have a Blog model and you add a new property AuthorName, you can create a migration to reflect this change in the database:

Image 12-07-23 at 9.52 PM.webp

You can add a migration using the Add-Migration command in the Package Manager Console (or dotnet ef migrations add in the command line):

Add-Migration AddAuthorToBlog

This will create a new migration file with the necessary commands to add the AuthorName column to the Blogs table.

18.
Explain the concept of asynchronous streams in C# 8.0 and later versions.

Hide Answer
Asynchronous streams, introduced in C# 8.0, allow developers to consume sequences of data asynchronously. An asynchronous stream is defined using the IAsyncEnumerable interface and can be iterated asynchronously using the await for each construct.

Here's a simple example of an asynchronous stream:

Image 12-07-23 at 10.30 PM.webp

In this example, GetNumbersAsync generates a sequence of numbers from 0 to 9, with a delay of one second between each number. This sequence can be consumed as follows:

Image 12-07-23 at 10.30 PM (1).webp

Here, await foreach is used to asynchronously iterate over the numbers as they are produced. This means that the method can do other work (or yield control back to its caller) in between the numbers, making it more responsive and efficient.

Asynchronous streams provide a convenient way to work with sequences of data that are produced asynchronously such as reading from a network stream or querying a database asynchronously. They enable developers to write more efficient and responsive code by processing data as it becomes available without blocking the calling thread.

19.
What are the major features and benefits of .NET 5 and later versions?

Hide Answer
Some major features and benefits of .NET 5 and later versions include:

Single unified platform: .NET 5 merged the capabilities of .NET Core, .NET Framework, and Xamarin into a single unified platform, making it easier to share code and target multiple platforms.

Improved performance: It introduced various performance improvements including better hardware intrinsics utilization, faster JSON serialization, and reduced memory allocations.

Native ARM64 support: It added native support for ARM64 architectures, allowing applications to run natively on devices like Raspberry Pi and ARM-based servers.

Improved container support: .NET 5 optimized container image sizes and startup times, making it more suitable for containerized applications.

Simplified Windows desktop development: .NET 5 introduced the Windows Desktop Packs, enabling developers to build Windows desktop applications using .NET 5 with support for Windows Forms and WPF.

C# 9 and F# 5: .NET 5 shipped with new language features and enhancements in C# 9 and F# 5 including record types, pattern matching improvements, and improved performance.

20.
Explain how to use the HttpClientFactory in .NET Core for creating HttpClient instances.

Hide Answer
HttpClientFactory is a factory class in .NET Core that helps with the creation and management of HttpClient instances. It addresses some of the known issues with the long-lived HttpClient instances, such as socket exhaustion, by providing a central location for naming and configuring logical HttpClient instances.

Here's an example of how to register and use an HttpClient using HttpClientFactory:

Image 12-07-23 at 10.33 PM.webp

In this example, an HttpClient is registered with the HttpClientFactory in the ConfigureServices method. This client is named "github" and is pre-configured with a base address and a default request header. Then, in the MyService class, an HttpClient instance is created using the CreateClient method of the IHttpClientFactory, passing the name of the client. This HttpClient instance can then be used to make HTTP requests.

21.
What are the major features and benefits of gRPC in .NET?

Hide Answer
gRPC (Google Remote Procedure Call) is a high-performance, open-source framework for making remote procedure calls (RPCs). It was developed by Google and is now part of the Cloud Native Computing Foundation. gRPC uses HTTP/2 for transport and Protocol Buffers (protobuf) as its interface definition language.

Here are some of the major features and benefits of gRPC, particularly in the context of .NET:

Cross-platform and multi-language support: gRPC works across different platforms and supports various programming languages, making it a good choice for polyglot microservices architectures.

Efficient communication: gRPC uses Protocol Buffers, a binary serialization format that is smaller and faster than text-based formats like JSON or XML. This leads to efficient and lightweight communication, which is particularly beneficial in network-constrained environments.

Bi-directional streaming: gRPC supports all four types of communication: unary (single request, single response), server streaming (single request, stream of responses), client streaming (stream of requests, single response), and bi-directional streaming (stream of requests, stream of responses). This makes it suitable for a wide range of use cases.

Contract-first API development****bold text: With gRPC, you define your service contract first using Protocol Buffers. From this contract, the gRPC tools generate both the client and server code, ensuring they are always in sync.

Integration with .NET: gRPC is natively supported in .NET Core 3.0 and later versions. It integrates well with the ASP.NET Core pipeline, configuration, logging, dependency injection, and more.

Here's a simple example of a gRPC service definition in protobuf:

Image 12-07-23 at 10.36 PM.webp

In this example, we define a Greeter service with a SayHello method that takes a HelloRequest and returns a HelloReply. The gRPC tools can generate the corresponding C# code for both the client and the server from this definition.

22.
Explain the concept of serverless computing and its integration with Azure Functions in .NET.

Hide Answer
Serverless computing is a cloud computing model where the cloud provider dynamically manages the allocation and provisioning of servers. A serverless solution allows developers to build and run applications without thinking about the underlying infrastructure. The cloud provider takes care of all the setup, capacity planning, and server management, allowing developers to focus solely on their code.

Azure Functions is a serverless computing service provided by Microsoft Azure. It allows developers to build and deploy small pieces of code (functions) in the cloud that are event-driven and can scale automatically. These functions can be written in various languages, including .NET languages like C#.

Azure Functions integrate seamlessly with .NET, providing a platform for executing .NET code in response to a variety of events or triggers, such as HTTP requests, timer schedules, Azure Queue messages, and more. This makes it a powerful tool for building microservices, APIs, data processing pipelines, and other event-driven applications.

Here's a simple example of an Azure Function written in C#:

Image 12-07-23 at 10.38 PM.webp

In this revised example, the GreetUser function is activated by an HTTP request and returns a greeting message. The function uses an ILogger to log information, showcasing the integration of Azure Functions with .NET's logging infrastructure.

One of the key benefits of Azure Functions and serverless computing is the cost-effectiveness. You only pay for the time your code is running, and Azure automatically scales your functions to meet demand. This makes Azure Functions a cost-effective choice for many types of workloads.

23.
What is the role of the TPL Dataflow library in building scalable and concurrent data processing pipelines?

Hide Answer
The Task Parallel Library (TPL) Dataflow library, part of .NET, provides a set of dataflow components to help create efficient, concurrent, and scalable data processing pipelines. These components are designed to handle the complexities of parallel and asynchronous programming, such as managing parallelism, buffering, synchronization, and error handling.

The TPL Dataflow library models dataflow operations as in-memory data transformations, known as dataflow blocks. These blocks can be composed together to form a dataflow pipeline. Each block can process data independently and concurrently with other blocks, which can significantly improve the throughput and responsiveness of your application.

Here's a simple example of a dataflow pipeline that reads lines from a file, transforms them, and then writes them to another file:

Image 12-07-23 at 10.46 PM.webp

24.
How does the System.Text.Json namespace in .NET compare to Newtonsoft.Json in terms of performance and features?

Hide Answer
The System.Text.Json namespace is a new JSON serialization library introduced in .NET Core and later versions. It offers similar features to Newtonsoft.Json, which is a widely used JSON framework in the .NET ecosystem. However, System.Text.Json is designed with performance as a primary focus, resulting in faster serialization and deserialization compared to Newtonsoft.Json. It also provides a more modern API, built-in support for asynchronous operations, and tighter integration with the .NET platform.

25.
Explain the concept of reactive programming and how it can be implemented using Reactive Extensions (Rx) in .NET.

Hide Answer
Reactive programming is an asynchronous programming paradigm that focuses on modeling and transforming streams of data or events. It allows developers to write code that reacts to changes in data and automatically propagates those changes through the system.

Reactive Extensions (Rx) is a library for composing asynchronous and event-based programs using observable sequences and LINQ-style query operators. It's available for various programming languages, including .NET (Rx.NET).

Rx.NET provides a set of types, like IObservable and IObserver, and a rich set of operators (like Map, Filter, Reduce, etc.) that allow you to create, transform, and subscribe to observable sequences. This makes it easier to handle complex asynchronous scenarios, such as coordinating multiple asynchronous operations, handling exceptions, managing resources, and more.

Here's a simple example of using Rx.NET to create and subscribe to an observable sequence:

Image 12-07-23 at 10.50 PM.webp

26.
What are the benefits of using the Actor model with frameworks like Orleans or Proto.Actor in distributed systems?

Hide Answer
The Actor model is a conceptual model for dealing with concurrent computation. It encapsulates state and behavior within "actors", which are independent entities that communicate exclusively by exchanging messages. This model is particularly useful for building distributed and concurrent systems.

Frameworks like Orleans and Proto.Actor implement the Actor model in .NET, providing a high-level, easy-to-use abstraction for building distributed systems. Here are some of the key benefits of using these frameworks:

Simplified concurrency management: In the Actor model, each actor processes messages one at a time, eliminating the need for locks or other synchronization mechanisms. This makes it easier to write safe, concurrent code.

Scalability: Actor-based frameworks can distribute actors across multiple nodes, allowing your system to scale out easily. They handle the complexities of actor placement, communication, and load balancing, allowing you to focus on your application logic.

Fault tolerance: Actor-based frameworks provide built-in mechanisms for dealing with failures, such as supervision hierarchies and automatic actor reactivation. This makes your system more resilient and easier to reason about in the face of failures.

Location transparency: Actors can communicate without knowing each other's physical location, making your system more flexible and easier to evolve.

Isolation: Each actor is isolated and runs independently of others, making your system more robust and easier to reason about. Changes in one actor's state do not affect the state of other actors.

Asynchrony: Actor-based frameworks are designed for asynchronous, non-blocking communication, which can lead to more efficient resource utilization and better system responsiveness.

27.
How does the Entity Framework Core enable query optimization and performance tuning?

Hide Answer
Entity Framework Core (EF Core) is a modern Object-Relational Mapping (ORM) framework for .NET. It provides several features and techniques to optimize queries and improve performance:

Query caching: EF Core automatically caches compiled query plans. This means that if you execute the same LINQ query multiple times, EF Core will only compile it once, improving performance.

Lazy loading: EF Core can delay loading related data until it's actually needed, reducing the amount of data retrieved from the database.

Eager loading: EF Core can also load related data as part of the initial query, reducing the number of round trips to the database.

Batch operations: EF Core can group multiple Create, Update, and Delete operations into a single round trip to the database, reducing network latency.

Raw SQL queries: While EF Core's LINQ provider can handle most query scenarios, there might be cases where writing raw SQL queries can lead to better performance. EF Core allows you to write raw SQL queries while still returning strongly typed results.

Indexing: EF Core supports database indexing, which can significantly speed up query performance. You can use the [Index] attribute or the HasIndex method in the Fluent API to create indexes.

Database-Specific optimizations: EF Core allows you to leverage database-specific features and optimizations. For example, you can use SQL Server's INCLUDE clause in indexes or PostgreSQL's VACUUM command for table optimization.

Here's an example of using raw SQL queries in EF Core:

Image 12-07-23 at 10.53 PM.webp

In this example, FromSqlRaw is used to execute a raw SQL query that retrieves all blogs. The results are returned as a list of Blog entities.

28.
Explain the concept of SIMD (Single Instruction, Multiple Data) in .NET and its significance in high-performance computing.

Hide Answer
SIMD (Single Instruction, Multiple Data) is a technique in computing where a single instruction operates on multiple data elements simultaneously. In .NET, SIMD support is provided through the System.Numerics namespace. It allows developers to leverage hardware-level parallelism, such as vectorized instructions in CPUs, to perform computations on large sets of data efficiently. SIMD is especially significant in high-performance computing scenarios, such as numerical simulations, image processing, and data-intensive algorithms, where it can greatly improve computational throughput and reduce processing time.

For example, consider the following code snippet that uses SIMD operations to add two arrays of integers:

Image 12-07-23 at 10.56 PM.webp

In this example, Vector.Count elements are processed at once, which can be significantly faster than processing each element individually.

29.
What are the advantages of using Docker containers for deploying .NET applications?

Hide Answer
Docker containers provide a lightweight and portable runtime environment for deploying applications. Docker offers several advantages, including:

Consistent deployment across different environments: A Docker container bundles the .NET application and its dependencies into a single unit, ensuring it works the same in every environment — whether it's a developer's machine, a test environment, or a cloud infrastructure.

Isolation of dependencies: Each .NET application in a Docker container runs in its own isolated environment. This prevents conflicts between different versions of dependencies used in other applications.

Improved scalability: Docker containers can be quickly started, stopped, and replicated as per the demand. This adaptability enables .NET applications to handle varying traffic loads efficiently.

Easy versioning and rollback: Docker image versions facilitate easy application versioning. If a new version has an issue, you can quickly rollback to a previous healthy version.

Simplified deployment automation: With Docker, you can automate the creation of containerized .NET applications by writing a Dockerfile. This feeds into a CI/CD pipeline, simplifying deployment automation.

Efficient resource utilization: Docker containers share the host system OS kernel, making them far less resource-intensive compared to running full-fledged virtual machines.

Facilitates microservices architecture: Docker containers are great for the microservices architecture because they enable each service (like a .NET service) to run in its own container, aiding the independent development, deployment, and scaling of each service.

In conclusion, Docker containers improve the manageability and performance of .NET applications, especially in complex distributed systems and microservices-based architectures.

30.
How does the Azure DevOps platform facilitate CI/CD (Continuous Integration/Continuous Deployment) for .NET projects?

Hide Answer
Azure DevOps is a cloud-based platform that provides a set of tools and services to support the entire development lifecycle, including CI/CD for .NET projects. It enables developers to automate build and release processes, ensuring continuous integration and deployment.

Azure DevOps provides features such as:

Source code version control: Using Azure Repos, you can manage your code with Git or Team Foundation Version Control (TFVC).

Build pipelines: You can set up automated builds for your .NET projects. The build pipeline compiles your code, runs tests, and produces artifacts ready for deployment.

Release pipelines: These allow you to automate the deployment of your .NET applications to various environments, such as development, staging, and production. You can also define approval processes for deployments.

Artifact management: Azure Artifacts lets you share packages, such as NuGet packages, across your team.

Testing capabilities: Azure Test Plans provide a platform for planning, tracking, and assessing your testing efforts.

Integration with Azure: You can easily deploy your .NET applications to Azure services like Azure App Service, Azure Functions, or Azure Kubernetes Service (AKS).

By providing a unified platform for collaboration, tracking work items, managing code repositories, and orchestrating the build and release pipelines, Azure DevOps simplifies the process of achieving seamless CI/CD for .NET projects.

31.
What are the advantages of using the System.Memory namespace and the "Span < T >" type in high-performance scenarios?

Hide Answer
The System.Memory namespace and the Span type provide several advantages in high-performance scenarios:

Reduced memory allocations: Span < T > allows direct access to memory regions without the need for intermediate copies, reducing the number of memory allocations and improving performance.

Efficient data processing: Span < T > enables efficient data processing by providing methods for slicing, indexing, and iterating over memory regions without the need for creating new objects or arrays.

For example, you can slice a Span < T > like this:

Image 12-07-23 at 11.11 PM.webp

Improved interoperability: Span < T > facilitates interoperability with unmanaged code and other memory-oriented APIs by providing a safe and efficient way to work with raw memory.
Enhanced performance in concurrent scenarios: Span < T > supports concurrent access through its struct-like nature, eliminating the need for locks or synchronization mechanisms.

32.
Explain the concept of cloud-native development in .NET and its relationship with containers and orchestration platforms like Kubernetes.

Hide Answer
Cloud-native development in .NET refers to building applications that are designed to take full advantage of cloud computing capabilities. It involves using modern development practices and architectural patterns to create scalable, resilient, and highly available applications. Containers and orchestration platforms like Kubernetes play a crucial role in cloud-native development. Containers, such as Docker, offer a lightweight, isolated environment to package and deploy applications along with their dependencies.

They offer portability and isolation, making it easier to deploy applications across different environments. Orchestration platforms like Kubernetes provide tools for automating the deployment, scaling, and management of containerized applications. They handle tasks such as load balancing, scaling, self-healing, and service discovery, enabling developers to focus on application logic rather than infrastructure management.

In the .NET ecosystem, tools and frameworks like .NET Core, ASP.NET Core, and Entity Framework Core are designed with cloud-native development in mind. They support containerization and can be easily integrated with Kubernetes. Additionally, the Steeltoe library provides .NET developers with cloud-native tools and frameworks to build robust, scalable applications that can be easily managed and monitored.

33.
What are the different techniques available for distributed caching in .NET and their trade-offs?

Hide Answer
In .NET, there are several techniques available for distributed caching, each with its own trade-offs:

In-memory caching: Caching data in-memory provides the fastest access times but is limited to a single server or instance. It is suitable for scenarios where data needs to be cached within a single application or instance.

Redis caching: Redis is an open-source, in-memory data store that provides distributed caching capabilities. It allows multiple instances of an application to share the same cache, providing scalability and high availability. However, it introduces network latency and requires additional infrastructure.

Distributed caching frameworks: .NET provides frameworks like Microsoft.Extensions.Caching.Distributed and Microsoft.ApplicationInsights.AspNetCore for distributed caching. These frameworks allow caching data across multiple servers or instances by using a distributed cache provider such as Redis or SQL Server. They offer a balance between performance and scalability but require additional configuration and infrastructure setup.

34.
Explain the concept of quantum computing and its potential impact on the future of .NET development.

Hide Answer
Quantum computing is an emerging field of computing that leverages the principles of quantum mechanics to perform complex computations. In contrast to traditional computers that use bits to represent information as 0s and 1s, quantum computers use quantum bits, or qubits, which can represent multiple states simultaneously due to quantum superposition and entanglement. This enables quantum computers to solve certain problems much faster than classical computers.

As quantum computing becomes more accessible, libraries and frameworks specific to .NET may emerge, enabling developers to write quantum programs using familiar languages and tools. Quantum computing is not intended to replace classical computing but to complement it. .NET developers may need to integrate classical and quantum systems, creating hybrid applications that leverage the strengths of both paradigms.

35.
What are the benefits of using machine learning and AI frameworks like ML.NET or TensorFlow.NET in .NET applications?

Hide Answer
Using machine learning (ML) and AI frameworks like ML.NET or TensorFlow.NET in .NET applications offer several benefits:

Simplified development: These frameworks provide high-level APIs and abstractions that simplify the development of machine learning and AI models.

Familiarity with language and tools: Developers can leverage their existing knowledge of C# and .NET tooling to build ML and AI models.

Integration with existing .NET ecosystem: ML.NET and TensorFlow.NET integrate seamlessly with the existing .NET ecosystem, allowing developers to leverage libraries, frameworks, and services for data access, processing, and visualization.

Performance and scalability: These frameworks provide optimizations for efficient computation and can leverage hardware accelerators like GPUs.

Community and support: Both ML.NET and TensorFlow.NET have active communities and extensive documentation. Developers can benefit from the wealth of resources, tutorials, and examples shared by the community.

How does the .NET framework work?

.NET framework-based applications that are written in supportive languages like C#, F#, or Visual basic are compiled to Common Intermediate Language (CIL).
Compiled code is stored in the form of an assembly file that has a .dll or .exe file extension.
When the .NET application runs, Common Language Runtime (CLR) takes the assembly file and converts the CIL into machine code with the help of the Just In Time(JIT) compiler.
Now, this machine code can execute on the specific architecture of the computer it is running on.

Explain about major components of the .NET framework.

The major components .NET framework are given below:

Common Language Runtime(CLR):
It is an execution engine that runs the code and provides services that make the development process easier.
Services provided by CLR are memory management, garbage collection, type safety, exception handling, security, and thread management. It also makes it easier for designing the applications and components whose objects interact across the languages.
The programs written for the .NET Framework are executed by the CLR regardless of programming language. Every .NET Framework version is having CLR.
Framework Class Library(FCL):
It has pre-defined methods and properties to implement common and complex functions that can be used by .NET applications. It will also provide types for dates, strings, numbers, etc.
This class library includes APIs for database connection, file reading and writing, drawing, etc.
Base Class Library(BCL):
The Base Class Library(BCL) has a huge collection of libraries features and functions that are helpful in implementing various programming languages such as C#, F#, Visual C++, etc., in the .NET Framework.
BCL is divided into two parts. They are:
User-defined class library: It includes Assemblies.
Assembly: A .NET assembly is considered as the major building block of the .NET Framework. An assembly in the CLI(Common Language Infrastructure) is a logical unit of code, which is used for security, deployment, and versioning. Assembly can be defined in two forms namely Dynamic Link Library(.dll) and executable(.exe) files.
When compilation of the .NET program takes place, metadata with Microsoft Intermediate Language(MSIL) will be generated and will be stored in a file called Assembly.
Predefined class library: It contains namespace.
Namespace: It is the collection of pre-defined methods and classes that are present in the .Net Framework. A namespace can be added to a .NET program with the help of “using system”, where using represents a keyword and system represents a namespace.
Common Type System(CTS):
CTS specifies a standard that will mention which type of data and value can be defined and managed in memory during runtime.
It will make sure that programming data defined in different languages should interact with each other for sharing the information. For example, in VB.NET we define datatype as integer, while in C# we define int as a data type.
It can be used to prevent data loss when you are trying to transfer data from a type in one language to its equivalent type in another language.
Common Language Specification (CLS):
Common Language Specification (CLS) is a subset of CTS and defines a set of rules and regulations to be followed by every .NET Framework’s language.
A CLS will support inter-operability or cross-language integration, which means it provides a common platform for interacting and sharing information. For example, every programming language(C#, F#, VB .Net, etc.) under the .NET framework has its own syntax. So when statements belonging to different languages get executed, a common platform will be provided by the CLS to interact and share the information.

3. What is an EXE and a DLL?

EXE and DLLs are assembly executable modules.

EXE is an executable file that runs the application for which it is designed. An EXE is produced when we build an application. Therefore the assemblies are loaded directly when we run an EXE. However, an EXE cannot be shared with the other applications.

Dynamic Link Library (DLL) is a library that consists of code that needs to be hidden. The code is encapsulated inside this library. An application can consist of many DLLs which can be shared with the other programs and applications.

What is CTS?

CTS stands for Common Type System. It follows a set of structured rules according to which a data type should be declared and used in the program code. It is used to describe all the data types that are going to be used in the application.

We can create our own classes and functions by following the rules in the CTS. It helps in calling the data type declared in one programming language by other programming languages.

Explain CLS

Common Language Specification (CLS) helps the application developers to use the components that are inter-language compatible with certain rules that come with CLS. It also helps in reusing the code among all of the .NET-compatible languages.

What is JIT?

JIT stands for Just In Time. It is a compiler that converts the intermediate code into the native language during the execution.

What is the difference between int and Int32?

There is no difference between int and Int32. Int32 is a type provided by the .NET framework class whereas int is an alias name for Int32 in the C# programming language.

Explain the differences between value type and reference type.

The main differences between value type and reference type are given below:

A Value Type holds the actual data directly within the memory location and a reference type contains a pointer which consists of the address of another memory location that holds the actual data.
Value type stores its contents on the stack memory and reference type stores its contents on the heap memory.
Assigning a value type variable to another variable will copy the value directly and assigning a reference variable to another doesn’t copy the value, instead, it creates a second copy of the reference.
Predefined data types, structures, enums are examples of value types. Classes, Objects, Arrays, Indexers, Interfaces, etc are examples of reference types.

9. What is the difference between managed and unmanaged code?

The main difference between managed and unmanaged code is listed below:

Explain Microsoft Intermediate Language

MSIL is the Microsoft Intermediate Language, which provides instructions for calling methods, memory handling, storing and initializing values, exception handling, and so on.

The instructions provided by MSIL are platform-independent and are generated by the language-specific compiler from the source code. JIT compiler compiles the MSIL into machine code based on the requirement.

What is an assembly?

An assembly is a file that is automatically generated by the compiler which consists of a collection of types and resources that are built to work together and form a logical unit of functionality. We can also say, assembly is a compiled code and logical unit of code.

Assemblies are implemented in the form of executable (.exe) or dynamic link library (.dll) files.

Is ASP.NET different from ASP? If yes, explain how?

Yes, ASP.NET and ASP(Active Server Pages) both are different. Let’s check how they are different from each other.

ASP.NET uses .NET languages such as C# and VB.NET, which are compiled to Microsoft Intermediate Language (MSIL). ASP uses VBScript. ASP code is interpreted during the execution.
ASP.NET which is developed by Microsoft is used to create dynamic web applications while ASP is Microsoft’s server-side technology used to create web pages.
ASP.NET is fully object-oriented but ASP is partially object-oriented.
ASP.NET has full XML Support for easy data exchange whereas ASP has no built-in support for XML.
ASP.NET uses the ADO.NET technology to connect and work with databases. ASP uses ADO technology.

Explain role-based security in .NET

Role-based security is used to implement security measures in .NET, based on the roles assigned to the users in the organization. In the organization, authorization of users is done based on their roles.

For example, windows have role-based access like administrators, users, and guests

14. Explain the different types of assembly.
Assemblies are classified into 2 types. They are:

Private Assembly:

It is accessible only to the application.
We need to copy this private assembly, separately in all application folders where we want to use that assembly. Without copying, we cannot access the private assembly.
It requires to be installed in the installation directory of the application.
Shared or Public Assembly:

It can be shared by multiple applications.
Public assembly does not require copying separately into all application folders. Only one copy of public assembly is required at the system level, we can use the same copy by multiple applications.
It is installed in the Global Assembly Cache(GAC).

What is the order of the events in a page life cycle?

There are eight events as given below that take place in an order to successfully render a page:

Page_PreInit
Page_Init
Page_InitComplete
Page_PreLoad
Page_Load
Page_LoadComplete
Page_PreRender
Render

16. What is a garbage collector?
Garbage collector frees the unused code objects in the memory. The memory heap is partitioned into 3 generations:

Generation 0: It holds short-lived objects.
Generation 1: It stores medium-lived objects.
Generation 2: This is for long-lived objects.
Collection of garbage refers to checking for objects in the generations of the managed heap that are no longer being used by the application. It also performs the necessary operations to reclaim their memory. The garbage collector must perform a collection in order to free some memory space.

During the garbage collection process:

The list of live objects is recognized.
References are updated for the compacted objects.
The memory space occupied by dead objects is recollected. The remaining objects are moved to an older segment.
System.GC.Collect() method is used to perform garbage collection in .NET.

17. What is caching?
Caching means storing the data temporarily in the memory so that the data can be easily accessed from the memory by an application instead of searching for it in the original location. It increases the speed and performance efficiency of an application.

There are three types of caching:

Page caching
Data caching
Fragment caching

What is cross-page posting?

Whenever we click on a submit button on a webpage, the data is stored on the same page. But if the data is stored on a different page and linked to the current one, then it is known as a cross-page posting. Cross-page posting is achieved by POSTBACKURL property.

To get the values that are posted on this page to which the page has been posted, the FindControl method can be used.

What is a delegate in .NET?

A delegate is a .NET object which defines a method signature and it can pass a function as a parameter.

Delegate always points to a method that matches its specific signature. Users can encapsulate the reference of a method in a delegate object.

When we pass the delegate object in a program, it will call the referenced method. To create a custom event in a class, we can make use of delegate.

What is MIME in .NET?

MIME stands for Multipurpose Internet Mail Extensions. It is the extension of the e-mail protocol which lets users use the protocol to exchange files over emails easily.
Servers insert the MIME header at the beginning of the web transmission to denote that it is a MIME transaction.
Then the clients use this header to select an appropriate ‘player’ for the type of data that the header indicates. Some of these players are built into the web browser.

What is the use of manifest in the .NET framework?

Manifest stores the metadata of the assembly. It contains metadata which is required for many things as given below:
Assembly version information.
Scope checking of the assembly.
Reference validation to classes.
Security identification.

Explain different types of cookies available in ASP.NET?

Two types of cookies are available in ASP.NET. They are:
Session Cookie: It resides on the client machine for a single session and is valid until the user logs out.
Persistent Cookie: It resides on the user machine for a period specified for its expiry. It may be an hour, a day, a month, or never.

What is the meaning of CAS in .NET?

Code Access Security(CAS) is necessary to prevent unauthorized access to programs and resources in the runtime. It is designed to solve the issues faced when obtaining code from external sources, which may contain bugs and vulnerabilities that make the user’s system vulnerable.
CAS gives limited access to code to perform only certain operations instead of providing all at a given point in time. CAS constructs a part of the native .NET security architecture.

What are the types of memories supported in the .NET framework?
Two types of memories are present in .NET. They are:
Stack: Stack is a stored-value type that keeps track of each executing thread and its location. It is used for static memory allocation.
Heap: Heap is a stored reference type that keeps track of the more precise objects or data. It is used for dynamic memory allocation.

Explain localization and globalization.

Localization is the process of customizing our application to behave as per the current culture and locale.
Globalization is the process of designing the application so that it can be used by users from across the globe by supporting multiple languages.

What are the parameters that control the connection pooling behaviors?

There are 4 parameters that control the connection pooling behaviours. They are:
Connect Timeout
Min Pool Size
Max Pool Size
Pooling

What are MDI and SDI?

MDI (Multiple Document Interface): An MDI allows you to open multiple windows, it will have one parent window and as many child windows. The components are shared from the parent window like toolbar, menubar, etc.
SDI (Single Document Interface): SDI opens each document in a separate window. Each window has its own components like a toolbar, menubar, etc. Therefore it is not constrained to the parent window.



What’s the difference between a class and an interface?
What’s the difference between an abstract class and an interface?
What is the difference between a class and a struct?
Describe the difference between overriding and overloading in C#
Can a structure have virtual methods?
Explain the difference between GET, POST and PATCH in HTTP APIs
Is there any limit go the GET request’s length? If yes, where is such a limit configured? What about POST?
How would you secure your WebAPI?
What is the flow of generating, obtaining and passing JWT token in a .NET application?
When using JWT tokens in an API, how does the server ensure it talks to a legitimate client?
Is the API security compromised when the user’s JWT token is stolen?
What is the difference between IEnumerable and IQueryable in the context of Entity Framework?
What are the dependency injection scopes in ASP.NET?
How can dependency injection be helpful in testing?
What is IHttpClientFactory used for and which issues does it help to eliminate?
What is wrong with creating HttpClient manually?
What would you choose for implementing communication between microservices: REST or a message broker? What would you consider when making such a choice?
What would you do as a backend developer when frontend developers are blocked because they are missing an API endpoint from your side?
What is the size of stack in .NET?
What are value and reference types? What is the difference between them? Give a practical example
Which objects go on Large Object Heap?
What is JIT compilation?
Describe the strategies for delivering a message in a message queue
When is Dispose method called on a class implementing IDisposable?
What is the difference between Dispose and Finalize?
What is SOLID? Can you elaborate on each SOLID acronym?
You are assigned a task to process a large piece of text by inserting and changing many parts of it. Which of the following would you use for that task: string, StringBuilder, StringWriter or StringReader?
What’s the difference between Repository and Query Object patterns?
What is the Saga pattern?
What is CQRS and in which scenarios may it be beneficial?
What is the difference between an event and a command (like in CQRS)?
What are the advantages and disadvantages of using a Repository pattern?
What is Clean Architecture? Who invented it and how it works?
What is Onion Architecture?
What is Modular Monolith?
Describe how you realized authentication & authorization in your last project
Explain your last project’s architecture
Explain a challenging task you faced in your last project and how you solved it
How would you approach diagnosing a performance issue on production, which cannot be reproduced locally?
Explain the “event-based architecture” you implemented in your last project. This was something I explicitly mentioned in my resume, so the advice is: prepare to elaborate on every experience you mention in your resume 🙂
How would you choose tech stack for a new full stack web application (backend + frontend)? Describe your decision-making process: what would you take into consideration when choosing a tech stack?
How would you decide whether to use an already-existing component (e.g. a library) vs implementing your own?

What is C#?

C sharp is an object-oriented programming language developed by Microsoft. C# is used with the .NET framework for creating websites, applications, and games. C# has a varied reasons for being popular:
Comparatively easier: Starting with C# is termed comparatively easier than other programming languages
Wider use of development: Using C#, you are prone to create web applications or gaming apps. C# has some fantastic features like automatic garbage collection, interfaces, etc. which help build better applications.
Larger target audience: Collaboration with Microsoft provides an edge to the applications created using C# since it would have a wider target audience.
Since C# is such a widely used programming language, a plethora of big and small organizations base their products using it. So, prepare yourself with basic and advanced level C# questions to ace the interviews. 
Let’s look at the following comprehensive set of C# Interview Questions and Answers which have been categorised below:

What is the difference between an Array and ArrayList in C#?

An array is a collection of similar variables clubbed together under one common name. While ArrayList is a collection of objects that can be indexed individually. With ArrayList you can access a number of features like dynamic memory allocation, adding, searching, and sorting items in the ArrayList. 
When declaring an array the size of the items is fixed therefore, the memory allocation is fixed. But with ArrayList, it can be increased or decreased dynamically.
Array belongs to system.array namespace while ArrayList belongs to the system.collection namespace.
All items in an array are of the same datatype while all the items in an ArrayList can be of the same or different data types.
While arrays cannot accept null, ArrayList can accept null values.

What are Generics in C#?

In C# collections, defining any kind of object is termed okay which compromises C#’s basic rule of type-safety. Therefore, generics were included to type-safe the code by allowing re-use of the data processing algorithms. Generics in C# mean not linked to any specific data type. Generics reduce the load of using boxing, unboxing, and typecasting objects. Generics are always defined inside angular brackets <>. To create a generic class, this syntax is used:

What are extension methods in C#?

Extension methods help to add new methods to the existing ones. The methods that are added are static. At times, when you want to add methods to an existing class but don’t perceive the right to modify that class or don’t hold the rights, you can create a new static class containing the new methods. Once the extended methods are declared, bind this class with the existing one and see the methods will be added to the existing one.

What is the difference between an abstract class and an interface?

Let’s dig into the differences between an abstract class and an interface:
Abstract classes are classes that cannot be instantiated ie. that cannot create an object. The interface is like an abstract class because all the methods inside the interface are abstract methods.
Surprisingly, abstract classes can have both abstract and non-abstract methods but all the methods of an interface are abstract methods.
Since abstract classes can have both abstract and non-abstract methods, we need to use the Abstract keyword to declare abstract methods. But in the interface, there is no such need.
An abstract class has constructors while an interface encompasses none. 

What is a managed and unmanaged code?

Managed code lets you run the code on a managed CLR runtime environment in the .NET framework. 
Managed code runs on the managed runtime environment than the operating system itself. 
Benefits: Provides various services like a garbage collector, exception handling, etc. 
Unmanaged code is when the code doesn’t run on CLR, it is an unmanaged code that works outside the .NET framework. 
They don’t provide services of the high-level languages and therefore, run without them. Such an example is C++. 

What is garbage collection in C#?

Garbage collection is the process of freeing up memory that is captured by unwanted objects. When you create a class object, automatically some memory space is allocated to the object in the heap memory. Now, after you perform all the actions on the object, the memory space occupied by the object becomes waste. It is necessary to free up memory. Garbage collection happens in three cases:
If the occupied memory by the objects exceeds the pre-set threshold value.
If the garbage collection method is called
If your system has low physical memory

What is the difference between String and StringBuilder in C#?

The major difference between String and StringBuilder is that String objects are immutable while StringBuilder creates a mutable string of characters. StringBuilder will make the changes to the existing object rather than creating a new object.
StringBuilder simplifies the entire process of making changes to the existing string object. Since the String class is immutable, it is costlier to create a new object every time we need to make a change. So, the StringBuilder class comes into picture which can be evoked using the System.Text namespace.
In case, a string object will not change throughout the entire program, then use String class or else StringBuilder.

What is Reflection in C#?

Reflection in C# extracts metadata from the datatypes during runtime. 
To add reflection in the .NET framework, simply use System.Refelction namespace in your program to retrieve the type which can be anything from:
Assembly
Module
Enum
MethodInfo
ConstructorInfo
MemberInfo
ParameterInfo
Type
FieldInfo
EventInfo
PropertyInfo

What are the different ways in which a method can be Overloaded in C#?

Overloading means when a method has the same name but carries different values to use in a different context. Only the main() method cannot be overloaded.
In order to overload methods in C#, 
Change the number of parameters in a method, or
Change the order of parameters in a method, or
Use different data types for parameters
In these ways, you can overload a method multiple times.

Difference between the Equality Operator (==) and Equals() Method in C#?

Although both are used to compare two objects by value, still they both are used differently. 
Equality operator (==) is a reference type which means that if equality operator is used, it will return true only if both the references point to the same object.  
Equals() method: Equals method is used to compare the values carried by the objects. int x=10, int y=10. If x==y is compared then, the values carried by x and y are compared which is equal and therefore they return true. 
Equality operator: Compares by reference
Equals(): Compares by value 

What are Indexers in C#?

Indexers are called smart arrays that allow access to a member variable. Indexers allow member variables using the features of an array. They are created using the Indexer keyword. Indexers are not static members. 

What are the Arrays in C#?

When a group of similar elements is clubbed together under one name, they are called arrays. 
For ex. An array of tea Atea[4]: [green tea, chamomile tea, black tea, lemon tea]. The length of the array defines how many elements are present in the array. 
In C#, the memory allocations for the elements of the array happen dynamically.  This is how values are stored in an array sequentially.

What is the difference between late binding and early binding in C#?

Late binding and early binding are examples of one of the primary concepts of OOPS: Polymorphism. 
For ex: one function calculateBill() will calculate bills of premium customers, basic customers, and semi-premium customers based on their policies differently. The calculation for all the customer objects is done differently using the same function which is called polymorphism. 
When an object is assigned to an object variable in C#, the .NET framework performs the binding. 
When the binding function happens at compile-time, it is called early binding. It investigates and checks the methods and properties of the static objects. With early binding, the number of run-time errors decreases substantially and it executes pretty quickly. 
But when the binding happens at runtime, it is called late binding. Late binding happens when the objects are dynamic (decided based on the data they hold) at run-time. It is slower as it looks through during run-time.

What are Properties in C#?

Properties in C# are public members of a class where they provide the ability to access private members of a class. The basic principle of encapsulation lets you hide some sensitive properties from the users by making the variables private. The private members are not accessible otherwise in a class. Therefore, by using properties in C# you can easily access the private members and set their values. 
The values can be easily assigned using get and set methods, also known as accessors. While the get method extracts the value, the set method assigns the value to the variables. 